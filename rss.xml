<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
  <channel>
    <title>Jokeme Blog</title>
    <link>https://jokeme.top</link>
    <atom:link href="https://jokeme.top/rss.xml" rel="self" type="application/rss+xml"/>
    <description>Debug The World</description>
    <generator>Solo, v4.3.1, https://b3log.org/solo</generator>
    <lastBuildDate>Tue, 13 Apr 2021 05:34:14 +0800</lastBuildDate>
    <language>zh-cn</language>
    <item>
      <title>Dockerfile编写</title>
      <link>https://jokeme.top/articles/2021/04/13/1618263133842.html</link>
      <description><![CDATA[<p>今天也是摸鱼的一天没怎么看书,一直在玩Linux。并且在无意间看到了我之前下载的 <a href="https://github.com/DirectoryLister/DirectoryLister" target="_blank">DirectoryLister</a>，就想着在Docker里面部署玩一下。</p>
<p>一开始我是没有想写Dockerfile的，直接在开了一个Ubuntu容器整的，但是想了想，以后想用肯定不方便，这个容器我随时随地都有可以废了它。所以就从网上看了看Dockerfile怎么写，开整！</p>
<p>首先我并不想介绍Dockerfile怎么样去写，网上的教程一大把，自己看就可以了 我是参考<a href="https://www.runoob.com/docker/docker-dockerfile.html" target="_blank">菜鸟教程</a>的教程。</p>
<p>Dockerfile无非就是一个自动化的过程，至少在我看来就是这样的，可能我刚接触了解不深吧。但是按照这个思路是绝对可以写出来Dockerfile的，因为我自己就是例子]]>🌰<![CDATA[。</p>
<p>来看看我的build</p>
<pre><code>7168 ◯ : docker build -t flt:v1.0 .
... ...
Removing intermediate container 8fe78ec98a65
 ---&gt; da56585b17c1
Step 4/4 : CMD ["/root/np.sh"]
 ---&gt; Running in 23bd36103ddd
Removing intermediate container 23bd36103ddd
 ---&gt; 114c7dec7e2f
Successfully built 114c7dec7e2f
Successfully tagged flt:v1.0
</code></pre>
<h2>1. 选择基础镜像</h2>
<p>因为Dockerfile是基于一些底层的镜像制作的，所以在这里我选择的是 <code>ubuntu:20.04</code></p>
<p>因为我平时就是在Ubuntu环境使用的比较多,你要是使用CentOS更顺手你也可以选择使用Redhat系的基础镜像。</p>
<p>这里无可争议，过。</p>
<pre><code>FROM ubuntu:20.04
</code></pre>
<h2>2. 配置环境变量</h2>
<p>其实我这里也没有啥环境变量，我也不知道啥东西要设置为环境变量，就把<strong>DirectoryLister</strong>的版本号设置为环境变量了，方便以后升级。哈哈哈哈，比较菜只能想到这东西了。</p>
<pre><code>ENV DL_VERSION 3.7.7
</code></pre>
<h2>3. 自动化运行命令</h2>
<p>这里也没有啥好说的，有点Linux基础就可以，就是这个写法很操蛋！要不停的 &amp;&amp; ... ... \，至于为什么要这样呢，我查了一下，说是一个RUN就是一层，你要是写太多RUN就会套太多层，非常的臃肿。这些暂时也不是我需要考虑的，别人怎么写，我就怎么写。</p>
<p>这里我遇到了一个自动化安装软件时，需要用户手动输入参数的问题，平时咱手动输入参数可以，但是这自动化的时候可不能这样呀，废了老大劲网上找到了解决办法，就是利用 debconf 提前配置好参数，详细解决办法见<a href="https://ubuntuqa.com/zh-tw/article/7684.html" target="_blank">Ubuntu问答</a> 。</p>
<p>这里我特喵的还是要喷一喷CSDN，妈的一篇帖子万人抄，也不管对不对，往自己的的账号里面薅就对了。妈的好几页都是垃圾文章，浪费我的时间。</p>
<p>自动化里面基本上就是安装软件修改配置等等，强化了一下我的awk和sed。这俩命令太重要了！一定要学好！</p>
<h2>4. CMD命令</h2>
<p>没错我直接跳到了CMD命令，啥<strong>COPY</strong>、<strong>ADD</strong>、<strong>ENTRYPOINT</strong>、<strong>ARG</strong>、<strong>VOLUME</strong>、<strong>EXPOSE</strong>、<strong>WORKDIR</strong>、<strong>USER</strong>、<strong>HEALTHCHECK</strong>、<strong>ONBUILD</strong> 我都没有用上，真的是不知道在哪里用，也用不好，索性就不用了，直接一个CMD就打完收工。</p>
<p>CMD里面的脚本也是我倒腾半天网上学来的，这样写虽然不太优雅，但是总比一开始的时候，一运行就结束了好。说到这我就觉得这里还是有点坑的，因为Docker容器里面必须有一个前台的进程，要是没有进程就会整个容器停止运行，我一开始还傻傻的看网上的教程写nohup，写了半天也不行。然鹅nohup并不是真正的前台进程，因为你再按一次回车就直接退出来了，nohup并没有在前台继续运行，只是nohup的那个命令或者脚本没死在后台活着，但是前台没有进程就会直接退出。正是这种命令或者脚本还活着的幻觉让我们觉得这他妈的Docker是不是有病呀？我这居然还不行！</p>
<p>所以有些东西还是要靠自己慢慢的积累，网上很多东西也都是错误的，不知道我上面的观点对不对，欢迎指正。</p>]]></description>
      <author>JokerLee</author>
      <guid>https://jokeme.top/articles/2021/04/13/1618263133842.html</guid>
      <category>Dockerfile</category>
      <pubDate>Tue, 13 Apr 2021 05:32:13 +0800</pubDate>
    </item>
    <item>
      <title>Nginx目录美化</title>
      <link>https://jokeme.top/articles/2021/03/23/1616436106293.html</link>
      <description><![CDATA[<h1>Nginx目录美化</h1>
<p>我们大家都知道啊! nginx是一个高性能的Web服务器,用于分享文件也是一个非常不错的选择,但是由于Nginx默认的目录太丑了, 都不好意思拿出手。这就有了本篇文章。</p>
<p>先来说一下我的环境: <code>Ubuntu 20.04.1</code> ，<code>Nginx 1.18</code></p>
<h2>1. 添加Index.html至主机根目录</h2>
<pre><code>nano index.html
</code></pre>
<p>内容如下</p>
<pre><code>&lt;!-- autoindex.html 21.02, see https://phus.lu --&gt;
&lt;script&gt;
!function(){
	var website_title = ''
	var datetime_format = '%Y-%b-%d %H:%M'
	var show_readme_md = true
	var enable_footer_js = true
	var max_name_length = 20

	var dom = {
		element: null,
		get: function (o) {
			var obj = Object.create(this)
			obj.element = (typeof o == "object") ? o : document.createElement(o)
			return obj
		},
		add: function (o) {
			var obj = dom.get(o)
			this.element.appendChild(obj.element)
			return obj
		},
		text: function (t) {
			this.element.appendChild(document.createTextNode(t))
			return this
		},
		html: function (s) {
			this.element.innerHTML = s
			return this
		},
		attr: function (k, v) {
			this.element.setAttribute(k, v)
			return this
		}
	}

	head = dom.get(document.head)
	head.add('meta').attr('charset', 'utf-8')
	head.add('meta').attr('name', 'viewport').attr('content', 'width=device-width,initial-scale=1')

	if (!document.title) {
		document.write(["&lt;div class=\"container\"&gt;",
		"&lt;h3&gt;nginx.conf&lt;/h3&gt;",
		"&lt;textarea rows=8 cols=50&gt;",
		"# download autoindex.html to /wwwroot/",
		"location ~ ^(.*)/$ {",
		"    charset utf-8;",
		"    autoindex on;",
		"    autoindex_localtime on;",
		"    autoindex_exact_size off;",
		"    add_after_body /autoindex.html;",
		"}",
		"&lt;/textarea&gt;",
		"&lt;/div&gt;"].join("\n"))
		return
	}

	var bodylines = document.body.innerHTML.split('\n')
	document.body.innerHTML = ''

	var titlehtml = document.title.replace(/\/$/, '').split('/').slice(1).reduce(function(acc, v, i, a) {
		return acc + '&lt;a href="/' + a.slice(0, i+1).join('/') + '/"&gt;' + v + '&lt;/a&gt;/'
	}, '&lt;a href="/"&gt;Index&lt;/a&gt; of /')
	if (website_title) {
		document.title = website_title + ' - ' + document.title
	}
	head.add('meta').attr('name', 'description').attr('content', document.title)

	div = dom.get('div').attr('class', 'container')
	div.add('table').add('tbody').add('tr').add('th').html(titlehtml)
	tbody = div.add('table').attr('class', 'table-hover').add('tbody')

	names = ['Name', 'Date', 'Size']
	thead = tbody.add('tr')
	for (i = 0; i &lt; names.length; i++)
		thead.add('td').add('a').attr('href', 'javascript:sortby('+i+')').attr('class', 'octicon arrow-up').text(names[i]);

	var insert = function(filename, datetime, size) {
		if (/\/$/.test(filename)) {
			css = 'file-directory'
			size = ''
		} else if (/\.(zip|7z|bz2|gz|tar|tgz|tbz2|xz|cab)$/.test(filename)) {
			css = 'file-zip'
		} else if (/\.(py|js|php|pl|rb|sh|bash|lua|sql|go|rs|java|c|h|cpp|cxx|hpp|css|html|)$/.test(filename)) {
			css = 'file-code'
		} else if (/\.(jpg|png|bmp|gif|ico|webp)$/.test(filename)) {
			css = 'file-media'
		} else if (/\.(flv|mp4|mkv|avi|mkv|vp9|m3u8)$/.test(filename)) {
			css = 'device-camera-video'
		} else {
			css = 'file'
		}

		displayname = decodeURIComponent(filename.replace(/\/$/, ''))
		if (displayname.length &gt; max_name_length)
			displayname = displayname.substring(0, max_name_length-3) + '..&gt;';

		if (!isNaN(Date.parse(datetime))) {
			d = new Date(datetime)
			pad = function (s) {return s &lt; 10 ? '0' + s : s}
			mon = function (m) {return ['01','02','03','04','05','06','07','08','09','10','11','12'][m]}
			datetime = datetime_format
					.replace('%Y', d.getFullYear())
					.replace('%m', pad(d.getMonth()+1))
					.replace('%d', pad(d.getDate()))
					.replace('%H', pad(d.getHours()))
					.replace('%M', pad(d.getMinutes()))
					.replace('%S', pad(d.getSeconds()))
					.replace('%b', mon(d.getMonth()))
		}

		tr = tbody.add('tr')
		tr.add('td').add('a').attr('class', 'octicon ' + css).attr('href', filename).text(displayname)
		tr.add('td').text(datetime)
		tr.add('td').text(size)
	}

	var readme = '', footer = ''
	insert('../', '', '-')
	for (var i in bodylines) {
		if (m = /\s*&lt;a href="(.+?)"&gt;(.+?)&lt;\/a&gt;\s+(\S+)\s+(\S+)\s+(\S+)\s*/.exec(bodylines[i])) {
			filename = m[1]
			datetime = m[3] + ' ' + m[4]
			size = m[5]
			insert(filename, datetime, size)
			switch (filename.toLowerCase()) {
			case 'readme.md':
				readme = filename
				break
			case 'footer.js':
				footer = filename
				break
			}
		}
	}

	document.body.appendChild(div.element)

	if (show_readme_md &amp;&amp; readme !== '') {
		tbody = div.add('table').add('tbody');
		tbody.add('tr').add('th').attr('class', 'octicon octicon-book').text(readme)
		tbody.add('tr').add('td').add('div').attr('id', 'readme').attr('class', 'markdown-body')
		xhr = new XMLHttpRequest()
		xhr.open('GET', location.pathname.replace(/[^/]+$/, '')+readme, true)
		xhr.onload = function() {
			if (xhr.status &lt; 200 &amp;&amp; xhr.status &gt;= 400)
				return
			wait = function (name, callback) {
				var interval = 10; // ms
				window.setTimeout(function() {
					if (window[name]) {
						callback(window[name])
					} else {
						window.setTimeout(arguments.callee, interval)
					}
				}, interval)
			}
			wait('marked', function() {
				document.getElementById("readme").innerHTML = marked(xhr.responseText)
			})
		}
		xhr.send()

		div.add('script').attr('src', 'https://cdn.staticfile.org/marked/0.7.0/marked.min.js')
		div.add('link').attr('rel', 'stylesheet').attr('href', 'https://cdn.staticfile.org/github-markdown-css/3.0.1/github-markdown.min.css')
	}

	if (enable_footer_js &amp;&amp; footer !== '') {
		div.add('script').attr('src', footer)
	}
}()

function sortby(index) {
	rows = document.getElementsByClassName('table-hover')[0].rows
	link = rows[0].getElementsByTagName('a')[index]
	arrow = link.className == 'octicon arrow-down' ? 1 : -1
	link.className = 'octicon arrow-' + (arrow == 1 ? 'up' : 'down');
	[].slice.call(rows).slice(2).map(function (e, i) {
		type = e.getElementsByTagName('a')[0].className == 'octicon file-directory' ? 0 : 1
		text = e.getElementsByTagName('td')[index].innerText
		if (index === 0) {
			value = text
		} else if (index === 1) {
			value = new Date(text).getTime()
		} else if (index === 2) {
			m = {'G':1024*1024*1024, 'M':1024*1024, 'K':1024}
			value = parseInt(text || 0) * (m[text[text.search(/[KMG]B?$/)]] || 1)
		}
		return {type: type, value: value, index: i, html: e.innerHTML}
	}).sort(function (a, b) {
		if (a.type != b.type)
			return a.type - b.type
		if (a.value != b.value)
			return a.value &lt; b.value ? -arrow : arrow
		return a.index &lt; b.index ? -arrow : arrow
	}).forEach(function (e, i) {
		rows[2+i].innerHTML = e.html
	})
}
&lt;/script&gt;

&lt;style&gt;
body {
	margin: 0;
	font-family: "ubuntu", "Tahoma", "Microsoft YaHei", Arial, Serif;
}
.container {
	padding-right: 15px;
	padding-left: 15px;
	margin-right: auto;
	margin-left: auto;
}
@media (min-width: 768px) {
	.container {
		max-width: 750px;
	}
}
@media (min-width: 992px) {
	.container {
		max-width: 970px;
	}
}
@media (min-width: 1200px) {
	.container {
		max-width: 1170px;
	}
}
table {
	width: 100%;
	margin-bottom: 20px;
	border: 1px solid #ddd;
	border-collapse: collapse;
}
table th {
	font-size: 14px;
}
table tr {
	border: 1px solid #ddd;
}
table tr:nth-child(odd) {
	background: #dfdfdf
}
table th, table td {
	border: 1px solid #ddd;
	line-height: 25px;
    width:auto;
	text-align: left;
}
a {
	color: #369;
	text-decoration: none;
}
a:hover, a:focus {
	color: #2a6496;
	text-decoration: underline;
}
table.table-hover &gt; tbody &gt; tr:hover &gt; td,
table.table-hover &gt; tbody &gt; tr:hover &gt; th {
	background-color: #f5f5f5;
}
.markdown-body {
	float: left;
	font-family: "ubuntu", "Tahoma", "Microsoft YaHei", Arial, Serif;
}
/* octicons */
.octicon {
	background-position: center left;
	background-repeat: no-repeat;
	padding-left: 25px;
}
.file {
	background-image: url("data:image/png;base64,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");
	background-repeat: no-repeat;
	background-size: 20px 20px;
}
.file-directory {
	background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIAAAACACAYAAADDPmHLAAAFWklEQVR4Xu2ZS2icZRiFzztJ01yMpFYTTU0Fo9GQaVIxShW84i1Jc1Ek4Mp0VxDdKbpSwUVFBLt0VQpu6qK2XqDaagVF0aJIOlWqCKVFoa02wbTNkHHmF4Wu1PzTzvtl5sx3up3O+c/7nIc/pTHoT9QELOrrdTwkQOQSSAAJEDmByM/XG0ACRE4g8vP1BpAAkROI/Hy9ASRA5AQiP19vAAkQOYHIz9cbQAJETiDy8/UGkACRE4j8fL0BJEDkBCI/X28ACRA5gcjPv6g3QLJ3cAKl4vWAddQktwzOIbEjmFv4xLYcy9dkxxorVZYAye6hPmSKbwK4t8b6/1+dBSR42R7NvU7St2o1yxNgb3YRCZqr1vJSH5zBuE3k3r/Ur8fwvVQBkneyL8HwIimM92wqN0HafUVqpwuwZ2AHYDMr0ibEQxoyt9r47LchoushswwBsgeJfvb/exPDczaZe60exgpxQwQC2D6bPDwSAl49ZNa/AEABQK9N5U7Uw2DeN8QgAGDJjE0e2ekNrx7y4hBgTf9J9D/5Qz0MtuwNCU4jwT50nd9pNl0s5944BGi6HLjlWSCzqhwm/H/HMI9SstWuHt+Vdky6AO8OH0IpP5wWVPOf928BOm6q+ZqOBRMsNV5pPY+cWS4zXYAP7/8Fi6e6HYtVJ6r7LuC6seo8u1pPNXvBOse2VSbAgdHzOHu8pVo3uD23rRsYfMYtjiRov3VtfqgyAT4eXcTCcb7fA/zX1RueAi7rIdnOoabhU+vcfJ8EuEBg/Qiw7h4HsiQRrgI0JUBrAjSXgAwJgNhqNrQDrUNA+53Aqk7ATQAca0Z7KTac3PeunQbab3f4EXDwwTzaTqzmphFp+55XPrNrHr+7sn8DfL6pgKb5xkgRcp/d8fBP1re9rzIBvhwsoWEp9f8LuEnVafuW3t9swwdXVSbAV9kS7E8JwOhI07XztvHAGgnAOJ5HZwngQZE4QwIQj+dRXQJ4UCTOkADE43lUlwAeFIkzJADxeB7VJYAHReIMFwG+3lgE8vr9H6MHLgJ8s6mAon4XwLg/JADlbH6lJYAfS8okCUA5m19pCeDHkjJJAlDO5ldaAvixpEySAJSz+ZWWAH4sKZMkAOVsfqUlgB9LyiQJQDmbX2kJ4MeSMkkCUM7mV1oC+LGkTJIAlLP5lZYAfiwpkyQA5Wx+pSWAH0vKJAlAOZtfaQngx5IySQJQzuZXWgL4saRMkgCUs/mVlgB+LCmTJADlbH6lJYAfS8okCUA5m19pCeDHkjJJAlDO5ldaAvixpEySAJSz+ZWWAH4sKZMkAOVsfqUlgB9LyiQJQDmbX2kJ4MeSMkkCUM7mV1oC+LGkTJIAlLP5lZYAfiwpkyQA5Wx+pSWAH0vKJAlAOZtfaQngx5IySQJQzuZXWgL4saRMkgCUs/mVlgB+LCmTJADlbH6lJYAfS8okCUA5m19pCeDHkjLJR4A7CijONVICiL306vVzNvTRFcthsDRGyeHHfsfi98uGpGXo8yoRaBs+agNv3VyZAD8+vQPz+2eqdIIeWwmBtVPPW++2VysS4O8vJ7NjZ5H/ua2SLvruChNoHfrVsrvWpT019UfAPwKcevsGnN69B+e+G0gL1Oc1QKD9ti/Q+MSI3Tj6R1qbsgS4EJKcfKMLZ2a3olToSQvW51Ug0NByFMUHttvA9FK5T78oAcoN1d/jISABeLYK0lQCBMHKEyoBeLYK0lQCBMHKEyoBeLYK0lQCBMHKEyoBeLYK0lQCBMHKEyoBeLYK0lQCBMHKEyoBeLYK0lQCBMHKEyoBeLYK0lQCBMHKEyoBeLYK0lQCBMHKE/oXjq52n+wTU1kAAAAASUVORK5CYII=");
	background-repeat: no-repeat;
	background-size: 20px 20px;
}
.file-zip {
	background-image: url("data:image/png;base64,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");
	background-repeat: no-repeat;
	background-size: 20px 20px;
}
.file-code {
	background-image: url("data:image/png;base64,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");
	background-repeat: no-repeat;
	background-size: 20px 20px;
}
.file-media {
	background-image: url("data:image/png;base64,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");
	background-repeat: no-repeat;
	background-size: 20px 20px;
}
.device-camera-video {
	background: url("data:image/png;base64,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");
	background-repeat: no-repeat;
	background-size: 20px 20px;
}
.octicon-book {
	padding-left: 20px;
	background-image: url("data:image/svg+xml;charset=utf8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='16' height='16' viewBox='0 0 16 16'%3E%3Cpath d='M3,5 L7,5 L7,6 L3,6 L3,5 L3,5 Z M3,8 L7,8 L7,7 L3,7 L3,8 L3,8 Z M3,10 L7,10 L7,9 L3,9 L3,10 L3,10 Z M14,5 L10,5 L10,6 L14,6 L14,5 L14,5 Z M14,7 L10,7 L10,8 L14,8 L14,7 L14,7 Z M14,9 L10,9 L10,10 L14,10 L14,9 L14,9 Z M16,3 L16,12 C16,12.55 15.55,13 15,13 L9.5,13 L8.5,14 L7.5,13 L2,13 C1.45,13 1,12.55 1,12 L1,3 C1,2.45 1.45,2 2,2 L7.5,2 L8.5,3 L9.5,2 L15,2 C15.55,2 16,2.45 16,3 L16,3 Z M8,3.5 L7.5,3 L2,3 L2,12 L8,12 L8,3.5 L8,3.5 Z M15,3 L9.5,3 L9,3.5 L9,12 L15,12 L15,3 L15,3 Z' /%3E%3C/svg%3E");
}
.arrow-down {
	font-weight: bold;
	text-decoration: none !important;
	background-image: url("data:image/svg+xml;charset=utf8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='10' height='16' viewBox='0 0 10 16'%3E%3Cpolygon id='Shape' points='7 7 7 3 3 3 3 7 0 7 5 13 10 7'%3E%3C/polygon%3E%3C/svg%3E");
}
.arrow-up {
	font-weight: bold;
	text-decoration: none !important;
	background-image: url("data:image/svg+xml;charset=utf8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='10' height='16' viewBox='0 0 10 16'%3E%3Cpolygon id='Shape' points='5 3 0 9 3 9 3 13 7 13 7 9 10 9'%3E%3C/polygon%3E%3C/svg%3E");
}
&lt;/style&gt;
</code></pre>
<h2>2. 编辑Nginx里的主机配置</h2>
<p>nginx 配置如下</p>
<pre><code>location ~ ^(.*)/$ {
    charset utf-8;
    autoindex on;
    autoindex_localtime on;
    autoindex_exact_size off;
    add_after_body /autoindex.html;
}
</code></pre>
<h2>3. 重启Nginx</h2>
<p>这个时候你就会发现默认的目录已经变好看了一丢丢，当然你可以基于这些代码继续更改。直到你满意为止。</p>
<p>本文参考 ：<a href="https://www.91yunbbs.com/discussion/441/autoindex-html" target="_blank"><strong>91yun论坛</strong></a> 	侵联删</p>]]></description>
      <author>JokerLee</author>
      <guid>https://jokeme.top/articles/2021/03/23/1616436106293.html</guid>
      <category>nginx</category>
      <pubDate>Tue, 23 Mar 2021 11:32:10 +0800</pubDate>
    </item>
    <item>
      <title>ffmpeg设置请求头</title>
      <link>https://jokeme.top/articles/2021/03/23/1616437882432.html</link>
      <description><![CDATA[<p>ffmpeg是一款非常强大的工具,它可以在命令行下对视频类文件进行多种操作,之前我也介绍过ffmpeg,<a href="https://jokeme.top/articles/2020/04/15/1586944809634.html">戳这里</a></p>
<p>在使用过程中我们经常可以遇到使用ffmpeg无法下载文件的情况,那这是为什么呢？</p>
<p>其实有时候,服务端会对我们客户端的请求进行检验,其中最简单的就是检查请求头：<strong>User-Agent</strong> ，如果你连请求头都没,那你肯定就暴露了你不是正常的用户，你既然不是正常的用户，那那服务器那边就会拒绝你的访问请求，所以就导致了你被403。</p>
<p>既然这样那咱们简单设置一下请求头就可以了：</p>
<pre><code>ffmpeg -user_agent "User-Agent: AppleCoreMedia/1.0.0.18C66 (iPhone; U; CPU OS 14_3 like Mac OS X; zh_cn)" -i https://www.baidu.com/xxx.mp4\?id\=2399977 -c copy str4.mp4
</code></pre>
<p>当你设置了请求头以后你还别高兴太早了！因为服务器那边既然开启了检测，就不会通过这麽简单的方法来拦截非正常用户的访问。一般来说还有各种<strong>headers</strong></p>
<p>这时我们就需要通过抓包来获得具体的请求头里的参数了，下面我就简单的介绍一下具体的参数该如何写。注意 <code>$'\r\n'</code>这是一种换行的写法。</p>
<pre><code>ffmpeg -user_agent "User-Agent: AppleCoreMedia/1.0.0.18C66 (iPhone; U; CPU OS 14_3 like Mac OS X; zh_cn)" -headers "Authorization: fudkmnso-... ...9-0sdf-0ea"$'\r\n'"Xplay-session-ID:9885998" -i https://www.baidu.com/xxx.mp4\?id\=2399977 -c copy str4.mp4
</code></pre>]]></description>
      <author>JokerLee</author>
      <guid>https://jokeme.top/articles/2021/03/23/1616437882432.html</guid>
      <category>ffmpeg</category>
      <pubDate>Tue, 23 Mar 2021 02:31:22 +0800</pubDate>
    </item>
    <item>
      <title>macOS设置brew安装的软件自启动</title>
      <link>https://jokeme.top/articles/2021/02/22/1614003754505.html</link>
      <description><![CDATA[<h2>1. Home-brew 简介</h2>
<p>先介绍一下本篇文章的主角：<strong><a href="https://brew.sh/" target="_blank">Home-brew</a></strong>，它是一款<strong>macOS</strong>的软件包管理器，当然也同样适用于<strong>Linux</strong>（不会真的有人 Linux 服务器用 brew 吧？）。</p>
<p>它的官网上有关于 brew 非常详细的文档，大家可以自己去看看。介绍了以后就到了我们的安装环节了！</p>
<h2>2. 安装 Brew</h2>
<p>安装 brew 非常的简单，就需要一条命令就可以了，当然大家 99% 会遇到网络问题，安装过程中建议最好用 v 要不然缓慢的到超时的网络会让你年轻漂亮有活力的 ?！</p>
<pre><code class="language-shell">/bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"
</code></pre>
<h2>3. brew 换源</h2>
<p>平时我们执行 brew 命令安装软件的时候，跟以下 3 个仓库地址有关：</p>
<ol>
<li>brew.git</li>
<li>homebrew-core.git</li>
<li>homebrew-bottles</li>
</ol>
<p>通过以下操作将这 3 个仓库地址全部替换为 Alibaba 提供的地址</p>
<h3>1. 替换 / 还原 brew.git 仓库地址</h3>
<pre><code># 替换成阿里巴巴的 brew.git 仓库地址:
cd "$(brew --repo)"
git remote set-url origin https://mirrors.aliyun.com/homebrew/brew.git
#=======================================================
# 还原为官方提供的 brew.git 仓库地址
cd "$(brew --repo)"
git remote set-url origin https://github.com/Homebrew/brew.git
</code></pre>
<h3>2. 替换 / 还原 homebrew-core.git 仓库地址</h3>
<pre><code># 替换成阿里巴巴的 homebrew-core.git 仓库地址:
cd "$(brew --repo)/Library/Taps/homebrew/homebrew-core"
git remote set-url origin https://mirrors.aliyun.com/homebrew/homebrew-core.git
#=======================================================
# 还原为官方提供的 homebrew-core.git 仓库地址
cd "$(brew --repo)/Library/Taps/homebrew/homebrew-core"
git remote set-url origin https://github.com/Homebrew/homebrew-core.git
</code></pre>
<h3>3. 替换 / 还原 homebrew-bottles 访问地址</h3>
<p>这个步骤跟你的 macOS 系统使用的 shell 版本有关系</p>
<p>所以，先来查看当前使用的 shell 版本</p>
<pre><code>echo $SHELL
# 如果你的输出结果是 /bin/zsh，参考?的 zsh 终端操作方式
# 如果你的输出结果是 /bin/bash，参考?的 bash 终端操作方式
</code></pre>
<h4>3.1 zsh 终端操作方式</h4>
<pre><code># 替换成阿里巴巴的 homebrew-bottles 访问地址:
echo 'export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.aliyun.com/homebrew/homebrew-bottles' &gt;&gt; ~/.zshrc
source ~/.zshrc
#=======================================================
# 还原为官方提供的 homebrew-bottles 访问地址
vi ~/.zshrc
# 然后，删除 HOMEBREW_BOTTLE_DOMAIN 这一行配置
source ~/.zshrc
</code></pre>
<h4>3.2 bash 终端操作方式</h4>
<pre><code># 替换 homebrew-bottles 访问 URL:
echo 'export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.aliyun.com/homebrew/homebrew-bottles' &gt;&gt; ~/.bash_profile
source ~/.bash_profile
#=======================================================
# 还原为官方提供的 homebrew-bottles 访问地址
vi ~/.bash_profile
# 然后，删除 HOMEBREW_BOTTLE_DOMAIN 这一行配置
source ~/.bash_profile
</code></pre>
<h2>4. 安装软件</h2>
<p>当我们已经配置好国内源时，我们就可以正式使用 brew 来安装一些软件了</p>
<p>eg：</p>
<pre><code>JokerMBP L-:cactus:-轩-:fallen_leaf:-X ~ 
812 ◯ : brew install nginx                                                ⏎ [~]
==&gt; Downloading https://mirrors.tuna.tsinghua.edu.cn/homebrew-bottles/bottles/ng
==&gt; Downloading from https://d29vzk4ow07wi7.cloudfront.net/9deda8734db308f21e3c8
######################################################################## 100.0%
==&gt; Pouring nginx-1.19.5.big_sur.bottle.tar.gz
==&gt; Caveats
Docroot is: /usr/local/var/www

The default port has been set in /usr/local/etc/nginx/nginx.conf to 8080 so that
nginx can run without sudo.

nginx will load all files in /usr/local/etc/nginx/servers/.

To have launchd start nginx now and restart at login:
  brew services start nginx
Or, if you don't want/need a background service you can just run:
  nginx
==&gt; Summary
:beer:  /usr/local/Cellar/nginx/1.19.5: 25 files, 2.2MB
==&gt; `brew cleanup` has not been run in 30 days, running now...
Pruned 0 symbolic links and 1 directories from /usr/local
</code></pre>
<p>可以看到在安装完成后 brew 给了我们很多有用的信息</p>
<p>我先来总结一下：</p>
<p>1：<strong>Docroot is: /usr/local/var/www</strong></p>
<p>默认文档位置在 <strong>/usr/local/var/www</strong></p>
<p>2：<strong>The default port has been set in /usr/local/etc/nginx/nginx.conf to 8080</strong></p>
<p>你丫的没有用<strong>sudo</strong>安装，我只能把默认端口给设置为 8080，你丫要是想改默认端口就要修改 <strong>/usr/local/etc/nginx/nginx.conf</strong>里的配置</p>
<p>3：<strong>To have launchd start nginx now and restart at login: brew services start nginx</strong></p>
<p>你小子要想让 nginx 开机自启动就要运行： <code>brew services start nginx</code></p>
<p>4：<strong>if you don't want/need a background service you can just run: nginx</strong></p>
<p>你小子 <del>要死</del> 要是想让 nginx 不开机自启动，直接运行命令： <code>nginx</code> 就可以了。</p>
<p>就这一小段话，如果你没有注意，或者直接忽略了，那你可能在以后的使用过程中就会遇到很多的麻烦事！而且百度还可能找不到问题的答案！所以我就建议大家在安装完软件以后留意一下这个<strong>Tips</strong>。</p>
<h2>5. 设置软件开机自启</h2>
<p>既然 brew 可以设置开机自启动那这篇文章还有啥意义？</p>
<p>其实只是想让大家了解 macOS 开机自启的原理而已</p>
<p>现在大家应该都知道了 brew 安装软件的具体位置了，没错就是在 <code>/usr/local/Cellar</code> 文件夹下面，比如说我安装的 nginx 就在 <code>/usr/local/Cellar/nginx/</code> 下面。我们不妨看看文件夹里面有啥：</p>
<pre><code class="language-shell">JokerMBP L-?-轩-?-X /usr/local/Cellar/nginx 
978 ◯ : ls 1.19.5                                                                                                                                                                                                                       total 640
-rw-r--r--  1 frelon  staff   300K 11 24 23:06 CHANGES
-rw-r--r--  1 frelon  staff   791B  2 22 20:09 INSTALL_RECEIPT.json
-rw-r--r--  1 frelon  staff   1.4K 11 24 23:06 LICENSE
-rw-r--r--  1 frelon  staff    49B 11 24 23:06 README
drwxr-xr-x  3 frelon  staff    96B 11 24 23:06 bin
-rw-r--r--  1 frelon  staff   571B  2 22 20:09 homebrew.mxcl.nginx.plist
lrwxr-xr-x  1 frelon  staff    16B  2 22 20:09 html -&gt; ../../../var/www
drwxr-xr-x  4 frelon  staff   128B 11 24 23:06 share
</code></pre>
<p>可以看到啊，哪里有一个显眼的 ==.plist== 结尾的文件，此时此刻我相信大家心里面肯定有答案了，开机自启动肯定和这个文件有着千丝万缕的关系。大家不要急哈，一步一步来！先把这个文件软连接到 <code>/Library/LaunchAgents/</code> 目录下，然后就可以执行</p>
<pre><code>launchctl load /Library/LaunchAgents/homebrew.mxcl.xxx.plist
</code></pre>
<p>此时此刻这个软件就可以开机自启了！要知道有一些小众软件并不能通过 brew 安装，我们只能手动编译安装，这个时候如果我们想要使它开机自启动怎么办？没有了 brew 是不是突然就不知所措了！其实这个 ==.plist== 文件我们自己也是可以手动编写的，我们再通过上面的步骤是不是就可以很容易的就让一个自己编译的软件开机自启动了。</p>
<p>本文参考博客园用户：<a href="https://www.cnblogs.com/wuygblog/" target="_blank">wygbbb</a> &amp; <a href="https://www.cnblogs.com/tulintao/" target="_blank">tulintao</a> 的文章而写，侵联删。</p>]]></description>
      <author>JokerLee</author>
      <guid>https://jokeme.top/articles/2021/02/22/1614003754505.html</guid>
      <category>macOS</category>
      <category>brew</category>
      <pubDate>Mon, 22 Mar 2021 12:20:03 +0800</pubDate>
    </item>
    <item>
      <title>收集整理一些我不经常使用,但是使用时又找不到的网站链接</title>
      <link>https://jokeme.top/articles/2020/07/03/1593769988253.html</link>
      <description><![CDATA[<p><a href="https://" target="_blank"></a>所有排名不分先后，我是看到一个收录一个</p>
<ol>
<li><a href="http://downloads.pangubox.com:6380/pandorabox/" target="_blank">Pandorabox 固件官网</a></li>
<li><a href="https://shields.io" target="_blank">Shields.io</a></li>
<li><a href="http://patorjk.com/software/taag" target="_blank">ascii</a></li>
<li><a href="https://www.microsoft.com/zh-cn/software-download/windows10" target="_blank">Windows 10下载</a></li>
<li><a href="https://www.iconfont.cn/" target="_blank">Iconfont</a></li>
<li><a href="http://www.lanzou.com/" target="_blank">蓝奏云</a></li>
<li><a href="https://www.remove.bg/" target="_blank">RM bg</a></li>
<li><a href="https://www.right.com.cn/forum/thread-4015141-1-1.html" target="_blank">小米路由器 3 刷机</a></li>
<li><a href="https://mirom.ezbox.idv.tw/" target="_blank">MiUi / Router OS</a></li>
<li><a href="https://cmwtat.cloudmoe.com/cn.html" target="_blank">Windows 10 激活</a></li>
<li><a href="https://uigradients.com/" target="_blank">渐变色 css</a></li>
<li><a href="https://pc.qq.com/" target="_blank">腾讯软件管家网页版</a></li>
<li><a href="https://www.electronjs.org/docs" target="_blank">Electron文档</a></li>
<li><a href="https://msdn.itellyou.cn/" target="_blank">MSDN</a></li>
<li><a href="https://mirrors.ustc.edu.cn/repogen/" target="_blank">中科大软件源生成</a></li>
<li><a href="https://zshguide.readthedocs.io/zh/latest/" target="_blank">zsh编程指南</a></li>
<li><del><a href="https://mfi.apple.com/MFiWeb/getAPS.action" target="_blank">MFI查询</a></del> <a href="https://mfi.apple.com/account/accessory-search" target="_blank">新MFI查询</a></li>
<li><a href="https://github.com/zhongyang219/TrafficMonitor/" target="_blank">TrafficMonitor</a></li>
<li><a href="https://www.snipaste.com/" target="_blank">Snipaste截图工具</a></li>
<li><a href="https://firmianay.gitbook.io/ctf-all-in-one/" target="_blank">CTF</a></li>
<li><a href="https://start.aliyun.com" target="_blank">Aliyun Springboot Initialize</a></li>
<li><a href="https://adoptopenjdk.net/" target="_blank">JDK下载</a></li>
<li><a href="https://www.macbl.com/" target="_blank">马可菠萝macos</a></li>
<li><a href="https://xclient.info/" target="_blank">xclientmacos</a></li>
<li><a href="https://macwk.com/" target="_blank">macwk</a></li>
<li><a href="http://www.coolsite360.com/resources/hao.html" target="_blank">网页设计导航</a></li>
</ol>]]></description>
      <author>JokerLee</author>
      <guid>https://jokeme.top/articles/2020/07/03/1593769988253.html</guid>
      <category>links</category>
      <pubDate>Sun, 21 Mar 2021 12:38:26 +0800</pubDate>
    </item>
    <item>
      <title>记录最近捯饬Linux的收获</title>
      <link>https://jokeme.top/articles/2021/03/21/1616297937888.html</link>
      <description><![CDATA[<h1>记录最近捯饬Linux的收获</h1>
<p>虽然最近在准备专升本考试吧，但是也没有认真的复习，最近还是天天玩Linux，在这里记录一下。</p>
<h2>1. Windows Terminal设置</h2>
<p>如果你关注IT圈的话，你一定知道微软在<strong>Github</strong>开源了新的<strong>Terminal</strong>，并且这是一个颜值高,用着爽的全新版本,支持<strong>Unicode</strong>。这些都是后话，我要说的是<strong>WSL</strong>和<strong>Terminal</strong>相关的设置。因为<strong>Terminal</strong>打开<strong>WSL</strong>默认的路径是该用户的在<strong>Windows</strong>下的家目录，而此时你就需要修改<code>setting.json</code>对应位置添加以下配置：<code>"startingDirectory": "//wsl$/Ubuntu-18.04/home/frelon"</code></p>
<p>如果你还没有用过<a href="https://github.com/microsoft/terminal/releases" target="_blank"><strong>Windows Terminal</strong></a>那你可以先看看这个<a href="https://docs.microsoft.com/zh-cn/windows/terminal/" target="_blank">Windows Terminal的简介</a></p>
<h2>2. aria2下载</h2>
<p>众所周知，<strong><a href="https://github.com/aria2/aria2/releases/tag/release-1.35.0" target="_blank">aria2</a><strong>是一款非常好用的一款下载工具，并且它开源，体积小，运行效率高等。什么？你没有听说过？那你总听说过</strong>Motrix</strong>吧！什么你还没有听说过？那你一定知道<strong>PanDown</strong>吧？没错这款伟大的软件就是基于<strong>aria2</strong>。</p>
<p>aria2本身只是命令行工具，所以我们可以在命令行里安装它。</p>
<pre><code>sudo apt install aira2
</code></pre>
<p>如果你只是简简单单的下载文件，那<strong>curl</strong> 和 <strong>wget</strong> <strong>aira2</strong>是没有啥大的区别的。额说到这里哈，就不得不说今天是curl的23岁生日，curl是 <a href="https://curl.se/docs/history.html" target="_blank"><em>March 20. 1998</em></a> 年发布的。没错！确实是23年前的今天！因为时差的原因，那边还是20号，咱们这边已经21号了，不是我记错了。</p>
<p>然后我就根据我个人的使用习惯给<strong>alias</strong>一下了，因为我不喜欢这种字母和数组夹杂的命令，遇到了都会给重命名一下方便以后自己敲命令。</p>
<pre><code>alias ac="aria2c"
</code></pre>
<p>首先既然是下载工具，那我为什么要用<strong>aria2</strong>？</p>
<p>我们先来看看aria2支持啥协议</p>
<p><strong>URI, MAGNET, TORRENT_FILE, METALINK_FILE</strong></p>
<p>传统的http，https，ftp，磁力。bt种子，metalink。你就说它强大不强大吧，可以在这么小体量的情况下，做这么多事情。现在你知道为什么这么多人夸赞它了吧。</p>
<p>现在我们来说说看Windows这边的下载巨头：迅雷。</p>
<p>为什么我们都瞧不起迅雷？</p>
<p>因为迅雷是白眼狼，喝BT的血起家，把自己养肥了。到最后迅雷却不反哺BT下载的生态圈。就这一点就足够可耻的了。</p>
<h2>3. 获取CPU温度</h2>
<pre><code>echo `echo "scale=2; $(cat /sys/class/thermal/thermal_zone2/temp)/1000" | bc` °C
</code></pre>
<p>用<strong>Ubuntu 20</strong>的小伙伴可以直接用这条命令查看cpu温度，Ubuntu18我还没有试过，别的系统我就不得而知了。</p>
<h2>4. awk 、sed</h2>
<p>awk 是一个文本处理命令，常用的就是查找文本内部的字符。</p>
<p>默认情况下awk是用空格来分割，</p>
<pre><code>awk '{print $1}'
</code></pre>
<p>如果你想用特定的字符串分割,可以用 <code>-F</code>来指定。</p>
<pre><code>awk -F/ '{print $1}'
</code></pre>
<hr>
<p>sed它同样也是文本处理，用来替换文本的，最常用到的可能就是在刚安装完系统后换软件源的时候。用国内的<strong>url</strong>来替换国外的<strong>url</strong></p>
<pre><code>sed -i 's/xxx/yyy/g' filename
</code></pre>
<p>这个就是把文件内部的xxx替换为yyy。如果需要在文件行首添加字符，就可以<code>sed -i 's/^/yyy/g' filename</code>，有行首肯定是有行尾，那行尾把 <code>^</code>换成<code>$</code>就可以了。</p>]]></description>
      <author>JokerLee</author>
      <guid>https://jokeme.top/articles/2021/03/21/1616297937888.html</guid>
      <category>Linux</category>
      <pubDate>Sun, 21 Mar 2021 11:38:57 +0800</pubDate>
    </item>
    <item>
      <title>Ubuntu 20.04.2 配置 vsftpd 的脑坑</title>
      <link>https://jokeme.top/articles/2021/03/01/1614537942569.html</link>
      <description><![CDATA[<h1>Ubuntu 20.04.2 配置 vsftpd 的脑坑</h1>
<p>今天是 2020-03-01 02:13:13，刚结束了我在我哥饭店帮忙的欢乐时光，刚下班回来的我就准备掏出我的大宝贝好好的爽一爽，毕竟大半个月都没有咋用我的电脑了。因为之前刚换的<strong>Ubuntu20</strong>还有好多东西没有配置好，我就想着今天晚上把 ftp 整一下，然后就遇到了我特别尴尬的一幕，记录一下。</p>
<h2>安装 VsFtpd</h2>
<pre><code>sudo apt install vsftpd
</code></pre>
<p>这一步毫无争议，没啥可说。略</p>
<h2>配置文件</h2>
<pre><code>sudo cp /etc/vsftpd.conf /etc/vsftpd.conf.bk
sudo nano /etc/vsftpd.conf
</code></pre>
<pre><code>listen=NO
listen_ipv6=YES
anonymous_enable=NO
local_enable=YES
write_enable=YES
allow_writeable_chroot=YES
local_root=/home/frelon
dirmessage_enable=YES
use_localtime=YES
xferlog_enable=YES
connect_from_port_20=YES
ascii_upload_enable=YES
ascii_download_enable=YES
ls_recurse_enable=YES
secure_chroot_dir=/var/run/vsftpd/empty
pam_service_name=vsftpd
rsa_cert_file=/etc/ssl/certs/ssl-cert-snakeoil.pem
rsa_private_key_file=/etc/ssl/private/ssl-cert-snakeoil.key
ssl_enable=NO
utf8_filesystem=YES
</code></pre>
<p>一样是毫无争议，按照自己喜欢的配置来。</p>
<h2>重启 vsftpd</h2>
<pre><code>sudo systemctl restart vsftpd
</code></pre>
<p>我就特喵的在这一步出现了问题了。因为我平时使用<strong>samba</strong>比较多，在 Windows 下面映射一下就可以把局域网的 samba 当本地硬盘使，所以我就莫名其妙的输入了 <code>sudo systemctl restart smbd</code> ,我就本能的，条件反射的输入了 smbd，然后我就用我的用户名登陆 ftp，一下子给我整的不自信了，咋回事？这 ftp 咋还不能用呢，卧槽？ftp 出问题啦？我就改了半天的配置文件。甚至允许匿名登陆都特喵的不能用，当时就心态炸了。然后又检查了好几遍配置文件，还把防火墙给关了也于事无用</p>
<p>我当时甚至怀疑系统出问题啦，还把服务器给重启了一遍（重启的时候我偏偏手贱，把配置文件还原了）,还不能登陆，我就接着改配置文件 ，接着重启 smbd，然后我打算放弃了，觉得这 ftp 是不是出现了 bug。我本来打算去洗澡的，但是心里面又有一点不甘，用手机接着来，当我又一次打算重启 smbd 的时候我突然发现了问题，我特喵的用的是 ftp，我老在这重启 samba 干啥？？？这就像你抓鲁迅关我周树人什么事一样的感觉。我就突然觉得挺对不起我的 samba 的，逮着它就是一顿重启，阿哈哈哈。</p>]]></description>
      <author>JokerLee</author>
      <guid>https://jokeme.top/articles/2021/03/01/1614537942569.html</guid>
      <category>Linux</category>
      <pubDate>Mon, 01 Mar 2021 02:50:56 +0800</pubDate>
    </item>
    <item>
      <title>Phicomm N1 刷 OpenWrt 做旁路由</title>
      <link>https://jokeme.top/articles/2021/01/28/1611818287056.html</link>
      <description><![CDATA[<p>众所周知啊！N1 这个产品呢比较的全能，可以刷<strong>armbian</strong>、<strong>Openwrt</strong>、<strong>Android 电视盒子</strong>甚至<strong>windows</strong>也都不在话下。</p>
<p>在去年也是以低价入手了一个盒子，但是一直就没有机会捯饬，因为我个人还有一个 x86 架构的低功耗小主机用于个人服务器使用，并且也是在 Docker 里面部署了一个 Openwrt 做旁路由来方便自己上墙，其实我个人是比较喜欢这种旁路由的方式的。因为连上局域网以后必须要手动指定网关才可以上墙，直接 DHCP 分配的用户没有任何影响，这样就不会对没有需求的用户产生影响。</p>
<p>这里说一下我的设备，我的 N1 买回来就是刷好的电视盒子系统，所以就没有降级的步骤了，但是降级工具包都包含在了 N1 工具包里面了可以自行百度如何降级，其实都非常简单，输入一个 IP 地址回车就可以了。</p>
<p>我个人是准备把 Openwrt 刷入自带的 emmc 里面的，这样可以省很多事，而且运行速度比在 U 盘里面有天然优势。</p>
<h2>1.环境准备</h2>
<p>斐讯 N1</p>
<p>适配 N1 的 OpenWrt 镜像</p>
<p><a href="https://www.lanzous.com/ia9fgdi" target="_blank">N1工具包</a>（非必须）</p>
<p>U 盘一个（选好一点的 U 盘，可以上 USB3.0）</p>
<p>Etcher / rufus （写盘工具）</p>
<hr>
<p>在这里给大家推荐就几个 N1 的 Openwrt 镜像</p>
<p>GitHub：<a href="https://github.com/tuanqing/mknop" target="_blank">tuanqing</a>的固件</p>
<p>GitHub：<a href="https://github.com/IvanSolis1989/OpenWrt-DIY" target="_blank">IvanSolis1989</a>的固件</p>
<p>恩山大佬：<a href="https://www.right.com.cn/forum/forum.php?mod=viewthread&amp;tid=981406&amp;extra=page%3D1%26filter%3Dtypeid%26typeid%3D21" target="_blank">flippy</a>的固件</p>
<p>有一点需要注意，上面两个 GitHub 的固件都是没有无线网的，只有 flippy 的固件才有 WI-FI，自己看着选吧！</p>
<h2>2.刻录镜像</h2>
<p>从上面任意的一个镜像里选一个下载然后使用刻录工具来把镜像刻录进 U 盘里，这一步基本上不会出现什么问题。注意 U 盘里面的数据记得备份，写盘会把 U 盘里面的数据全部抹除。</p>
<h2>3.引导 OpenWrt 启动</h2>
<p>这一步需要先把 N1 启动连接好网线，插上刚刚刻录好的 U 盘，打开 N1 的 adb，然后可以去路由器管理界面查看 N1 盒子的 IP 地址，然后利用工具包里面的批处理脚本（N1 盒子进入刷机模式。bat）来引导 N1 从 Android 电视盒子重启到 Openwrt 中。基本上都是一键操作非常简单。</p>
<h2>4.把 OpenWrt 写入 emmc</h2>
<p>进过上面的步骤后，不意外的话你就已经在 OpenWrt 的命令行里面了，然后运行下面的命令</p>
<pre><code class="language-shell">cd ~
./install #然后按下Tab，具体脚本名我已经忘记了，但是运行这个准没错
</code></pre>
<p>然后就是脚本自动运行了，然后需要重启一下就可以了，这样 OpenWrt 就写入了我们的 emmc 了</p>
<pre><code class="language-sh">iptables -t nat -I POSTROUTING -o eth0 -j MASQUERADE
</code></pre>
<p>据说要在防火墙规则里面加上上面这句，但是我没有加使用起来也没有啥感觉，可能是我家 100m 的宽带限制了吧</p>
<p>顺带说一下 OpenWrt 换源</p>
<pre><code>sed -i 's/downloads.openwrt.org/mirrors.ustc.edu.cn\/openwrt/g' /etc/opkg/distfeeds.conf
</code></pre>]]></description>
      <author>JokerLee</author>
      <guid>https://jokeme.top/articles/2021/01/28/1611818287056.html</guid>
      <category>N1</category>
      <category>OpenWrt</category>
      <pubDate>Thu, 11 Feb 2021 15:18:25 +0800</pubDate>
    </item>
    <item>
      <title>Python 爬虫抓取?播放源(m3u8)</title>
      <link>https://jokeme.top/articles/2020/07/01/1593533676745.html</link>
      <description><![CDATA[<h1>Python 爬虫抓取播放源(m3u8)</h1>
<p>今天没有事的时候在捯饬 <a href="https://apps.apple.com/cn/app/id1455092592" target="_blank">dotPlayer</a> [IOS 平台 APP/￥ 收费？] 时发现这个东西是个宝贝呀！可以看 m3u8 格式的视频，这都不是重点，重点是使用起来非常舒服，虽然直接复制 m3u8 链接到 Safari 也可以播放，但是 <strong>dotPlayer</strong> 还可以有封面和标题！这两者体验可谓是天差地别(我没有收钱哈！我是真的觉得好用，希望 dotplayer 的作者看到了打一下广告费！)</p>
<p>具体可以看</p>
<p>简书作者： <a href="https://www.jianshu.com/u/cac586f07bd4" target="_blank">NickXXXXXXXX</a> 给出的图片简介</p>
<p>GitHub 上的 <a href="https://github.com/frozenthrone/dotplayer/blob/master/help_zh.md" target="_blank">help_zh.md</a> 给出的使用简介</p>
<p>这都不是我们需要关注の重点，重点是<strong>这款 app 是用来播放 m3u8 流の</strong></p>
<p>播放视频很简单，可是这 <strong>m3u8</strong> 文件从哪里来呢？??</p>
<ol>
<li>去 <code>Telegram</code> 加入组群 <a href="https://t.me/dotplayer" target="_blank">dotPlayer</a> ,群里经常会分享相关的订阅</li>
<li>自己动手丰衣足食</li>
</ol>
<p>这次用的爬虫和上一次一模一样，只是我优化了一下过程，就随便讲讲吧</p>
<pre><code> #coding=utf-8  
 import requests  
 from lxml import etree  
 import time  
 import datetime  
 import re  
 ​  
 def makeUrl(Num):  
  # Num为html的页数  
  allinks=[]  
  for link in range(1,Num+1):  
  link="https://www.xxxx.com/xzy{}".format(link)  
  allinks.append(link)  
  return allinks  
 ​  
 def getRealUrl(fakeUrl):  
  webPage = requests.get(  
  url=fakeUrl,  
  headers={"User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/79.0.3945.88 Safari/537.36"}  
  )  
  indexPage=webPage.text  
  indexHtml=etree.HTML(indexPage)  
  nextPageUrl=indexHtml.xpath("//div[@id='posts']/div[@class='post grid']/h3/a/@href")  
  picurls=indexHtml.xpath("//div[@class='img']/a/img/@data-src")  
  Set = []  
  Set.append(nextPageUrl)  
  Set.append(picurls)  
  return Set  
 ​  
 def ownSource(realUrl):  
  webPagess = requests.get(  
  url=realUrl,  
  headers={"User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/79.0.3945.88 Safari/537.36"}  
  )  
  indexPagess=webPagess.text  
  indexHtmlss=etree.HTML(indexPagess)  
  title=indexHtmlss.xpath("//header/h1/text()")  
  source=indexHtmlss.xpath("//div[@class='article-content']/div/@data-item")  
  finalUrl = []  
  finalUrl.append(title)  
  finalUrl.append(source)  
  return finalUrl  
 ​  
 Derailed = makeUrl(110)  
 for iPhoneSE in Derailed:  
     
  ceo = getRealUrl(iPhoneSE)  
  qq = ceo[0]  
  a=0  
  for SourceUrl in qq:  
  helloWorld = ownSource(SourceUrl)  
     
  MUlink=helloWorld[1][0]  
  realMULinks=MUlink.split('"')  
  realMULink=realMULinks[5].replace("\\","")  
  title=helloWorld[0][0].replace(" ","")  
  thePicUrl = ceo[1][a]  
 ​  
  p=re.compile(r"[-,$()#+&amp;*' ]")  
  lastTitle=re.sub(p,"",title)  
     
  str ='{\n'+'"name":"'+lastTitle+'",\n'+'"logo":"'+thePicUrl+'",\n'+'"url":"'+realMULink+'"\n'+'},\n'  
  with open ("weicha8.json","a+",encoding='utf-8') as f:  
  f.write(str)  
  a+=1  
  print(str)  
  print(a)  
  print(datetime.datetime.now())  
  time.sleep(1)
</code></pre>
<p>整体分为三个部分：</p>
<pre><code> def makeUrl(Num):  
 def getRealUrl(fakeUrl):  
 def ownSource(realUrl):
</code></pre>
<h3>1. def makeUrl(Num):</h3>
<p>该函数，接收一个 <code>int</code> 类型的参数， <strong>return</strong> 一个 <code>字符串列表</code></p>
<p>这部分就是分析页面链接？的规则，在本地生成 <strong>URL</strong> ,并返回给下一个函数处理， 爬虫能在本地干的就经量在本地完成，不过度占用服务器的资源，不给站长添堵！ 这也是为了自己好？?? 俗话说的好：爬虫学的好！ ... ...</p>
<h3>2. def getRealUrl(fakeUrl):</h3>
<p>该函数，接收一个 <code>字符串列表</code>  <strong>return</strong> 一个 <code>嵌套列表</code></p>
<p>这部分就是接收到上面生成の <strong>URL</strong> ,访问并分析网页结构。拿到视频的 <strong>封面</strong>  <strong>真实播放页</strong> の URL,并且返回给下一个函数来执行</p>
<h3>3. def ownSource(realUrl):</h3>
<p>该函数，接收一个 <code>嵌套列表</code>  <strong>return</strong> 一个 <code>嵌套列表</code></p>
<p>这部分也很简单，接收上面来的链接，一个一个的访问，拿到 <strong>标题</strong>  <strong>播放 URL</strong> ,然后返回一个 <code>嵌套列表</code></p>
<h3>4. 编写代码</h3>
<p>函数已经写好了，我们自己调用即可，需要注意循环嵌套的时候不能犯迷糊就可以，最后处理一下所得到の数据，写入本地 JSON 文件就可以了</p>
<p>虽然我爬虫很菜，但是我在一点点的学习！一起加油吧！!!</p>
<p>最新代码在 <a href="https://github.com/jokefrelon/python/blob/master/getM3u8.py" target="_blank">Github</a> 上，这篇文章，以后就不更新了</p>]]></description>
      <author>JokerLee</author>
      <guid>https://jokeme.top/articles/2020/07/01/1593533676745.html</guid>
      <category>python</category>
      <pubDate>Wed, 06 Jan 2021 21:17:20 +0800</pubDate>
    </item>
    <item>
      <title>数学思想</title>
      <link>https://jokeme.top/articles/2020/12/06/1607245769542.html</link>
      <description><![CDATA[<h1>数学思想</h1>
<blockquote>
<p>先声明一下！我是数学菜鸡！以下内容是我个人总结在学习数学中的一些重要的数学思想，写的不好！望海涵！!!</p>
</blockquote>
<h2>1. 无中生一</h2>
<p>这个是我最先总结出来的了， 所谓<strong>无中生一</strong>就是我们在做题目时常常会遇到一些写着写着就没办法写下去的题目，也不是写错了，但就是卡在了这里想了半天也没有想出来可以用什么公式来解决问题！ 这个时候我们就需要重新审视一下题目了， 我们真的应该这样写吗？看例题</p>
<p>$$<br>
求 f(x)=ln( \sqrt{1+x^2} +x) 的奇偶性<br>
$$</p>
<p>$$<br>
f(-x) = ln(\sqrt{1+(-x)^2}-x)<br>
$$</p>
<p>$$<br>
f(-x) = ln(\sqrt{1+x^2}-x)<br>
$$</p>
<p>$$<br>
f(-x)=ln[(\sqrt{1+x^2}-x)*\frac{\sqrt{x^2+1}+x}{\sqrt{x^2+1}+x}]<br>
$$</p>
<p>$$<br>
因为后面的\frac{\sqrt{x^2+1}+x}{\sqrt{x^2+1}+x}为一,对整个结果没有影响可得<br>
$$</p>
<p>$$<br>
f(-x)=ln\frac {(\sqrt{x^2+1}+x)*(\sqrt{1+x^2}-x)} {\sqrt{x^2+1}+x}<br>
$$</p>
<p>$$<br>
f(-x)=ln(\frac{1}{\sqrt{x^2+1}+x})=ln(\sqrt{x^2+1}+x)^{-1}=-ln(\sqrt{x^2+1}+x)<br>
$$</p>
<p><em>文章持续更新 ing</em>❤️️</p>]]></description>
      <author>JokerLee</author>
      <guid>https://jokeme.top/articles/2020/12/06/1607245769542.html</guid>
      <category>Math</category>
      <pubDate>Sun, 06 Dec 2020 17:17:17 +0800</pubDate>
    </item>
    <item>
      <title>Ubuntu &amp;&amp; Docker 使用建议</title>
      <link>https://jokeme.top/articles/2020/11/15/1605378926228.html</link>
      <description><![CDATA[<p><strong>Ubuntu</strong>一直是我喜欢用的<strong>Linux</strong>发行版本,界面简洁,上手简单,用户广泛</p>
<p>在<strong>Ubuntu</strong>中使用<strong>docker</strong>时,一直就有两个问题困扰着我</p>
<h2>1. Ubuntu pull 镜像速度太缓慢</h2>
<p>这个问题百度一搜一大把,但是作为个人学习 类型的博客,还是记录一下的好?</p>
<h3>1.1 Aliyun 镜像加速大法</h3>
<p>打开<strong>aliyun</strong>的<strong>docker</strong>加速<a href="https://cr.console.aliyun.com/" target="_blank">登陆页面</a>,虽然操作略微繁琐,但是我个人觉得这是速度最快的也是最稳定的</p>
<p>然后找到 <strong>容器镜像服务</strong> &gt; <strong>镜像加速器</strong> 根据提升来操作就可以啦</p>
<p>其中<strong>Docker</strong> <code>1.10.0</code>版本以上的直接就可以在 <code>/etc/docker/daemon.json</code>文件里加上你的专属加速链接</p>
<pre><code class="language-shell">sudo systemctl daemon-reload
sudo systemctl restart docker
</code></pre>
<p>少侠记得重启加载一下配置文件</p>
<h2>2. Docker 网桥IP和实际物理IP冲突</h2>
<p>虽然这个问题大家不一定会遇到,因为我们使用的大部分的路由器都是<code>192</code>开头的,<strong>docker</strong>的网桥<strong>IP</strong>则是选择<code>172</code>开头的,但是在学校,公司等场所就很容易出现冲突,而且一旦出现冲突你还不一定会想到问题出现在<strong>Docker</strong>网桥<strong>IP</strong>的问题上,所以当我遇到了这个问题我也是半天才反应过来要修改<strong>docker</strong>网桥<strong>IP</strong>,下面看操作 !</p>
<p>一样 ! 编辑上面的<code>/etc/docker/daemon.json</code>文件,</p>
<pre><code class="language-json">{
  "registry-mirrors": ["https://xxxxxxxxxxxx.mirror.aliyuncs.com"],
  "bip":"192.168.66.1/24" #换成你想要修改的ip网段
}
</code></pre>
<p>需要注意的是这个文件是<strong>json</strong>,保存的时候检查一下是否是json格式的</p>
<pre><code class="language-shell">sudo systemctl daemon-reload
sudo systemctl restart docker
</code></pre>
<p>少侠记得重启加载一下配置文件</p>]]></description>
      <author>JokerLee</author>
      <guid>https://jokeme.top/articles/2020/11/15/1605378926228.html</guid>
      <category>Linux</category>
      <category>Docker</category>
      <pubDate>Sun, 15 Nov 2020 02:35:26 +0800</pubDate>
    </item>
    <item>
      <title>记录一次OpenWrt安装zsh</title>
      <link>https://jokeme.top/articles/2020/10/07/1602055989143.html</link>
      <description><![CDATA[<p>众所周知啊，OpenWrt 是一个非常优秀的路由器 OS,但是因为是为路由器优化的，所以我们在使用的时候就会遇到各种各样的问题，就比如安装 <code>ohmyzsh</code></p>
<p>因为网络问题，咱可以直接去<a href="https://github.com/ohmyzsh/ohmyzsh/" target="_blank"><strong>GitHub</strong></a>看源码，顺便 Ctrl C / V</p>
<h2>1.安装依赖</h2>
<pre><code>opkg update
opkg install zsh git git-http ca-certificates curl
sh -c "$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)" 
#如果你Timeout了,不要慌!去Github下载源码,手动安装吧
./install.sh
</code></pre>
<h2>2.没了</h2>
<p>开始造作啦！?</p>
<p>如果你内存空间不够安装 <strong>zsh</strong>,那你可以看看<a href="https://itcao.com/2020/06031516.html" target="_blank">飞尘@IT草</a>的文章,最小化安装<strong>zsh</strong>后,仅占用不到的1m空间</p>]]></description>
      <author>JokerLee</author>
      <guid>https://jokeme.top/articles/2020/10/07/1602055989143.html</guid>
      <category>OpenWrt</category>
      <pubDate>Wed, 07 Oct 2020 15:42:16 +0800</pubDate>
    </item>
    <item>
      <title>Ubuntu 使用 netplan 配置 WIFI</title>
      <link>https://jokeme.top/articles/2020/05/06/1588694708444.html</link>
      <description><![CDATA[<h1>Ubuntu 使用 netplan 配置 WIFI</h1>
<p>在折腾 Ubuntu 的时候，我突然发现 Ubuntu 有好几套网络管理方案，但是在安装了图形化界面以后，只有<strong>Network Manager &amp; Systemd-networkd</strong> 之一生效，</p>
<p>那像我这种爱折腾的人，肯定是不满足被束缚啊，为什么不能用命令行来连接 ? WiFi 呢？</p>
<h2>1 .查看网卡名字</h2>
<pre><code class="language-shell">$ ~ iw dev
phy#0
        Interface wlx200db035fad3
                ifindex 3
                wdev 0x1
                addr 20:0d:b0:35:fa:d3
                ssid Tenda_277D40
                type managed
                txpower 12.00 dBm
</code></pre>
<h2>2 .打开无线网卡</h2>
<pre><code class="language-shell">$ ~ sudo ip lin set wlx200db035fad3 up
</code></pre>
<h2>3 . 搜索 WiFi 信号</h2>
<pre><code class="language-shell">$ ~ sudo iw dev wlx200db035fad3 scan
BSS **:**:**:**:**:**(on wlx200db035fad3) -- associated
        TSF: 1588670071330336 usec (18387d, 09:14:31)
        freq: 2437
        beacon interval: 100 TUs
        capability: ESS Privacy ShortSlotTime (0x0411)
        signal: -80.00 dBm
        last seen: 0 ms ago
        SSID: Tenda_277D40
        Supported rates: 1.0* 2.0* 5.5 11.0 18.0 24.0 36.0 54.0
        DS Parameter set: channel 6
        ERP: &lt;no flags&gt;
        ERP D4.0: &lt;no flags&gt;
        Extended supported rates: 6.0 9.0 12.0 48.0
        HT capabilities:
                Capabilities: 0x18fc
                        HT20
                        SM Power Save disabled
                        RX Greenfield
                        RX HT20 SGI
                        RX HT40 SGI
                        TX STBC
                        No RX STBC
                        Max AMSDU length: 7935 bytes
                        DSSS/CCK HT40
                Maximum RX AMPDU length 65535 bytes (exponent: 0x003)
                Minimum RX AMPDU time spacing: 8 usec (0x06)
                HT RX MCS rate indexes supported: 0-15, 32
                HT TX MCS rate indexes are undefined
        HT operation:
                 * primary channel: 6
                 * secondary channel offset: no secondary
                 * STA channel width: 20 MHz
                 * RIFS: 1
                 * HT protection: no
                 * non-GF present: 0
                 * OBSS non-GF present: 0
                 * dual beacon: 0
                 * dual CTS protection: 0
                 * STBC beacon: 0
                 * L-SIG TXOP Prot: 0
                 * PCO active: 0
                 * PCO phase: 0
        WPA:     * Version: 1
                 * Group cipher: CCMP
                 * Pairwise ciphers: CCMP
                 * Authentication suites: PSK
                 * Capabilities: 16-PTKSA-RC 1-GTKSA-RC (0x000c)
        WMM:     * Parameter version 1
                 * BE: CW 15-1023, AIFSN 3
                 * BK: CW 15-1023, AIFSN 7
                 * VI: CW 7-15, AIFSN 2, TXOP 3008 usec
                 * VO: CW 3-7, AIFSN 2, TXOP 1504 usec
</code></pre>
<p>我个人认为这一步纯属装 13! 我连接 ? WiFi,我肯定知道这个 WiFi の名字啊，那密码我肯定也知道啊，那还扫描个锤锤 ?啊？</p>
<h2>4 .配置 WiFi</h2>
<pre><code class="language-shell">$ ~ sudo nano  /etc/netplan/01-network-manager-all.yaml
</code></pre>
<p>这个文件名大家理论上都是不一样的，但是配置文件都在这个 <strong>/etc/netplan/</strong> 里面</p>
<pre><code class="language-yaml">network:
  version: 2
  renderer: networkd
  wifis:
    wlx200db035fad3:
      dhcp4: yes
      dhcp6: no
      access-points:
        Tenda_277D40:
          password: "password"
</code></pre>
<p>这个配置文件是 <strong>YAML</strong> 使用的时候需要注意缩进，这样一番操作以后就可以</p>
<pre><code class="language-shell">$ ~ sudo netplan generate //检查语法错误的
$ ~ sudo netplan apply
</code></pre>
<p>可以参考下面的文章,写的很规范 : <strong><a href="https://itsfoss.com/connect-wifi-terminal-ubuntu/" target="_blank">connect-wifi-terminal-ubuntu</a></strong></p>]]></description>
      <author>JokerLee</author>
      <guid>https://jokeme.top/articles/2020/05/06/1588694708444.html</guid>
      <category>Linux</category>
      <pubDate>Thu, 01 Oct 2020 17:50:36 +0800</pubDate>
    </item>
    <item>
      <title>笔记本坏了，这几天不能敲代码了</title>
      <link>https://jokeme.top/articles/2020/07/27/1595854655734.html</link>
      <description><![CDATA[<p>&lt;2020-07-27 14:25&gt;</p>
<p>笔记本坏了，这几天不能写代码了</p>
<p>太难受了，换了一个 Ubuntu 系统的老电脑，卡的怀疑人生，还没有好的中文输入法，明天就去修电脑去，希望小米的授权维修店不会坑我吧</p>
<p>······························································</p>
<p>&lt;2020-07-28 01:21&gt;</p>
<p>好了，?早点洗洗睡觉了</p>
<p>······························································</p>
<p>&lt;2020-07-28 17:56&gt;</p>
<p>现在刚刚修完电脑回来，话说小米的售后还是可以的，只是客服有点坑，给我说要发票，要三包卡</p>
<p>结果我去了小米授权维修点，检查了一下电脑状况，主板出问题了，查了一下保修日期还有一天，也没有给我拖时间，当场发顺丰了，还说大概三天就可以维修好，我不是吹捧小米哈，我是 <strong>果粉</strong> 就觉得小米这个牌子也确实是还可以的。</p>
<p>等过几天看看返厂修的怎么样，不行我再喷，哈哈哈</p>
<p>...............................................................</p>
<p>&lt;2020-09-25 20:52&gt;</p>
<p>忘记了写后续了，今天来补一下后续 ?</p>
<p>大概是 5 天后，我的笔记本被修好寄回，快递员大早上的给我打电话，那个时候我还在睡着觉，然后快递员打不通我的电话，就打我室友的。我室友叫我下去拿快递。妈的，我刚到楼下就看到这个狗屁快递员，直接把我的快递 ?从 2 米多高的铁门外丢进来了，然后当场潇洒离去，卧槽，我都看呆了，那个是我的电脑！没错吧？快递员敢这么随便的扔进来？?</p>
<p>然后我就拿快递回去拆开，检查了一下电脑 ?,好在小米那边泡沫纸裹的多，电脑没有啥事！那我就开个机吧！</p>
<p>然后就挺惨不忍睹的，换了主板以后，各种卡，开机以后至少还要卡个 30s 这样才能反应过来，一开始我就想凑合着用吧，反正不要钱的，还要啥自行车呢 ?‍♂️  . 但是我还是找了随电脑寄过来的专属售后吐槽，加了微信以后，我就说着各种我遇到的问题，一开始他还理我，后来直接鸟都不鸟我，心里一万个 <code>mmp</code></p>
<p>大概是五天后吧，我他们电脑又坏了，莫名其妙的自己坏的，我发誓真的就是一顿饭的功夫... ...就是这么突然！我又找我的专属客服哔哔！依旧是不理我，我也就自认倒霉了，打算发工资了重新换一下笔记本</p>
<p>然后又是两天后！我闲着无聊搁哪看我收到的垃圾短信，啊哈哈哈，无意间看到了小米给我发的售后服务评价，我就点进去链接，一顿妈卖批的骂，什么垃圾小米，什么垃圾售后，才几天又坏了，反正就是各种怼。</p>
<p>大概是一天以后，小米客服打电话给我了，和我大概了解了一下情况后，让我再次返厂，再给我维修一下(实际上是给我换了一块主板)</p>
<p>然后又是几天的折腾，电脑又给我修好啦，这次终于靠谱了，虽然也有一点卡顿，但是打完驱动，满血复活！New Bee ! 还给我报销了邮费</p>
<p>好了，今天算是完结了！</p>
<p>...............................................................</p>]]></description>
      <author>JokerLee</author>
      <guid>https://jokeme.top/articles/2020/07/27/1595854655734.html</guid>
      <category>日记</category>
      <pubDate>Fri, 25 Sep 2020 21:27:06 +0800</pubDate>
    </item>
    <item>
      <title>OpenStack 常用命令</title>
      <link>https://jokeme.top/articles/2020/09/25/1601015004916.html</link>
      <description><![CDATA[<h1>OpenStack 常用命令</h1>
<h2>1. MySQL</h2>
<pre><code class="language-mysql">show variables like "storage_engine";	//查询默认存储引擎InnoDB
show variables like "have%";	//查询支持的存储引擎
</code></pre>
<h2>2. Keyston</h2>
<pre><code class="language-shell">source /etc/keystone/admin-openrc.sh

openstack user create --domain demo --password password testuser 
//--domain为所属域 --password为密码 testuser是用户名

[root@controller ~]# openstack user list
//查看用户列表
+----------------------------------+----------+
| ID                               | Name     |
+----------------------------------+----------+
| 1877ca2b73b04380af77a5cd3d057734 | demo     |
| 21a0b28505a140b9b54ca5a20542746c | glance   |
| 65e4fa15c643474d99f0b7950b5328bb | neutron  |
| 710f538564124ecd9fdcfaef40792e84 | admin    |
| 7caa95a15cb54d789d69e511c8214cb8 | nova     |
| cce5f695864940a0a32eab0d2015528c | testuser |
+----------------------------------+----------+

[root@controller ~]# openstack endpoint list
//endpoint列表
+---------------+-----------+--------------+--------------+---------+-----------+------------------+
| ID            | Region    | Service Name | Service Type | Enabled | Interface | URL              |
+---------------+-----------+--------------+--------------+---------+-----------+------------------+
| 1f7824e81d9f4 | RegionOne | neutron      | network      | True    | internal  | http://controlle |
| f04b595b97a0a |           |              |              |         |           | r:9696           |
| e78f46        |           |              |              |         |           |                  |
| 399280c404a54 | RegionOne | glance       | image        | True    | public    | http://controlle |
| a1bb314531c2b |           |              |              |         |           | r:9292           |
| 880ca1        |           |              |              |         |           |                  |
|   . ... ... ... ... ... ... ... ... ... ... ... 略 ... ... ... ... ... ... ... ... ... ... ... . |
| fcb27923a6674 | RegionOne | neutron      | network      | True    | public    | http://controlle |
| 064a5f6d6ddd6 |           |              |              |         |           | r:9696           |
| 90fa54        |           |              |              |         |           |                  |
+---------------+-----------+--------------+--------------+---------+-----------+------------------+

[root@controller ~]# openstack role list
//查询OpenStack的角色列表
+----------------------------------+-------+
| ID                               | Name  |
+----------------------------------+-------+
| 2a818016714e4f828d96e05475a67208 | user  |
| a38871259df34ea39884b9019cea926b | admin |
+----------------------------------+-------+

[root@controller ~]# openstack service list
//查看keystone 服务
+----------------------------------+----------+----------+
| ID                               | Name     | Type     |
+----------------------------------+----------+----------+
| 40d9e5252f5f4967bc336542e6faab23 | glance   | image    |
| 442e7454d7244037b7fdd05a96440dec | keystone | identity |
| 6a95c79cc01147029bf79b5dfa3304f5 | neutron  | network  |
| 8a78c7d6a9af432f89ae9a4d185b29d5 | nova     | compute  |
| d821457f69fa4838ba42074652649548 | neutron  | network  |
+----------------------------------+----------+----------+

[root@controller ~]# openstack project list
//查看keystone租户
+----------------------------------+---------+
| ID                               | Name    |
+----------------------------------+---------+
| 00fa84b7a654447886421978253a2829 | demo    |
| 869f732ec387457ba9cfdcb424cc8ea2 | admin   |
| b421cbca4234472a94de962c634b5bb9 | service |
+----------------------------------+---------+

[root@controller ~]# openstack project show demo
//查看租户情况,show 后面加上上面查询到的用户 name
+-------------+----------------------------------+
| Field       | Value                            |
+-------------+----------------------------------+
| description | Demo Project                     |
| domain_id   | ad5088bf450145819f9338635ebfb7a6 |
| enabled     | True                             |
| id          | 00fa84b7a654447886421978253a2829 |
| is_domain   | False                            |
| name        | demo                             |
| parent_id   | ad5088bf450145819f9338635ebfb7a6 |
+-------------+----------------------------------+

[root@controller ~]# openstack domain create --description "PPX_PiXiaoMei_Only" NeiHanDuanZi_TV
//创建域
//--description "PPX_PiXiaoMei_Only" 不是必须的, 下同
+-------------+----------------------------------+
| Field       | Value                            |
+-------------+----------------------------------+
| description | PPX_PiXiaoMei_Only               |
| enabled     | True                             |
| id          | 57581f0aa311416c88c9fdb36688a46e |
| name        | NeiHanDuanZi_TV                  |
+-------------+----------------------------------+

[root@controller ~]# openstack project create --domain NeiHanDuanZi_TV --description "PDL" PXM
//创建项目（租户）
+-------------+----------------------------------+
| Field       | Value                            |
+-------------+----------------------------------+
| description | PDL                              |
| domain_id   | 57581f0aa311416c88c9fdb36688a46e |
| enabled     | True                             |
| id          | 4b6c52f02496465ebc70447b740a043c |
| is_domain   | False                            |
| name        | PXM                              |
| parent_id   | 57581f0aa311416c88c9fdb36688a46e |
+-------------+----------------------------------+

[root@controller ~]# openstack user create --domain NeiHanDuanZi_TV --password-prompt frelon
//创建用户
User Password:
Repeat User Password:
+-----------+----------------------------------+
| Field     | Value                            |
+-----------+----------------------------------+
| domain_id | 57581f0aa311416c88c9fdb36688a46e |
| enabled   | True                             |
| id        | 5ac456db906a43e8a8427ae7f3a5334a |
| name      | frelon                           |
+-----------+----------------------------------+


[root@controller ~]# openstack role create oiL
//创建角色
+-----------+----------------------------------+
| Field     | Value                            |
+-----------+----------------------------------+
| domain_id | None                             |
| id        | 893a47b1b1ce4f558858418da04c86e4 |
| name      | oiL                              |
+-----------+----------------------------------+

openstack role add  --project PXM --user frelon oiL
//为某项目中的某用户指定角色
</code></pre>
<blockquote>
<p><code>Tenant</code>也叫<code>project</code>,译为<code>租户</code> , 所有的资源(包括但不限于<code>CPU</code>,<code>Memory</code>,<code>Disk</code>等)都属于<code>Tenant</code> , <code>User</code> 本生并没有任何调度资源的权力,只有把 <code>User</code>加入<code>Tenant</code>后,用户才有资源的调度权限,<code>Tenant</code>就相当于一个 <strong>用户组</strong>,只不过在<code>OpenStack</code>这里被强化了,用户必须加入一个或多个<strong>用户组</strong>才可以调度资源</p>
</blockquote>
<blockquote>
<p><code>Role</code>主要是解决用户登陆后的权限问题,即用户登录以后可以干什么,有没有权利操作资源等等,简而言之就是<strong>鉴权</strong>,一个用户必须有一个或多个<code>Role</code>才有权力执行相应操作. <code>Role</code>是全局的,所有<code>Domain</code>里的<code>Group</code>,<code>User</code></p>
</blockquote>
<blockquote>
<p><code>Group</code>是用来配合<code>Role</code>来使用的,给<code>Group</code>加上相应的权限,再把用户加入<code>Group</code>该用户就可以获得<code>Group</code>所有的权限了,这样就方便了<code>Role</code>的分配</p>
</blockquote>
<blockquote>
<p><code>Domain</code> 常常表示一个客户/合作伙伴,并且 <code>project</code>,<code>Group</code>,<code>User</code>在同一个<code>Domain</code>里面不可以重复</p>
</blockquote>
<h2>3. glance</h2>
<pre><code>glance image-create --name "testone" --disk-format "qcow2" --container-format bare --progress &lt; /root/CentOS_6.5_x86_64_XD.qcow2
//上传镜像 并 用--name 命名为 "testone"

openstack image set testone --name examimage 
//修改已上传的镜像名称

openstack image list 
//列出已上传的镜像列表
</code></pre>
<h2>4. nova</h2>
<pre><code class="language-shell">nova usage-list 
//查询资源使用情况
</code></pre>
<h2>5. neutron</h2>
<pre><code> neutron router-list
 //列出当前存在的网络/路由器
 
 neutron router-show + id/name
 
 [root@controller ~]#  neutron router-list
+--------------------------------------+------+-----------------------+-------------+-------+
| id                                   | name | external_gateway_info | distributed | ha    |
+--------------------------------------+------+-----------------------+-------------+-------+
| bb46e65a-ad51-4c13-b1c6-51c845dcfb52 | cvn  | null                  | False       | False |
+--------------------------------------+------+-----------------------+-------------+-------+
[root@controller ~]#  neutron router-show bb46e65a-ad51-4c13-b1c6-51c845dcfb52
+-------------------------+--------------------------------------+
| Field                   | Value                                |
+-------------------------+--------------------------------------+
| admin_state_up          | True                                 |
| availability_zone_hints |                                      |
| availability_zones      | nova                                 |
| description             |                                      |
| distributed             | False                                |
| external_gateway_info   |                                      |
| ha                      | False                                |
| id                      | bb46e65a-ad51-4c13-b1c6-51c845dcfb52 |
| name                    | cvn                                  |
| routes                  |                                      |
| status                  | ACTIVE                               |
| tenant_id               | 869f732ec387457ba9cfdcb424cc8ea2     |
+-------------------------+--------------------------------------+


</code></pre>
<h2>6. trove</h2>
<h2>7. OpenStack命令大全</h2>
<pre><code>access token create                        project create
acl delete                                 project delete
acl get                                    project list
acl submit                                 project set
acl user add                               project show
acl user remove                            ptr record list
aggregate add host                         ptr record set
aggregate create                           ptr record show
aggregate delete                           ptr record unset
aggregate list                             quota set
aggregate remove host                      quota show
aggregate set                              recordset create
aggregate show                             recordset delete
availability zone list                     recordset list
backup create                              recordset set
backup delete                              recordset show
backup list                                region create
backup restore                             region delete
backup show                                region list
ca get                                     region set
ca list                                    region show
catalog list                               request token authorize
catalog show                               request token create
command list                               role add
complete                                   role assignment list
compute agent create                       role create
compute agent delete                       role delete
compute agent list                         role list
compute agent set                          role remove
compute service delete                     role set
compute service list                       role show
compute service set                        router create
configuration show                         router delete
console log show                           router list
console url show                           router set
consumer create                            router show
consumer delete                            secret container create
consumer list                              secret container delete
consumer set                               secret container get
consumer show                              secret container list
container create                           secret delete
container delete                           secret get
container list                             secret list
container save                             secret order create
container set                              secret order delete
container show                             secret order get
container unset                            secret order list
credential create                          secret store
credential delete                          secret update
credential list                            security group create
credential set                             security group delete
credential show                            security group list
dataprocessing cluster create              security group rule create
dataprocessing cluster delete              security group rule delete
dataprocessing cluster list                security group rule list
dataprocessing cluster scale               security group rule show
dataprocessing cluster show                security group set
dataprocessing cluster template create     security group show
dataprocessing cluster template delete     server add security group
dataprocessing cluster template list       server add volume
dataprocessing cluster template show       server create
dataprocessing cluster template update     server delete
dataprocessing cluster update              server dump create
dataprocessing cluster verification        server image create
dataprocessing data source create          server list
dataprocessing data source delete          server lock
dataprocessing data source list            server migrate
dataprocessing data source show            server pause
dataprocessing data source update          server reboot
dataprocessing image list                  server rebuild
dataprocessing image register              server remove security group
dataprocessing image show                  server remove volume
dataprocessing image tags add              server rescue
dataprocessing image tags remove           server resize
dataprocessing image tags set              server resume
dataprocessing image unregister            server set
dataprocessing job binary create           server shelve
dataprocessing job binary delete           server show
dataprocessing job binary download         server ssh
dataprocessing job binary list             server start
dataprocessing job binary show             server stop
dataprocessing job binary update           server suspend
dataprocessing job delete                  server unlock
dataprocessing job execute                 server unpause
dataprocessing job list                    server unrescue
dataprocessing job show                    server unset
dataprocessing job template create         server unshelve
dataprocessing job template delete         service create
dataprocessing job template list           service delete
dataprocessing job template show           service list
dataprocessing job template update         service provider create
dataprocessing job type configs get        service provider delete
dataprocessing job type list               service provider list
dataprocessing job update                  service provider set
dataprocessing node group template create  service provider show
dataprocessing node group template delete  service set
dataprocessing node group template list    service show
dataprocessing node group template show    snapshot create
dataprocessing node group template update  snapshot delete
dataprocessing plugin configs get          snapshot list
dataprocessing plugin list                 snapshot set
dataprocessing plugin show                 snapshot show
domain create                              snapshot unset
domain delete                              software config create
domain list                                software config delete
domain set                                 software config list
domain show                                software config show
ec2 credentials create                     software deployment create
ec2 credentials delete                     software deployment delete
ec2 credentials list                       software deployment list
ec2 credentials show                       software deployment metadata show
endpoint create                            software deployment output show
endpoint delete                            software deployment show
endpoint list                              stack abandon
endpoint set                               stack adopt
endpoint show                              stack cancel
extension list                             stack check
federation domain list                     stack create
federation project list                    stack delete
federation protocol create                 stack event list
federation protocol delete                 stack event show
federation protocol list                   stack hook clear
federation protocol set                    stack hook poll
federation protocol show                   stack list
flavor create                              stack output list
flavor delete                              stack output show
flavor list                                stack resource list
flavor set                                 stack resource mark unhealthy
flavor show                                stack resource metadata
flavor unset                               stack resource show
group add user                             stack resource signal
group contains user                        stack resume
group create                               stack show
group delete                               stack snapshot create
group list                                 stack snapshot delete
group remove user                          stack snapshot list
group set                                  stack snapshot restore
group show                                 stack snapshot show
help                                       stack suspend
host list                                  stack template show
host show                                  stack update
hypervisor list                            subnet delete
hypervisor show                            subnet list
hypervisor stats show                      subnet pool delete
identity provider create                   subnet pool list
identity provider delete                   subnet pool show
identity provider list                     subnet show
identity provider set                      tld create
identity provider show                     tld delete
image add project                          tld list
image create                               tld set
image delete                               tld show
image list                                 token issue
image remove project                       token revoke
image save                                 trust create
image set                                  trust delete
image show                                 trust list
ip fixed add                               trust show
ip fixed remove                            usage list
ip floating add                            usage show
ip floating create                         user create
ip floating delete                         user delete
ip floating list                           user list
ip floating pool list                      user password set
ip floating remove                         user set
ip floating show                           user show
keypair create                             volume create
keypair delete                             volume delete
keypair list                               volume list
keypair show                               volume qos associate
limits show                                volume qos create
mapping create                             volume qos delete
mapping delete                             volume qos disassociate
mapping list                               volume qos list
mapping set                                volume qos set
mapping show                               volume qos show
module list                                volume qos unset
network create                             volume set
network delete                             volume show
network list                               volume type create
network set                                volume type delete
network show                               volume type list
object create                              volume type set
object delete                              volume type show
object list                                volume type unset
object save                                volume unset
object set                                 zone abandon
object show                                zone axfr
object store account set                   zone blacklist create
object store account show                  zone blacklist delete
object store account unset                 zone blacklist list
object unset                               zone blacklist set
orchestration build info                   zone blacklist show
orchestration resource type list           zone create
orchestration resource type show           zone delete
orchestration service list                 zone list
orchestration template function list       zone set
orchestration template version list        zone show
policy create                              zone transfer accept request
policy delete                              zone transfer accept show
policy list                                zone transfer request create
policy set                                 zone transfer request delete
policy show                                zone transfer request list
port delete                                zone transfer request set
port show                                  zone transfer request show
</code></pre>]]></description>
      <author>JokerLee</author>
      <guid>https://jokeme.top/articles/2020/09/25/1601015004916.html</guid>
      <category>OpenStack</category>
      <pubDate>Fri, 25 Sep 2020 14:23:25 +0800</pubDate>
    </item>
    <item>
      <title>CentOS 7 磁盘扩容</title>
      <link>https://jokeme.top/articles/2020/09/25/1601014454374.html</link>
      <description><![CDATA[<h1>CentOS 7 磁盘扩容</h1>
<p>假设已经添加了磁盘,到了需要在系统里操作的步骤</p>
<h2>对新增加的硬盘进行分区</h2>
<pre><code>fidsk -l
fdisk /dev/sda (根据实际情况选择)
n	(新增加一个分区)
p	(区类型选择为主分区)
回车	(分区号)
回车　（起始扇区）
回车　（结束扇区）
t
上面的分区号
8e 将分区“Linux”的类型更改为“Linux LVM”
w 保存
reboot
</code></pre>
<h2>对新增加的硬盘格式化</h2>
<pre><code>mkfs.ext4 /dev/sda3
</code></pre>
<h2>添加新LVM到已有的LVM组，实现扩容</h2>
<pre><code>lvm　　　　　　　　　　　　 进入lvm管理
lvm&gt; pvcreate /dev/sda3 这是初始化刚才的分区，必须的
lvm&gt;vgextend centos /dev/sda3 将初始化过的分区加入到虚拟卷组vg_dc01
lvm&gt;lvextend -L +100G /dev/mapper/centos-root　　扩展已有卷的容量（注意容量大小）
lvm&gt;pvdisplay　　　　　　　　　　　　　　 查看卷容量，这时你会看到一个很大的卷了
lvm&gt;quit　
</code></pre>
<p>以上只是卷扩容了，下面是文件系统的真正扩容，输入以下命令：</p>
<pre><code>resize2fs /dev/mapper/centos-root
</code></pre>
<p>resize2fs: Bad magic number in super-block 当尝试打开 /dev/mapper/centos-root 时</p>
<p>报错：当尝试打开 /dev/mapper/centos-root 时 找不到有效的文件系统超级块</p>
<p>因为我的centos7的某些分区用的是xfs的文件系统（使用df -T查看即可知道）</p>
<p>将<code>resize2fs</code>替换为<code>xfs_growfs</code>，重新执行一遍即可，如下：</p>
<pre><code class="language-shell"> xfs_growfs /dev/mapper/centos-root
</code></pre>
<h3>步骤记录</h3>
<pre><code>[root@last ~]# fdisk /dev/sda
Welcome to fdisk (util-linux 2.23.2).

Changes will remain in memory only, until you decide to write them.
Be careful before using the write command.


Command (m for help): p

Disk /dev/sda: 107.4 GB, 107374182400 bytes, 209715200 sectors
Units = sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disk label type: dos
Disk identifier: 0x000ae200

   Device Boot      Start         End      Blocks   Id  System
/dev/sda1   *        2048     2099199     1048576   83  Linux
/dev/sda2         2099200    41943039    19921920   8e  Linux LVM

Command (m for help): n
Partition type:
   p   primary (2 primary, 0 extended, 2 free)
   e   extended
Select (default p):
Using default response p
Partition number (3,4, default 3):
First sector (41943040-209715199, default 41943040):
Using default value 41943040
Last sector, +sectors or +size{K,M,G} (41943040-209715199, default 209715199):
Using default value 209715199
Partition 3 of type Linux and of size 80 GiB is set

Command (m for help): p

Disk /dev/sda: 107.4 GB, 107374182400 bytes, 209715200 sectors
Units = sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disk label type: dos
Disk identifier: 0x000ae200

   Device Boot      Start         End      Blocks   Id  System
/dev/sda1   *        2048     2099199     1048576   83  Linux
/dev/sda2         2099200    41943039    19921920   8e  Linux LVM
/dev/sda3        41943040   209715199    83886080   83  Linux

Command (m for help): t
Partition number (1-3, default 3): 8e
Partition number (1-3, default 3):
Hex code (type L to list all codes): 8e
Changed type of partition 'Linux' to 'Linux LVM'

Command (m for help): p

Disk /dev/sda: 107.4 GB, 107374182400 bytes, 209715200 sectors
Units = sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disk label type: dos
Disk identifier: 0x000ae200

   Device Boot      Start         End      Blocks   Id  System
/dev/sda1   *        2048     2099199     1048576   83  Linux
/dev/sda2         2099200    41943039    19921920   8e  Linux LVM
/dev/sda3        41943040   209715199    83886080   8e  Linux LVM

Command (m for help): w
The partition table has been altered!

Calling ioctl() to re-read partition table.

WARNING: Re-reading the partition table failed with error 16: Device or resource busy.
The kernel still uses the old table. The new table will be used at
the next reboot or after you run partprobe(8) or kpartx(8)
Syncing disks.
[root@last ~]#
[root@last ~]# reboot
Connection to 192.168.50.130 closed by remote host.
Connection to 192.168.50.130 closed.
➜  frelon
➜  frelon
➜  frelon ssh root@192.168.50.130
Last login: Sat Sep 19 04:08:59 2020 from 192.168.50.1
[root@last ~]# mkfs.ext4 /dev/sda3
mke2fs 1.42.9 (28-Dec-2013)
Filesystem label=
OS type: Linux
Block size=4096 (log=2)
Fragment size=4096 (log=2)
Stride=0 blocks, Stripe width=0 blocks
5242880 inodes, 20971520 blocks
1048576 blocks (5.00%) reserved for the super user
First data block=0
Maximum filesystem blocks=2168455168
640 block groups
32768 blocks per group, 32768 fragments per group
8192 inodes per group
Superblock backups stored on blocks:
        32768, 98304, 163840, 229376, 294912, 819200, 884736, 1605632, 2654208,
        4096000, 7962624, 11239424, 20480000

Allocating group tables: done
Writing inode tables: done
Creating journal (32768 blocks): done
Writing superblocks and filesystem accounting information: done

[root@last ~]#
[root@last ~]#
[root@last ~]# lvm
lvm&gt; pvcreate /dev/sda3
WARNING: ext4 signature detected on /dev/sda3 at offset 1080. Wipe it? [y/n]: y
  Wiping ext4 signature on /dev/sda3.
  Physical volume "/dev/sda3" successfully created.
lvm&gt;
lvm&gt; vgextend centos /dev/sda3
  Volume group "centos" successfully extended
lvm&gt; lvextend -L +79G /dev/mapper/centos-root
  Size of logical volume centos/root changed from &lt;17.00 GiB (4351 extents) to &lt;96.00 GiB (24575 extents).
  Logical volume centos/root successfully resized.
lvm&gt; quit
  Exiting.
[root@last ~]# xfs_
xfs_admin      xfs_db         xfs_fsr        xfs_io         xfs_metadump   xfs_quota
xfs_bmap       xfs_estimate   xfs_growfs     xfs_logprint   xfs_mkfile     xfs_repair
xfs_copy       xfs_freeze     xfs_info       xfs_mdrestore  xfs_ncheck     xfs_rtcp
[root@last ~]# xfs_
xfs_admin      xfs_db         xfs_fsr        xfs_io         xfs_metadump   xfs_quota
xfs_bmap       xfs_estimate   xfs_growfs     xfs_logprint   xfs_mkfile     xfs_repair
xfs_copy       xfs_freeze     xfs_info       xfs_mdrestore  xfs_ncheck     xfs_rtcp
[root@last ~]# xfs_growfs /dev/mapper/c
centos-root  centos-swap  control
[root@last ~]# xfs_growfs /dev/mapper/centos-root
meta-data=/dev/mapper/centos-root isize=512    agcount=4, agsize=1113856 blks
         =                       sectsz=512   attr=2, projid32bit=1
         =                       crc=1        finobt=0 spinodes=0
data     =                       bsize=4096   blocks=4455424, imaxpct=25
         =                       sunit=0      swidth=0 blks
naming   =version 2              bsize=4096   ascii-ci=0 ftype=1
log      =internal               bsize=4096   blocks=2560, version=2
         =                       sectsz=512   sunit=0 blks, lazy-count=1
realtime =none                   extsz=4096   blocks=0, rtextents=0
data blocks changed from 4455424 to 25164800
[root@last ~]#
[root@last ~]#
[root@last ~]# df -h
Filesystem               Size  Used Avail Use% Mounted on
devtmpfs                 898M     0  898M   0% /dev
tmpfs                    910M     0  910M   0% /dev/shm
tmpfs                    910M  9.5M  901M   2% /run
tmpfs                    910M     0  910M   0% /sys/fs/cgroup
/dev/mapper/centos-root   96G  1.4G   95G   2% /
/dev/sda1               1014M  150M  865M  15% /boot
tmpfs                    182M     0  182M   0% /run/user/0
</code></pre>
<hr>
<p>　由于在安装centos系统的时候，如果在安装时没有分配磁盘空间，选择的是默认分配的，在安装完成后，可以发现大容量磁盘往往分配在了home下面。</p>
<p>如果要把home下面的磁盘空间分配到root磁盘下面。可以进行如下操作。</p>
<h2>1.查看CentOS的系统版本</h2>
<pre><code>[root@controller ~]# cat /etc/redhat-release
CentOS Linux release 7.2.1511 (Core)
</code></pre>
<h2>2.查看分区</h2>
<p>df -h (centos-home和centos-root每人的名字可能不一样)</p>
<pre><code>[root@controller ~]# df -h
Filesystem      Size  Used Avail Use% Mounted on
/dev/sda3        50G  8.5G   42G  17% /
devtmpfs        1.9G     0  1.9G   0% /dev
tmpfs           1.9G     0  1.9G   0% /dev/shm
tmpfs           1.9G  8.7M  1.9G   1% /run
tmpfs           1.9G     0  1.9G   0% /sys/fs/cgroup
/dev/sda6        20G   33M   20G   1% /home
/dev/sda5        26G  804M   26G   4% /var
/dev/sda2       2.0G  125M  1.9G   7% /boot
/dev/loop0      4.1G  4.1G     0 100% /mnt/centos
/dev/loop1      2.7G  2.7G     0 100% /mnt/xiandi
tmpfs           378M     0  378M   0% /run/user/0
</code></pre>
<h2>3.备份home分区文件</h2>
<pre><code>[root@controller ~]# tar cvzf /mnt/home.tar /home/
tar: Removing leading `/' from member names
/home/
/home/frelon/
</code></pre>
<h2>4.卸载/home，如果无法卸载，先终止使用/home文件系统的进程</h2>
<pre><code>[root@controller ~]# umount /home （卸载）
</code></pre>
<p>如果卸载时，发现/home在使用中，所以先终止。</p>
<pre><code>[root@controller ~]# fuser -km /home/（终止）
</code></pre>
<p>再次卸载，没有报错，表示成功。</p>
<pre><code>[root@controller ~]# umount /home （卸载）
</code></pre>
<h2>5.删除/home所在的lv</h2>
<pre><code>lvremove /dev/mapper/centos-home
</code></pre>
<h2>6.扩展/root所在的lv</h2>
<pre><code>lvextend -L +100G /dev/mapper/centos-root

</code></pre>
<h2>7.扩展/root文件系统</h2>
<pre><code>xfs_growfs /dev/mapper/centos-root
</code></pre>
<h2>8.重新创建home lv （创建时计算好剩余的磁盘容量，建议比剩余小1G左右）</h2>
<pre><code>lvcreate -L 41G -n /dev/mapper/centos-home 
</code></pre>
<h2>9.创建文件系统</h2>
<pre><code>mkfs.xfs /dev/mapper/centos-home
</code></pre>
<h2>10.挂载home</h2>
<pre><code>mount /dev/mapper/centos-home
</code></pre>
<h2>11.home文件恢复</h2>
<pre><code>tar xvf /tmp/home.tar -C /home/
</code></pre>
<h2>12.再次使用df -h查看系统磁盘大小</h2>
<p>可以看到home下面100G的磁盘容量已经转移到root下面了，至此，转移任务结束。此为在CentOS7.2系统下测试使用的，在CentOS6版本下还没测试过。</p>
<p>声明 : 文章来自互联网(实在是找不到原作者链接出处了),<strong>侵联删</strong></p>]]></description>
      <author>JokerLee</author>
      <guid>https://jokeme.top/articles/2020/09/25/1601014454374.html</guid>
      <category>Linux</category>
      <pubDate>Fri, 25 Sep 2020 14:14:35 +0800</pubDate>
    </item>
    <item>
      <title>clang 学习笔记</title>
      <link>https://jokeme.top/articles/2020/08/31/1598851343874.html</link>
      <description><![CDATA[<h1>clang 学习笔记</h1>
<h2>1.什么是 c</h2>
<p>C 语言是一种通用的高级语言，最初是由丹尼斯·里奇在贝尔实验室为开发 UNIX 操作系统而设计的。C 语言最开始是于 1972 年在 DEC PDP-11 计算机上被首次实现。</p>
<p>在 1978 年，布莱恩·柯林汉（Brian Kernighan）和丹尼斯·里奇（Dennis Ritchie）制作了 C 的第一个公开可用的描述，现在被称为 K&amp;R 标准。</p>
<p>UNIX 操作系统，C 编译器，和几乎所有的 UNIX 应用程序都是用 C 语言编写的。由于各种原因，C 语言现在已经成为一种广泛使用的专业语言。</p>
<ul>
<li>易于学习。</li>
<li>结构化语言。</li>
<li>它产生高效率的程序。</li>
<li>它可以处理底层的活动。</li>
<li>它可以在多种计算机平台上编译。</li>
</ul>
<h3>1.1 关于 C</h3>
<ul>
<li>C 语言是为了编写 UNIX 操作系统而被发明的。</li>
<li>C 语言是以 B 语言为基础的，B 语言大概是在 1970 年被引进的。</li>
<li>C 语言标准是于 1988 年由美国国家标准协会（ANSI，全称 American National Standard Institute）制定的。</li>
<li>截至 1973 年，UNIX 操作系统完全使用 C 语言编写。</li>
<li>目前，C 语言是最广泛使用的系统程序设计语言。</li>
<li>大多数先进的软件都是使用 C 语言实现的。</li>
<li>当今最流行的 Linux 操作系统和 RDBMS（Relational Database Management System：关系数据库管理系统） MySQL 都是使用 C 语言编写的。</li>
</ul>
<h3>1.2 为什么要使用 C？</h3>
<p>C 语言最初是用于系统开发工作，特别是组成操作系统的程序。由于 C 语言所产生的代码运行速度与汇编语言编写的代码运行速度几乎一样，所以采用 C 语言作为系统开发语言。下面列举几个使用 C 的实例：</p>
<ul>
<li>操作系统</li>
<li>语言编译器</li>
<li>汇编器</li>
<li>文本编辑器</li>
<li>打印机</li>
<li>网络驱动器</li>
<li>现代程序</li>
<li>数据库</li>
<li>语言解释器</li>
<li>实体工具</li>
</ul>
<h3>1.3 C 程序</h3>
<p>一个 C 语言程序，可以是 3 行，也可以是数百万行，它可以写在一个或多个扩展名为 <strong>".c"</strong> 的文本文件中，例如，<em>hello.c</em>。您可以使用  <strong>"sublime text3"</strong>、<strong>"vim"</strong>、<strong>"vscode"</strong> 或任何其他文本编辑器来编写您的 C 语言程序。</p>
<p>下面看一个<strong>c</strong>语言入门实例</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
 
int main()
{
    /* 我的第一个 C 程序 */
    printf("Hello, World! \n");
 
    return 0;
}
</code></pre>
<ul>
<li>所有的 C 语言程序都需要包含 <strong>main()</strong> 函数。 代码从 <strong>main()</strong> 函数开始执行。</li>
<li><strong>/* ... */</strong> 用于注释说明。</li>
<li><strong>printf()</strong> 用于格式化输出到屏幕。<strong>printf()</strong> 函数在 <strong>"stdio.h"</strong> 头文件中声明。</li>
<li><strong>stdio.h</strong> 是一个头文件 (标准输入输出头文件) , <strong>#include</strong> 是一个预处理命令，用来引入头文件。 当编译器遇到 <strong>printf()</strong> 函数时，如果没有找到 <strong>stdio.h</strong> 头文件，会发生编译错误。</li>
<li><strong>return 0;</strong> 语句用于表示退出程序。</li>
</ul>
<h2>2. 配置 c 环境</h2>
<h3>2.1 Linux</h3>
<p>一般 Linux 自带 <strong>gcc</strong> , 终端输入 <code>gcc -v</code> 即可查看当前版本</p>
<p>(本教程以<strong>Linux</strong>环境为基础)</p>
<h3>2.2 macOS</h3>
<p>安装<strong>xcode</strong> , 一劳永逸，并且可以减少你不少的麻烦，也可以自己安装，推荐使用<strong>brew</strong>包管理器来安装</p>
<h3>2.3 Windows</h3>
<p>为了在 Windows 上安装 GCC，您需要安装 MinGW。为了安装 MinGW，请访问 MinGW 的主页 <a href="http://www.mingw.org/" target="_blank">www.mingw.org</a>，进入 MinGW 下载页面，下载最新版本的 MinGW 安装程序，命名格式为 MinGW- <version> .exe。</version></p>
<p>当安装 MinGW 时，您至少要安装 gcc-core、gcc-g++、binutils 和 MinGW runtime，但是一般情况下都会安装更多其他的项。</p>
<p>添加您安装的 MinGW 的 bin 子目录到您的 <strong>PATH</strong> 环境变量中，这样您就可以在命令行中通过简单的名称来指定这些工具。</p>
<p>当完成安装时，您可以从 Windows 命令行上运行 gcc、g++、ar、ranlib、dlltool 和其他一些 GNU 工具</p>
<h2>3. clang 程序结构</h2>
<pre><code class="language-c">#include &lt;stdio.h&gt;
 
int main()
{
   /* 我的第一个 C 程序 */
   printf("Hello, World! \n");
   
   return 0;
}
</code></pre>
<p>接下来我们讲解一下上面这段程序：</p>
<ol>
<li>程序的第一行 *#include * 是预处理器指令，告诉 C 编译器在实际编译之前要包含 stdio.h 文件。</li>
<li>下一行 <em>int main()</em> 是主函数，程序从这里开始执行。</li>
<li>下一行 /<em>...</em>/ 将会被编译器忽略，这里放置程序的注释内容。它们被称为程序的注释。</li>
<li>下一行 <em>printf(...)</em> 是 C 中另一个可用的函数，会在屏幕上显示消息 "Hello, World!"。</li>
<li>下一行 <strong>return 0;</strong> 终止 main() 函数，并返回值 0。</li>
</ol>
<p>想要执行<strong>c</strong>程序，只需要简单的编译即可运行</p>
<pre><code class="language-shell">$ gcc hello.c -c hello
$ ./hello
Hello, World!
</code></pre>
<h2>4. clang 关键字</h2>
<p>下表列出了 C 中的保留字。这些保留字不能作为常量名、变量名或其他标识符名称。</p>
<table>
<thead>
<tr><th align="left">关键字</th><th align="left">说明</th></tr>
</thead>
<tbody>
<tr><td align="left">auto</td><td align="left">声明自动变量</td></tr>
<tr><td align="left">break</td><td align="left">跳出当前循环</td></tr>
<tr><td align="left">case</td><td align="left">开关语句分支</td></tr>
<tr><td align="left">char</td><td align="left">声明字符型变量或函数返回值类型</td></tr>
<tr><td align="left">const</td><td align="left">定义常量，如果一个变量被 const 修饰，那么它的值就不能再被改变</td></tr>
<tr><td align="left">continue</td><td align="left">结束当前循环，开始下一轮循环</td></tr>
<tr><td align="left">default</td><td align="left">开关语句中的"其它"分支</td></tr>
<tr><td align="left">do</td><td align="left">循环语句的循环体</td></tr>
<tr><td align="left">double</td><td align="left">声明双精度浮点型变量或函数返回值类型</td></tr>
<tr><td align="left">else</td><td align="left">条件语句否定分支（与 if 连用）</td></tr>
<tr><td align="left">enum</td><td align="left">声明枚举类型</td></tr>
<tr><td align="left">extern</td><td align="left">声明变量或函数是在其它文件或本文件的其他位置定义</td></tr>
<tr><td align="left">float</td><td align="left">声明浮点型变量或函数返回值类型</td></tr>
<tr><td align="left">for</td><td align="left">一种循环语句</td></tr>
<tr><td align="left">goto</td><td align="left">无条件跳转语句</td></tr>
<tr><td align="left">if</td><td align="left">条件语句</td></tr>
<tr><td align="left">int</td><td align="left">声明整型变量或函数</td></tr>
<tr><td align="left">long</td><td align="left">声明长整型变量或函数返回值类型</td></tr>
<tr><td align="left">register</td><td align="left">声明寄存器变量</td></tr>
<tr><td align="left">return</td><td align="left">子程序返回语句（可以带参数，也可不带参数）</td></tr>
<tr><td align="left">short</td><td align="left">声明短整型变量或函数</td></tr>
<tr><td align="left">signed</td><td align="left">声明有符号类型变量或函数</td></tr>
<tr><td align="left">sizeof</td><td align="left">计算数据类型或变量长度（即所占字节数）</td></tr>
<tr><td align="left">static</td><td align="left">声明静态变量</td></tr>
<tr><td align="left">struct</td><td align="left">声明结构体类型</td></tr>
<tr><td align="left">switch</td><td align="left">用于开关语句</td></tr>
<tr><td align="left">typedef</td><td align="left">用以给数据类型取别名</td></tr>
<tr><td align="left">unsigned</td><td align="left">声明无符号类型变量或函数</td></tr>
<tr><td align="left">union</td><td align="left">声明共用体类型</td></tr>
<tr><td align="left">void</td><td align="left">声明函数无返回值或无参数，声明无类型指针</td></tr>
<tr><td align="left">volatile</td><td align="left">说明变量在程序执行中可被隐含地改变</td></tr>
<tr><td align="left">while</td><td align="left">循环语句的循环条件</td></tr>
</tbody>
</table>
<h3>4.1 C99 新增关键字</h3>
<table>
<thead>
<tr><th><code>_Bool</code></th><th><code>_Complex</code></th><th><code>_Imaginary</code></th><th><code>inline</code></th><th><code>restrict</code></th></tr>
</thead>
<tbody>
<tr><td colspan="5"></td></tr>
</tbody>
</table>
<h3>4.2 C11 新增关键字</h3>
<table>
<thead>
<tr><th><code>_Alignas</code></th><th><code>_Alignof</code></th><th><code>_Atomic</code></th><th><code>_Generic</code></th><th><code>_Noreturn</code></th></tr>
</thead>
<tbody>
<tr><td><code>_Static_assert</code></td><td colspan="4"><code>_Thread_local</code></td></tr>
</tbody>
</table>
<p>看看就可以了，一般我们也不会傻 x 到用这些来命名变量</p>
<h2>5. C 数据类型</h2>
<p>C 中的类型可分为以下几种：</p>
<table>
<thead>
<tr><th align="left">序号</th><th align="left">类型与描述</th></tr>
</thead>
<tbody>
<tr><td align="left">1</td><td align="left"><strong>基本类型：</strong> 它们是算术类型，包括两种类型：整数类型和浮点类型。</td></tr>
<tr><td align="left">2</td><td align="left"><strong>枚举类型：</strong> 它们也是算术类型，被用来定义在程序中只能赋予其一定的离散整数值的变量。</td></tr>
<tr><td align="left">3</td><td align="left"><strong>void 类型：</strong> 类型说明符 <em>void</em> 表明没有可用的值。</td></tr>
<tr><td align="left">4</td><td align="left"><strong>派生类型：</strong> 它们包括：指针类型、数组类型、结构类型、共用体类型和函数类型。</td></tr>
</tbody>
</table>
<h3>5.1 整数类型</h3>
<p>下表列出了关于标准整数类型的存储大小和值范围的细节：</p>
<table>
<thead>
<tr><th align="left">类型</th><th align="left">存储大小</th><th align="left">值范围</th></tr>
</thead>
<tbody>
<tr><td align="left">char</td><td align="left">1 字节</td><td align="left">-128 到 127 或 0 到 255</td></tr>
<tr><td align="left">unsigned char</td><td align="left">1 字节</td><td align="left">0 到 255</td></tr>
<tr><td align="left">signed char</td><td align="left">1 字节</td><td align="left">-128 到 127</td></tr>
<tr><td align="left">int</td><td align="left">2 或 4 字节</td><td align="left">-32,768 到 32,767 或 -2,147,483,648 到 2,147,483,647</td></tr>
<tr><td align="left">unsigned int</td><td align="left">2 或 4 字节</td><td align="left">0 到 65,535 或 0 到 4,294,967,295</td></tr>
<tr><td align="left">short</td><td align="left">2 字节</td><td align="left">-32,768 到 32,767</td></tr>
<tr><td align="left">unsigned short</td><td align="left">2 字节</td><td align="left">0 到 65,535</td></tr>
<tr><td align="left">long</td><td align="left">4 字节</td><td align="left">-2,147,483,648 到 2,147,483,647</td></tr>
<tr><td align="left">unsigned long</td><td align="left">4 字节</td><td align="left">0 到 4,294,967,295</td></tr>
</tbody>
</table>
<p>注意，各种类型的存储大小与系统位数有关，但目前通用的以 64 位系统为主。</p>
<p>以下列出了 32 位系统与 64 位系统的存储大小的差别（windows 相同）：</p>
<p><img src="https://www.runoob.com/wp-content/uploads/2014/09/32-64.jpg" alt="pic"></p>
<p>为了得到某个类型或某个变量在特定平台上的准确大小，您可以使用 <strong>sizeof</strong> 运算符。表达式 <em>sizeof(type)</em> 得到对象或类型的存储字节大小。下面的实例演示了获取 int 类型的大小：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;limits.h&gt;
 
int main()
{
   printf("int 存储大小 : %lu \n", sizeof(int));
   
   return 0;
}
</code></pre>
<pre><code class="language-shell">int 存储大小 : 4 
</code></pre>
<h3>5.2 浮点类型</h3>
<p>下表列出了关于标准浮点类型的存储大小、值范围和精度的细节：</p>
<table>
<thead>
<tr><th align="left">类型</th><th align="left">存储大小</th><th align="left">值范围</th><th align="left">精度</th></tr>
</thead>
<tbody>
<tr><td align="left">float</td><td align="left">4 字节</td><td align="left">1.2E-38 到 3.4E+38</td><td align="left">6 位小数</td></tr>
<tr><td align="left">double</td><td align="left">8 字节</td><td align="left">2.3E-308 到 1.7E+308</td><td align="left">15 位小数</td></tr>
<tr><td align="left">long double</td><td align="left">16 字节</td><td align="left">3.4E-4932 到 1.1E+4932</td><td align="left">19 位小数</td></tr>
</tbody>
</table>
<h3>5.3 void 类型</h3>
<p>void 类型指定没有可用的值。它通常用于以下三种情况下：</p>
<table>
<thead>
<tr><th align="left">序号</th><th align="left">类型与描述</th></tr>
</thead>
<tbody>
<tr><td align="left">1</td><td align="left"><strong>函数返回为空</strong> C 中有各种函数都不返回值，或者您可以说它们返回空。不返回值的函数的返回类型为空。例如 <strong>void exit (int status);</strong></td></tr>
<tr><td align="left">2</td><td align="left"><strong>函数参数为空</strong> C 中有各种函数不接受任何参数。不带参数的函数可以接受一个 void。例如 <strong>int rand(void);</strong></td></tr>
<tr><td align="left">3</td><td align="left"><strong>指针指向 void</strong> 类型为 void * 的指针代表对象的地址，而不是类型。例如，内存分配函数 <strong>void*malloc( size_t size );</strong> 返回指向 void 的指针，可以转换为任何数据类型。</td></tr>
</tbody>
</table>
<p>如果现在您还是无法完全理解 void 类型，不用太担心，在后续的章节中我们将会详细讲解这些概念。</p>
<h3>Note</h3>
<blockquote>
<p>常用基本数据类型占用空间（64 位机器为例）</p>
<ul>
<li>char ： 1 个字节</li>
<li>int ：4 个字节</li>
<li>float：4 个字节</li>
<li>double：8 个字节</li>
</ul>
<p>基本类型书写</p>
<p><strong>整数</strong></p>
<ul>
<li>a，默认为 10 进制 ，10 ，20。</li>
<li>b，以 0 开头为 8 进制，045，021。</li>
<li>c.，以 0b 开头为 2 进制，0b11101101。</li>
<li>d，以 0x 开头为 16 进制，0x21458adf。</li>
</ul>
<p><strong>小数</strong></p>
<p>单精度常量：2.3f 。</p>
<p>双精度常量：2.3，默认为双精度。</p>
<p><strong>字符型常量</strong></p>
<p>用英文单引号括起来，只保存一个字符'a'、'b' 、'*' ，还有转义字符 '\n' 、'\t'。</p>
<p><strong>字符串常量</strong></p>
<p>用英文的双引号引起来 可以保存多个字符："abc"。</p>
<hr>
<p>1、数据类型转换：C 语言中如果一个表达式中含有不同类型的常量和变量，在计算时，会将它们自动转换为同一种类型；在 C 语言中也可以对数据类型进行强制转换；</p>
<p>2、自动转换规则：</p>
<ul>
<li>a）浮点数赋给整型，该浮点数小数被舍去；</li>
<li>b）整数赋给浮点型，数值不变，但是被存储到相应的浮点型变量中；</li>
</ul>
<p>3、强制类型转换形式： <strong>(类型说明符)(表达式)</strong></p>
<p>实例程序：</p>
<pre><code class="language-c">#include&lt;stdio.h&gt;

int main()
{
   float f,x=3.6,y=5.2;
   int i=4,a,b;
   a=x+y;
   b=(int)(x+y);
   f=10/i;
   printf("a=%d,b=%d,f=%f,x=%f\n",a,b,f,x);
}
</code></pre>
<p>例中先计算 x+y 值为 8.8，然后赋值给 a，因为 a 为整型，所以自取整数部分 8，a=8;</p>
<p>接下来 b 把 x+y 强制转换为整型;</p>
<p>最后 10/i 是两个整数相除，结果仍为整数 2，把 2 赋给浮点数 f;</p>
<p>x 为浮点型直接输出。</p>
</blockquote>
<h2>6. clang 变量</h2>
<table>
<thead>
<tr><th align="left">类型</th><th align="left">描述</th></tr>
</thead>
<tbody>
<tr><td align="left">char</td><td align="left">通常是一个字节（八位）。这是一个整数类型。</td></tr>
<tr><td align="left">int</td><td align="left">对机器而言，整数的最自然的大小。</td></tr>
<tr><td align="left">float</td><td align="left">单精度浮点值。单精度是这样的格式，1 位符号，8 位指数，23 位小数。<img src="https://www.runoob.com/wp-content/uploads/2014/09/v2-749cc641eb4d5dafd085e8c23f8826aa_hd.png" alt="img"></td></tr>
<tr><td align="left">double</td><td align="left">双精度浮点值。双精度是 1 位符号，11 位指数，52 位小数。<img src="https://www.runoob.com/wp-content/uploads/2014/09/v2-48240f0e1e0dd33ec89100cbe2d30707_hd.png" alt="img"></td></tr>
<tr><td align="left">void</td><td align="left">表示类型的缺失。</td></tr>
</tbody>
</table>
<h3>6.1 C 中的变量声明</h3>
<p>变量的声明有两种情况：</p>
<ul>
<li>1、一种是需要建立存储空间的。例如：int a 在声明的时候就已经建立了存储空间。</li>
<li>2、另一种是不需要建立存储空间的，通过使用 extern 关键字声明变量名而不定义它。 例如：extern int a 其中变量 a 可以在别的文件中定义的。</li>
<li>除非有<a href="#point1">extern</a>关键字，否则都是变量的定义。</li>
</ul>
<pre><code class="language-c">extern int i; //声明，不是定义
int i; //声明，也是定义
</code></pre>
<h3>6.2 代码实例：</h3>
<pre><code class="language-c">#include &lt;stdio.h&gt;
 
// 函数外定义变量 x 和 y
int x;
int y;
int addtwonum()
{
    // 函数内声明变量 x 和 y 为外部变量
    extern int x;
    extern int y;
    // 给外部变量（全局变量）x 和 y 赋值
    x = 1;
    y = 2;
    return x+y;
}
 
int main()
{
    int result;
    // 调用函数 addtwonum
    result = addtwonum();
    
    printf("result 为: %d",result);
    return 0;
}
</code></pre>
<p>如果我们将**addtwonum()**独立为一个文件呢？试试看！</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
/*外部变量声明*/
extern int x ;
extern int y ;
int addtwonum()
{
    return x+y;
}
</code></pre>
<pre><code class="language-c">#include &lt;stdio.h&gt;
  
/*定义两个全局变量*/
int x=1;
int y=2;
int addtwonum();
int main(void)
{
    int result;
    result = addtwonum();
    printf("result 为: %d\n",result);
    return 0;
}
</code></pre>
<p>如果需要在一个源文件中引用另外一个源文件中定义的变量，我们只需在引用的文件中将变量加上 extern 关键字的声明即可。</p>
<h2>7. 常量</h2>
<h3>7.1 整数常量</h3>
<p>整数常量可以是十进制、八进制或十六进制的常量。前缀指定基数：0x 或 0X 表示十六进制，0 表示八进制，不带前缀则默认表示十进制。</p>
<p>整数常量也可以带一个后缀，后缀是 U 和 L 的组合，U 表示无符号整数（unsigned），L 表示长整数（long）。后缀可以是大写，也可以是小写，U 和 L 的顺序任意。</p>
<p>以下是各种类型的整数常量的实例：</p>
<pre><code>85         /* 十进制 */
0213       /* 八进制 */
0x4b       /* 十六进制 */
30         /* 整数 */
30u        /* 无符号整数 */
30l        /* 长整数 */
30ul       /* 无符号长整数 */
</code></pre>
<h3>7.2 浮点常量</h3>
<p>浮点常量由整数部分、小数点、小数部分和指数部分组成。您可以使用小数形式或者指数形式来表示浮点常量。</p>
<p>当使用小数形式表示时，必须包含整数部分、小数部分，或同时包含两者。当使用指数形式表示时， 必须包含小数点、指数，或同时包含两者。带符号的指数是用 e 或 E 引入的。</p>
<p>下面列举几个浮点常量的实例：</p>
<pre><code>3.14159       /* 合法的 */
314159E-5L    /* 合法的 */
510E          /* 非法的：不完整的指数 */
210f          /* 非法的：没有小数或指数 */
.e55          /* 非法的：缺少整数或分数 */
</code></pre>
<h3>7.3 字符常量</h3>
<p>字符常量是括在单引号中，例如，'x' 可以存储在 <strong>char</strong> 类型的简单变量中。</p>
<p>字符常量可以是一个普通的字符（例如 'x'）、一个转义序列（例如 '\t'），或一个通用的字符（例如 '\u02C0'）。</p>
<p>在 C 中，有一些特定的字符，当它们前面有反斜杠时，它们就具有特殊的含义，被用来表示如换行符（\n）或制表符（\t）等。下表列出了一些这样的转义序列码：</p>
<table>
<thead>
<tr><th align="left">转义序列</th><th align="left">含义</th></tr>
</thead>
<tbody>
<tr><td align="left">\</td><td align="left">\ 字符</td></tr>
<tr><td align="left">'</td><td align="left">' 字符</td></tr>
<tr><td align="left">"</td><td align="left">" 字符</td></tr>
<tr><td align="left">?</td><td align="left">? 字符</td></tr>
<tr><td align="left">\a</td><td align="left">警报铃声</td></tr>
<tr><td align="left">\b</td><td align="left">退格键</td></tr>
<tr><td align="left">\f</td><td align="left">换页符</td></tr>
<tr><td align="left">\n</td><td align="left">换行符</td></tr>
<tr><td align="left">\r</td><td align="left">回车</td></tr>
<tr><td align="left">\t</td><td align="left">水平制表符</td></tr>
<tr><td align="left">\v</td><td align="left">垂直制表符</td></tr>
<tr><td align="left">\ooo</td><td align="left">一到三位的八进制数</td></tr>
<tr><td align="left">\xhh . . .</td><td align="left">一个或多个数字的十六进制数</td></tr>
</tbody>
</table>
<p>下面的实例显示了一些转义序列字符：</p>
<h3>7.4 字符串常量</h3>
<p>字符串字面值或常量是括在双引号 "" 中的。一个字符串包含类似于字符常量的字符：普通的字符、转义序列和通用的字符。</p>
<p>您可以使用空格做分隔符，把一个很长的字符串常量进行分行。</p>
<p>下面的实例显示了一些字符串常量。下面这三种形式所显示的字符串是相同的。</p>
<pre><code>"hello, dear"

"hello, \

dear"

"hello, " "d" "ear"
</code></pre>
<h3>7.5 定义常量</h3>
<p>在 C 中，有两种简单的定义常量的方式：</p>
<ol>
<li>使用 <strong>#define</strong> 预处理器。</li>
<li>使用 <strong>const</strong> 关键字。</li>
</ol>
<h4>7.5.1 #define 预处理器</h4>
<p>下面是使用 #define 预处理器定义常量的形式：</p>
<pre><code>#define identifier value
</code></pre>
<pre><code class="language-c">#include &lt;stdio.h&gt;
 
#define LENGTH 10   
#define WIDTH  5
#define NEWLINE '\n'
 
int main()
{
   int area= LENGTH * WIDTH;
  
   printf("value of area : %d", area);
   printf("%c", NEWLINE);
 
   return 0;
}
</code></pre>
<pre><code class="language-shell">value of area : 50
</code></pre>
<h4>7.5.2 const 关键字</h4>
<p>您可以使用 <strong>const</strong> 前缀声明指定类型的常量，如下所示：</p>
<pre><code>const type variable = value;
</code></pre>
<pre><code class="language-c">#include &lt;stdio.h&gt;
 
int main()
{
   const int  LENGTH = 10;
   const int  WIDTH  = 5;
   const char NEWLINE = '\n';
   int area = LENGTH * WIDTH;  
   
   printf("value of area : %d", area);
   printf("%c", NEWLINE);
 
   return 0;
}
</code></pre>
<pre><code class="language-shell">value of area : 50
</code></pre>
<h2>8. C 存储类</h2>
<p>存储类定义 C 程序中变量/函数的范围（可见性）和生命周期。这些说明符放置在它们所修饰的类型之前。下面列出 C 程序中可用的存储类：</p>
<ul>
<li>auto</li>
<li>register</li>
<li>static</li>
<li>extern</li>
</ul>
<h3>8.1 auto 存储类</h3>
<p><strong>auto</strong> 存储类是所有局部变量默认的存储类。</p>
<pre><code>{
   int mount;
   auto int month;
}
</code></pre>
<p>上面的实例定义了两个带有相同存储类的变量，auto 只能用在函数内，即 auto 只能修饰局部变量。</p>
<h3>8.2 register 存储类</h3>
<p><strong>register</strong> 存储类用于定义存储在寄存器中而不是 RAM 中的局部变量。这意味着变量的最大尺寸等于寄存器的大小（通常是一个词），且不能对它应用一元的 '&amp;' 运算符（因为它没有内存位置）。</p>
<pre><code>{
   register int  miles;
}
</code></pre>
<p>寄存器只用于需要快速访问的变量，比如计数器。还应注意的是，定义 'register' 并不意味着变量将被存储在寄存器中，它意味着变量可能存储在寄存器中，这取决于硬件和实现的限制。</p>
<h3>8.3 static 存储类</h3>
<p><strong>static</strong> 存储类指示编译器在程序的生命周期内保持局部变量的存在，而不需要在每次它进入和离开作用域时进行创建和销毁。因此，使用 static 修饰局部变量可以在函数调用之间保持局部变量的值。</p>
<p>static 修饰符也可以应用于全局变量。当 static 修饰全局变量时，会使变量的作用域限制在声明它的文件内。</p>
<p>全局声明的一个 static 变量或方法可以被任何函数或方法调用，只要这些方法出现在跟 static 变量或方法同一个文件中。</p>
<p>以下实例演示了 static 修饰全局变量和局部变量的应用：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

static int count=10;        /* 全局变量 - static 是默认的 */
 
void func1(void)
{
/* 'thingy' 是 'func1' 的局部变量 - 只初始化一次
 * 每次调用函数 'func1' 'thingy' 值不会被重置。
 */                
  static int thingy=5;
  thingy++;
  printf(" thingy 为 %d ， count 为 %d\n", thingy, count);
}

int main()
{
  while (count--) {
      func1();
  }
  return 0;
}
</code></pre>
<pre><code> thingy 为 6 ， count 为 9
 thingy 为 7 ， count 为 8
 thingy 为 8 ， count 为 7
 thingy 为 9 ， count 为 6
 thingy 为 10 ， count 为 5
 thingy 为 11 ， count 为 4
 thingy 为 12 ， count 为 3
 thingy 为 13 ， count 为 2
 thingy 为 14 ， count 为 1
 thingy 为 15 ， count 为 0
</code></pre>
<p><strong>可以看出加了 static 后，局部变量就变成了类似全局变量了，但是仅仅是定义了这个存储类的对象可以访问</strong></p>
<h3>8.4 <span id="point1"> extern </span> 存储类</h3>
<p><strong>extern</strong> 存储类用于提供一个全局变量的引用，全局变量对所有的程序文件都是可见的。当您使用 <strong>extern</strong> 时，对于无法初始化的变量，会把变量名指向一个之前定义过的存储位置。</p>
<p>当您有多个文件且定义了一个可以在其他文件中使用的全局变量或函数时，可以在其他文件中使用 <em>extern</em> 来得到已定义的变量或函数的引用。可以这么理解，<em>extern</em> 是用来在另一个文件中声明一个全局变量或函数。</p>
<p>extern 修饰符通常用于当有两个或多个文件共享相同的全局变量或函数的时候，如下所示：</p>
<p><strong>第一个文件：main.c</strong></p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
 
int count ;
extern void write_extern();
 
int main()
{
   count = 5;
   write_extern();
}
</code></pre>
<p><strong>第二个文件：support.c</strong></p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
 
extern int count;
 
void write_extern(void)
{
   printf("count is %d\n", count);
}
</code></pre>
<p>在这里，第二个文件中的 <em>extern</em> 关键字用于声明已经在第一个文件 main.c 中定义的 <em>count</em>。现在 ，编译这两个文件，如下所示：</p>
<pre><code> $ gcc main.c support.c
</code></pre>
<p>这会产生 <strong>a.out</strong> 可执行程序，当程序被执行时，它会产生下列结果：</p>
<pre><code>count is 5
</code></pre>]]></description>
      <author>JokerLee</author>
      <guid>https://jokeme.top/articles/2020/08/31/1598851343874.html</guid>
      <category>clang</category>
      <pubDate>Fri, 04 Sep 2020 23:38:11 +0800</pubDate>
    </item>
    <item>
      <title>解决一个Ubuntu 18 安装MySQL 5.7不能远程登录的问题</title>
      <link>https://jokeme.top/articles/2020/07/28/1595932645078.html</link>
      <description><![CDATA[<p>首先编辑 /etc/mysql/mysql.conf.d/mysqld.cnf 配置文件：</p>
<pre><code>nano  /etc/mysql/mysql.conf.d/mysqld.cnf
</code></pre>
<p>注释掉</p>
<pre><code>bind-address = 127.0.0.1
#如果没有就跳过
</code></pre>
<p>还有就是要给<code>root</code> 设置一个密码，允许他远程登录</p>
<pre><code>use mysql;
SELECT  user,host FROM  user;
update user set host="%" where user="root"
update user set authentication_string=PASSWORD("UrPasswd")where user="root";
flush privileges;
</code></pre>
<p>如果<strong>MySQL5.7</strong> 这样还不能远程登录上，咱见面持刀互a，如果你比我猛，当我没有说！</p>
<p>你以为这就完了吗？？哪有这么简单，你还需要下面这条命令</p>
<pre><code>update user set plugin='mysql_native_password';
#放在上面 use mysql； 后面执行
</code></pre>
<p>很多人都是忽略了这条命令，导致一直无法远程登录上<strong>MySQL</strong>*<br>
必要的话可以重启一下MySQL哦！</p>]]></description>
      <author>JokerLee</author>
      <guid>https://jokeme.top/articles/2020/07/28/1595932645078.html</guid>
      <category>mysql</category>
      <pubDate>Tue, 28 Jul 2020 18:37:25 +0800</pubDate>
    </item>
    <item>
      <title>关于 Maven 下载插件缓慢的问题</title>
      <link>https://jokeme.top/articles/2020/07/23/1595502243908.html</link>
      <description><![CDATA[<h1>关于 Maven 下载插件缓慢的问题</h1>
<p>众所周知,咱们大天朝由于各种原因,只能活在局域网里面.这可能对那些不深度使用网络的人来说不痛不痒,但是你要是搞开发,搞运维,那才是各种烦呢</p>
<p>就拿 <code>maven</code>来说,我™下载一个几kb得依赖都要好几个小时,甚至还要看运气</p>
<p>网上也给了各种各样得解决方案<del>特指 CSDN</del>,但是我去尝试后,他妈的怎么弄都不行!!!我就搞不明白了,有些作者<del>特指那种只会复制粘贴别人文章的</del>,连别人文章的有效性都不去验证一下,就直接拿过来当作自己的了,太恶心了??</p>
<p>好嘞废话不多说了,还是说 <code>maven</code> 吧<br>
以前阿里源还是 <strong>http</strong> ,所以用网上的方法还是有效的,但是当阿里把 <strong>http</strong> 升级为<strong>https</strong> 后,原来的方法就失效了</p>
<ol>
<li>idea编辑器:忽略<code>ssl</code>的配置,Maven -&gt; Runner -&gt; VM Options添加</li>
</ol>
<pre><code>-Dmaven.wagon.http.ssl.insecure=true -Dmaven.wagon.http.ssl.allowall=true -Dmaven.wagon.http.ssl.ignore.validity.dates=true
</code></pre>
<p>Eclipse操作大致同上,忽略 <code>ssl</code>即可</p>
<p>另外想屏蔽CSDN得话可以用 <strong>Tampermonkey</strong> 脚本来屏蔽一下<br>
p.s. 需要先安装 <strong>Tampermonkey</strong> 再安装 <strong><a href="https://greasyfork.org/zh-CN/scripts/395382-%E7%99%BE%E5%BA%A6%E6%90%9C%E7%B4%A2%E7%BB%93%E6%9E%9C%E5%B1%8F%E8%94%BDcsdn%E5%8D%9A%E5%AE%A2" target="_blank">百度搜索结果屏蔽csdn博客</a></strong></p>
<p>文章转自博客园作者:<strong><a href="https://www.cnblogs.com/lisongyu/p/12600952.html" target="_blank">lisongyu</a></strong><br>
原文链接:<strong><a href="https://www.cnblogs.com/lisongyu/p/12600952.html" target="_blank">关于maven使用阿里源无法生效问题</a></strong></p>]]></description>
      <author>JokerLee</author>
      <guid>https://jokeme.top/articles/2020/07/23/1595502243908.html</guid>
      <category>Tampermonkey</category>
      <category>Maven</category>
      <pubDate>Thu, 23 Jul 2020 19:04:04 +0800</pubDate>
    </item>
    <item>
      <title>简单解释 NAT</title>
      <link>https://jokeme.top/articles/2020/07/15/1594823469464.html</link>
      <description><![CDATA[<h1>简单解释 NAT[转自知乎]</h1>
<p>NAT 大家应该十分熟悉了，它分为几种。一种就叫做 NAT，它只对 IP 地址进行转换；另一种叫做 NAPT（Network Address/Port Translation），它可以对整个会话的端点（由 IP 地址和端口号组成）做转换，这是一种更加常见的 NAT 变种。</p>
<p>当然了，NAPT 也分为许多种，我们这里就不深入探讨了，大家如果有兴趣可以查阅相关的文献。</p>
<p>下面就简单介绍一下 NAT 的工作原理：</p>
<p><img src="https://pic4.zhimg.com/80/v2-62cb7ac6f3ef6272314dfe0a822b35a3_720w.jpg" alt="img"></p>
<p>首先，NAT A 网下的设备 1（192.168.1.101）想与某公网 IP 通讯，设备 1 将包发给 NAT A，然后 NAT A 对源 IP 进行转换发给 NAT B（中间可能还会经过多重 NAT）。</p>
<p>这样做的目的是，NAT B 并不知晓 NAT A 下的各个设备，他只能与 NAT A 本身通讯，因此发送给 NAT B 的包源 IP 必须是 NAT A 的公网 IP，不然 NAT B 没有办法进行回复。</p>
<p>接下来 NAT B 将回复包再发回 NAT A，此时就是 NAT 发挥作用的时候了，NAT A 现在要做的就是将包再分发回之前的设备，如何确定要发给谁呢？NAT 中记录了一张表，之前 192.168.1.101 通过 2333 端口与 42.120.241.46 端口 443 通讯了，并且 NAT A 是用 60001 的端口转发出去的，那么这次接受到发往该 NAT 60001 端口的包时就应该再通过 2333 端口转发给 192.168.1.101。经过这样的过程，NAT A 下的设备都可以连接到互联网了！</p>
<h2>UDP 打洞原理及过程</h2>
<p>如上图所示，由于 NAT 的存在，当 NAT A 的设备 1 想与 NAT B 下的设备通讯时，必然要将目标 IP 设置为 NAT B 的公网地址，而 NAT B 转发表中并没有记录过 NAT A 与自身网络下设备的通讯记录，因此 NAT B 会将包丢掉。</p>
<p>下面我们来看看 UDP 打洞是怎么解决这个问题的。</p>
<p><img src="https://pic4.zhimg.com/80/v2-52767d1e9ac42d6416025fc5080016d7_720w.jpg" alt="img"></p>
<p>为了能够进行 UDP 打洞，我们需要一台公网的服务器作为中转站，它是 NAT A 与 NAT B 之间的信使。</p>
<p>（为了方便起见，我们把地址为 192.168.1.101 的设备称为设备 1，把地址为 192.168.1.2 的设备称为设备 2，信使服务器称为 S）</p>
<p>首先，设备 1 和设备 2 都向 S 注册自己，S 中能记录各个设备此时使用的公网 IP 地址和端口号，例如设备 1 是 123.122.53.20:31000，设备 2 是 42.120.241.46:41000。</p>
<p>然后设备 1 与设备 2 都向 S 获取对方的公网 IP 与之前预留的端口号，就像这样：</p>
<p><img src="https://pic4.zhimg.com/80/v2-6e2bb16c9c7c4a7ad9e1807a8648e02f_720w.jpg" alt="img"></p>
<p>然后就是最关键的一步，打洞。</p>
<p>设备 1 向 42.120.241.46:41000 发一个包，NAT B 自然能接收到这个包，然而它不知道来自 NAT A 的包应该发给谁，因此 NAT B 将这个包舍弃。但是由于设备 1 向 42.120.241.46:41000 发过包，NAT A 会记录：<strong>以后来自 42.120.241.46:41000 的包都发给设备 1</strong>。</p>
<p>设备 2 也做相同的操作，让 NAT B 也知道：<strong>以后来自 123.122.53.20:31000 的包都发给设备 2</strong>。</p>
<p>至此，NAT A 与 NAT B 都互相为对方保留了端口，就可以愉快地通讯了。</p>
<p>本文 <del>参考</del> 抄袭自知乎文章 <a href="https://zhuanlan.zhihu.com/p/40816201" target="_blank">简单解释 NAT</a></p>]]></description>
      <author>JokerLee</author>
      <guid>https://jokeme.top/articles/2020/07/15/1594823469464.html</guid>
      <category>NAT</category>
      <pubDate>Fri, 17 Jul 2020 01:21:50 +0800</pubDate>
    </item>
    <item>
      <title>VS code 快捷键大全</title>
      <link>https://jokeme.top/articles/2020/07/17/1594919904452.html</link>
      <description><![CDATA[<h2>General</h2>
<p>Ctrl+Shift+P, F1 Show Command Palette</p>
<p>Ctrl+P Quick Open, Go to File…</p>
<p>Ctrl+Shift+N New window/instance</p>
<p>Ctrl+Shift+W Close window/instance</p>
<p>Ctrl+, User Settings</p>
<p>Ctrl+K Ctrl+S Keyboard Shortcuts</p>
<h2>Basic editing</h2>
<p>Ctrl+X Cut line (empty selection)</p>
<p>Ctrl+C Copy line (empty selection)</p>
<p>Alt+ ↑ / ↓ Move line up/down</p>
<p>Shift+Alt + ↓ / ↑ Copy line up/down</p>
<p>Ctrl+Shift+K Delete line</p>
<p>Ctrl+Enter Insert line below</p>
<p>Ctrl+Shift+Enter Insert line above</p>
<p>Ctrl+Shift+\ Jump to matching bracket</p>
<p>Ctrl+] / [ Indent/outdent line</p>
<p>Home / End Go to beginning/end of line</p>
<p>Ctrl+Home Go to beginning of file</p>
<p>Ctrl+End Go to end of file</p>
<p>Ctrl+↑ / ↓ Scroll line up/down</p>
<p>Alt+PgUp / PgDn Scroll page up/down</p>
<p>Ctrl+Shift+[ Fold (collapse) region</p>
<p>Ctrl+Shift+] Unfold (uncollapse) region</p>
<p>Ctrl+K Ctrl+[ Fold (collapse) all subregions</p>
<p>Ctrl+K Ctrl+] Unfold (uncollapse) all subregions</p>
<p>Ctrl+K Ctrl+0 Fold (collapse) all regions</p>
<p>Ctrl+K Ctrl+J Unfold (uncollapse) all regions</p>
<p>Ctrl+K Ctrl+C Add line comment</p>
<p>Ctrl+K Ctrl+U Remove line comment</p>
<p>Ctrl+/ Toggle line comment</p>
<p>Shift+Alt+A Toggle block comment</p>
<p>Alt+Z Toggle word wrap</p>
<h2>Navigation</h2>
<p>Ctrl+T Show all Symbols</p>
<p>Ctrl+G Go to Line...</p>
<p>Ctrl+P Go to File...</p>
<p>Ctrl+Shift+O Go to Symbol...</p>
<p>Ctrl+Shift+M Show Problems panel</p>
<p>F8 Go to next error or warning</p>
<p>Shift+F8 Go to previous error or warning</p>
<p>Ctrl+Shift+Tab Navigate editor group history</p>
<p>Alt+ ← / → Go back / forward</p>
<p>Ctrl+M Toggle Tab moves focus</p>
<h2>Search and replace</h2>
<p>Ctrl+F Find Ctrl+H Replace</p>
<p>F3 / Shift+F3 Find next/previous</p>
<p>Alt+Enter Select all occurences of Find match</p>
<p>Ctrl+D Add selection to next Find match</p>
<p>Ctrl+K Ctrl+D Move last selection to next Find match</p>
<p>Alt+C / R / W Toggle case-sensitive / regex / whole word</p>
<h2>Multi-cursor and selection</h2>
<p>Alt+Click Insert cursor</p>
<p>Ctrl+Alt+ ↑ / ↓ Insert cursor above / below</p>
<p>Ctrl+U Undo last cursor operation</p>
<p>Shift+Alt+I Insert cursor at end of each line selected</p>
<p>Ctrl+L Select current line</p>
<p>Ctrl+Shift+L Select all occurrences of current selection</p>
<p>Ctrl+F2 Select all occurrences of current word</p>
<p>Shift+Alt+→ Expand selection</p>
<p>Shift+Alt+← Shrink selection</p>
<p>Shift+Alt + (drag mouse) Column (box) selection</p>
<p>Ctrl+Shift+Alt + (arrow key) Column (box) selection</p>
<p>Ctrl+Shift+Alt +PgUp/PgDn</p>
<h2>Rich languages editing</h2>
<p>Ctrl+Space Trigger suggestion</p>
<p>Ctrl+Shift+Space Trigger parameter hints</p>
<p>Shift+Alt+F Format document</p>
<p>Ctrl+K Ctrl+F Format selection</p>
<p>F12 Go to Definition</p>
<p>Alt+F12 Peek Definition</p>
<p>Ctrl+K F12 Open Definition to the side</p>
<p>Ctrl+. Quick Fix</p>
<p>Shift+F12 Show References</p>
<p>F2 Rename Symbol</p>
<p>Ctrl+K Ctrl+X Trim trailing whitespace</p>
<p>Ctrl+K M Change file language</p>
<h2>Editor management</h2>
<p>Ctrl+F4, Ctrl+W Close editor</p>
<p>Ctrl+K F Close folder</p>
<p>Ctrl+\ Split editor</p>
<p>Ctrl+ 1 / 2 / 3 Focus into 1 st, 2nd or 3rd editor group</p>
<p>Ctrl+K Ctrl+ ←/→ Focus into previous/next editor group</p>
<p>Ctrl+Shift+PgUp / PgDn Move editor left/right</p>
<p>Ctrl+K ← / → Move active editor group</p>
<h2>File management</h2>
<p>Ctrl+N New File</p>
<p>Ctrl+O Open File...</p>
<p>Ctrl+S Save</p>
<p>Ctrl+Shift+S Save As...</p>
<p>Ctrl+K S Save All</p>
<p>Ctrl+F4 Close</p>
<p>Ctrl+K Ctrl+W Close All</p>
<p>Ctrl+Shift+T Reopen closed editor</p>
<p>Ctrl+K Enter Keep preview mode editor open</p>
<p>Ctrl+Tab Open next</p>
<p>Ctrl+Shift+Tab Open previous</p>
<p>Ctrl+K P Copy path of active file</p>
<p>Ctrl+K R Reveal active file in Explorer</p>
<p>Ctrl+K O Show active file in new window/instance</p>
<h2>Display</h2>
<p>F11 Toggle full screen</p>
<p>Shift+Alt+0 Toggle editor layout (horizontal/vertical)</p>
<p>Ctrl+ = / - Zoom in/out Ctrl+B Toggle Sidebar visibility</p>
<p>Ctrl+Shift+E Show Explorer / Toggle focus</p>
<p>Ctrl+Shift+F Show Search</p>
<p>Ctrl+Shift+G Show Source Control</p>
<p>Ctrl+Shift+D Show Debug</p>
<p>Ctrl+Shift+X Show Extensions</p>
<p>Ctrl+Shift+H Replace in files</p>
<p>Ctrl+Shift+J Toggle Search details</p>
<p>Ctrl+Shift+U Show Output panel</p>
<p>Ctrl+Shift+V Open Markdown preview</p>
<p>Ctrl+K V Open Markdown preview to the side</p>
<p>Ctrl+K Z Zen Mode (Esc Esc to exit)</p>
<h2>Debug</h2>
<p>F9 Toggle breakpoint</p>
<p>F5 Start/Continue</p>
<p>Shift+F5 Stop</p>
<p>F11 / Shift+F11 Step into/out</p>
<p>F10 Step over</p>
<p>Ctrl+K Ctrl+I Show hover</p>
<h2>Integrated terminal</h2>
<p>Ctrl+` Show integrated terminal</p>
<p>Ctrl+Shift+` Create new terminal</p>
<p>Ctrl+C Copy selection</p>
<p>Ctrl+V Paste into active terminal</p>
<p>Ctrl+↑ / ↓ Scroll up/down</p>
<p>Shift+PgUp / PgDn Scroll page up/down</p>
<p>Ctrl+Home / End Scroll to top/bottom</p>
<p>译文:</p>
<h2>一般</h2>
<p>Ctrl + Shift + P，F1显示命令面板</p>
<p>Ctrl + P快速打开，转到文件…</p>
<p>Ctrl + Shift + N新窗口/实例</p>
<p>Ctrl + Shift + W关闭窗口/实例</p>
<p>Ctrl +，用户设置</p>
<p>Ctrl + K Ctrl + S键盘快捷键</p>
<h2>基本编辑</h2>
<p>Ctrl + X剪切线（空选择）</p>
<p>Ctrl + C复制行（空选择）</p>
<p>Alt +↑/↓上下移动行</p>
<p>Shift + Alt +↓/↑复制上/下一行</p>
<p>Ctrl + Shift + K删除行</p>
<p>Ctrl + Enter在下面插入行</p>
<p>Ctrl + Shift + Enter在上方插入行</p>
<p>Ctrl + Shift + \跳转到匹配的括号</p>
<p>Ctrl +] / [缩进/缩进行</p>
<p>Home / End转到行首/行尾</p>
<p>Ctrl + Home转到文件开头</p>
<p>Ctrl + End转到文件末尾</p>
<p>Ctrl +↑/↓上下滚动</p>
<p>Alt + PgUp / PgDn向上/​​向下滚动页面</p>
<p>Ctrl + Shift + [折叠（折叠）区域</p>
<p>Ctrl + Shift +]展开（展开）区域</p>
<p>Ctrl + K Ctrl + [折叠（折叠）所有子区域</p>
<p>Ctrl + K Ctrl +]展开（展开）所有子区域</p>
<p>Ctrl + K Ctrl + 0折叠（折叠）所有区域</p>
<p>Ctrl + K Ctrl + J展开（展开）所有区域</p>
<p>Ctrl + K Ctrl + C添加行注释</p>
<p>Ctrl + K Ctrl + U删除行注释</p>
<p>Ctrl + /切换行注释</p>
<p>Shift + Alt + A切换块注释</p>
<p>Alt + Z切换自动换行</p>
<h2>导航</h2>
<p>Ctrl + T显示所有符号</p>
<p>Ctrl + G转到行...</p>
<p>Ctrl + P转到文件...</p>
<p>Ctrl + Shift + O转到符号...</p>
<p>Ctrl + Shift + M显示问题面板</p>
<p>F8转到下一个错误或警告</p>
<p>Shift + F8转到上一个错误或警告</p>
<p>Ctrl + Shift + Tab导航编辑器组的历史记录</p>
<p>Alt +←/→返回/前进</p>
<p>Ctrl + M切换选项卡可移动焦点</p>
<h2>搜索并替换</h2>
<p>Ctrl + F查找Ctrl + H替换</p>
<p>F3 / Shift + F3查找下一个/上一个</p>
<p>Alt + Enter选择所有出现的“查找匹配项”</p>
<p>Ctrl + D将选择添加到下一个查找匹配项</p>
<p>Ctrl + K Ctrl + D将最后一个选择移至下一个查找匹配项</p>
<p>Alt + C / R / W切换区分大小写/正则表达式/整个单词</p>
<h2>多光标和选择</h2>
<p>Alt +单击插入光标</p>
<p>Ctrl + Alt +↑/↓在上方/下方插入光标</p>
<p>Ctrl + U撤消上一个光标操作</p>
<p>Shift + Alt + I在选定的每行末尾插入光标</p>
<p>Ctrl + L选择当前行</p>
<p>Ctrl + Shift + L选择所有当前选中项</p>
<p>Ctrl + F2选择所有出现的当前单词</p>
<p>Shift + Alt +→扩展选择</p>
<p>Shift + Alt +←缩小选择</p>
<p>Shift + Alt +（拖动鼠标）列（框）选择</p>
<p>Ctrl + Shift + Alt +（箭头键）列（框）选择</p>
<p>Ctrl + Shift + Alt + PgUp / PgDn</p>
<h2>富语言编辑</h2>
<p>Ctrl +空格触发建议</p>
<p>Ctrl + Shift +空格键触发参数提示</p>
<p>Shift + Alt + F格式文件</p>
<p>Ctrl + K Ctrl + F格式选择</p>
<p>F12转到定义</p>
<p>Alt + F12偷看定义</p>
<p>Ctrl + K F12在侧面打开定义</p>
<p>Ctrl +。快速解决</p>
<p>Shift + F12显示参考</p>
<p>F2重命名符号</p>
<p>Ctrl + K Ctrl + X修剪尾随空格</p>
<p>Ctrl + K M更改文件语言</p>
<h2>编辑器管理</h2>
<p>Ctrl + F4，Ctrl + W关闭编辑器</p>
<p>Ctrl + K F关闭文件夹</p>
<p>Ctrl + \分割编辑器</p>
<p>Ctrl + 1/2/3聚焦到第1，第2或第3编辑器组</p>
<p>Ctrl + K Ctrl +←/→聚焦到上一个/下一个编辑器组</p>
<p>Ctrl + Shift + PgUp / PgDn左右移动编辑器</p>
<p>Ctrl + K←/→移动活动的编辑器组</p>
<h2>文件管理</h2>
<p>Ctrl + N新建文件</p>
<p>Ctrl + O打开文件...</p>
<p>Ctrl + S保存</p>
<p>Ctrl + Shift + S另存为...</p>
<p>Ctrl + K S全部保存</p>
<p>Ctrl + F4关闭</p>
<p>Ctrl + K Ctrl + W关闭所有</p>
<p>Ctrl + Shift + T重新打开关闭的编辑器</p>
<p>Ctrl + K输入保持打开预览模式编辑器</p>
<p>Ctrl + Tab打开下一步</p>
<p>Ctrl + Shift + Tab打开上一个</p>
<p>Ctrl + K P复制活动文件的路径</p>
<p>Ctrl + K R在资源管理器中显示活动文件</p>
<p>Ctrl + K O在新窗口/实例中显示活动文件</p>
<h2>显示</h2>
<p>F11切换全屏</p>
<p>Shift + Alt + 0切换编辑器布局（水平/垂直）</p>
<p>Ctrl + = /-放大/缩小Ctrl + B切换边栏可见性</p>
<p>Ctrl + Shift + E显示资源管理器/切换焦点</p>
<p>Ctrl + Shift + F显示搜索</p>
<p>Ctrl + Shift + G显示源代码控制</p>
<p>Ctrl + Shift + D显示调试</p>
<p>Ctrl + Shift + X显示扩展</p>
<p>Ctrl + Shift + H替换为文件</p>
<p>Ctrl + Shift + J切换搜索详细信息</p>
<p>Ctrl + Shift + U显示输出面板</p>
<p>Ctrl + Shift + V打开Markdown预览</p>
<p>Ctrl + K V在侧面打开Markdown预览</p>
<p>Ctrl + K Z禅模式（Esc Esc退出）</p>
<h2>调试</h2>
<p>F9切换断点</p>
<p>F5开始/继续</p>
<p>Shift + F5停止</p>
<p>F11 / Shift + F11跳入/跳出</p>
<p>F10越过</p>
<p>Ctrl + K Ctrl + I显示悬停</p>
<h2>集成终端</h2>
<p>Ctrl +`显示集成终端</p>
<p>Ctrl + Shift +`创建新终端</p>
<p>Ctrl + C复制选择</p>
<p>Ctrl + V粘贴到活动终端</p>
<p>Ctrl +↑/↓向上/向下滚动</p>
<p>Shift + PgUp / PgDn向上/​​向下滚动页面</p>
<p>Ctrl + Home / End滚动到顶部/底部</p>
<h4>本文在 <a href="https://code.visualstudio.com/shortcuts/keyboard-shortcuts-windows.pdf" target="_blank">visualstudiocode</a> 快捷键的原文基础上进行整理修改</h4>]]></description>
      <author>JokerLee</author>
      <guid>https://jokeme.top/articles/2020/07/17/1594919904452.html</guid>
      <category>vscode</category>
      <pubDate>Fri, 17 Jul 2020 01:18:24 +0800</pubDate>
    </item>
    <item>
      <title>在微软官网下载 Windows10 ISO 安装包</title>
      <link>https://jokeme.top/articles/2020/07/14/1594738294949.html</link>
      <description><![CDATA[<h1>教大家如何在微软官网下载 Windows10 ISO 安装包</h1>
<ol>
<li>进入 <a href="https://www.microsoft.com/zh-cn/software-download/windows10" target="_blank">Windows10</a> 下载页面</li>
<li><code>CTRL+SHIFT+I</code> 后再 <code>CTRL+SHIFT+M</code>再接一个 <code>CTRL+R</code></li>
</ol>
<p>你就可以看到让你选择 Windows 版本,个人建议不要选家庭中文版<br>
然后一路下来也没有啥难点了,他就会为你创建一个24H内有效的链接,记得尽快下载系统哦</p>
<p>就这了</p>]]></description>
      <author>JokerLee</author>
      <guid>https://jokeme.top/articles/2020/07/14/1594738294949.html</guid>
      <category>Windows10</category>
      <pubDate>Tue, 14 Jul 2020 22:51:35 +0800</pubDate>
    </item>
    <item>
      <title>Linux 常用的小技巧</title>
      <link>https://jokeme.top/articles/2020/06/10/1591792331001.html</link>
      <description><![CDATA[<h1>Linux 常用的小技巧</h1>
<h3>1 .apt-get remove vsftpd --purge</h3>
<p>删除所有配置，下次安装的时候会重新生成配置文件</p>
<h3>2 .编辑器 nano 快捷键</h3>
<p><code>ALT+Shift+3</code>	显示行号<br>
<code>CTRL+SHIFT+_</code>	快速跳到某行</p>
<h3>3 .如果不经常使用 Linux の桌面，但是又不希望桌面吃内存，可以试试看</h3>
<pre><code>sudo init 3
</code></pre>
<h3>4 .echo 颜色输出</h3>
<p><strong>echo -e "\033[背景颜色；文字颜色 m 字符串\033[0m"</strong></p>
<p>可以选择的编码如下所示(这些颜色是 ANSI 标准颜色)：<br>
40 　 设置黑色背景<br>
41 　 设置红色背景<br>
42 　 设置绿色背景<br>
43 　 设置黄色背景<br>
44 　 设置蓝色背景<br>
45 　 设置紫色背景<br>
46 　 设置青色背景<br>
47 　 设置白色(灰色)背景<br>
49 　 设置缺省黑色背景</p>
<p>前景颜色是背景颜色减去 10</p>
<h3>5 .zsh 美化</h3>
<p>在 GitHub 上有一个 <a href="https://github.com/ohmyzsh/ohmyzsh" target="_blank">oh-my-zsh</a> の项目，相信我，用上这个 zsh 以后，你会离不开它的，安装脚本附上</p>
<pre><code class="language-shell">sh -c "$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)"
sh -c "$(wget -O- https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)"
</code></pre>]]></description>
      <author>JokerLee</author>
      <guid>https://jokeme.top/articles/2020/06/10/1591792331001.html</guid>
      <category>Linux</category>
      <pubDate>Tue, 14 Jul 2020 05:12:28 +0800</pubDate>
    </item>
    <item>
      <title>两小时 Git 入门</title>
      <link>https://jokeme.top/articles/2020/07/14/1594662739208.html</link>
      <description><![CDATA[<h1>两小时 Git 入门</h1>
<h2>1.建立 Git 仓库</h2>
<pre><code>$ git init
</code></pre>
<h2>2.把文件添加到仓库</h2>
<pre><code>$ git add + filename
</code></pre>
<h2>3.把文件提交到仓库</h2>
<pre><code>$ git commit -m "wrote a readme file"
</code></pre>
<h2>4.查看提交结果/对比工作区和文件和仓库文件的不同之处</h2>
<pre><code>$ git status
</code></pre>
<h2>5.比对并列出文件和仓库文件的不同之处</h2>
<pre><code>$ git diff

#如果git status告诉你有文件被修改过，用git diff可以查看修改内容。
</code></pre>
<h2>6.Git 查看历史记录</h2>
<pre><code>$ git log/git log --pretty=oneline(查看精简版)
</code></pre>
<h2>7.退回曾经的某个版本</h2>
<h3>7.1 退回最新版</h3>
<pre><code>$ git reset --hard + (对应的append GPL的commit id)

$ git reset --hard HEAD^
</code></pre>
<p>用 HEAD 表示当前版本，上一个版本就是 HEAD^，上上一个版本就是 HEAD^^，当然往上 100 个版本写 100 个 ^ 比较容易数不过来，所以写成 HEAD~100</p>
<h3>7.2 查找所有版本 append GPL 的 commit id</h3>
<pre><code>$ git reflog
</code></pre>
<h3>7.3 Git 原理：</h3>
<p>1.工作区（Working Directory）就是 Git 创建仓库所在的目录</p>
<p>2 版本库（Repository）工作区有一个隐藏目录。Git，这个不是工作区，而是 Git 的版本库 Git 的版本库里存了很多东西，其中最重要的就是称为 stage（或者叫 index）的暂存区，还有 Git 为我们自动创建的第一个分支 master，以及指向 master 的一个指针叫 HEADgit add 实际上就是把文件修改添加到暂存区 Git commit 实际上就是把暂存区的所有内容提交到当前分支我们创建 Git 版本库时，Git 自动为我们创建了唯一一个 master 分支，所以，现在，Git commit 就是往 master 分支上提交更改</p>
<h2>8.查看工作区和版本库里面最新版本的区别</h2>
<pre><code>$ git diff HEAD -- +文件名
</code></pre>
<h2>9.放弃对文件的更改</h2>
<h3>9.1 放弃对"工作区"文件的更改</h3>
<pre><code>$ git checkout -- 文件名

$ git checkout -- file
</code></pre>
<p>命令中的--很重要，没有--，就变成了“切换到另一个分支”的命令</p>
<h2>9.2 放弃对"暂存区"文件的更改</h2>
<pre><code>$ git reset HEAD + 文件名
</code></pre>
<p>场景 1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令 Git checkout -- file。</p>
<p>场景 2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令 Git reset HEAD ，就回到了场景 1，第二步按场景 1 操作。</p>
<p>场景 3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考版本回退 &lt;number 7&gt;，不过前提是没有推送到远程库。</p>
<p>命令 Git rm 用于删除一个文件。如果一个文件已经被提交到版本库，那么你永远不用担心误删，但是要小心，你只能恢复文件到最新版本，你会丢失最近一次提交后你修改的内容</p>
<h2>10.创建 GitHub 远程仓库</h2>
<p>第 1 步：创建 SSH Key。在用户主目录下，看看有没有。SSH 目录，如果有，再看看这个目录下有没有 id_rsa,id_rsa.pub 这两个文件，如果已经有了，可直接跳到下一步。如果没有，打开 Shell（Windows 下打开 Git Bash），创建 SSH Key</p>
<pre><code>$ ssh-keygen -t rsa -C"youremail@example.com"
</code></pre>
<p>第 2 步：登陆 GitHub，打开“Account settings”，“SSH Keys”页面，然后，点“Add SSH Key”，填上任意 Title，在 Key 文本框里粘贴 id_rsa.pub 文件的内容</p>
<p>第 3 步： 登陆 GitHub，在右上角找到“Create a new repo”按钮，创建一个新的仓库，在 Repository name 填入仓库名，其他保持默认设置，点击“Create repository”按钮，就成功地创建了一个新的 Git 仓库</p>
<p>第 4 步： 在本地 shell 上 对 GitHub 上的仓库绑定： Git remote add frelon <a href="mailto:git@github.com" target="_blank">git@github.com</a>:lixuanliming/frelon.git 这里的 frelon 是远程仓库的名字，后面是 GitHub 给的 URL11.推送更新到 GitHub 仓库上</p>
<pre><code>$ git push -u 仓库名 master
</code></pre>
<p>#由于远程库是空的，我们第一次推送 master 分支时，加上了-u 参数，Git 不但会把本地的 master 分支内容推送的远程新的 master 分支，还会把本地的 master 分支和远程的 master 分支关联起来，在以后推送或者拉取时就不用加 -u 参数</p>
<pre><code>$ git push 仓库名 master
</code></pre>
<h2>11. 关于远程仓库</h2>
<p>从远程仓库克隆 如果自己需要新建一个项目，且从零开发，那么最好的方式是先创建远程库，然后，在 shell 里从远程库克隆</p>
<p>建仓库过程省略，在建立仓库的时候我们可以勾选 Initialize this repository with a README，这样 GitHub 会自动为我们创建一个 README.md 文件。创建完毕后，可以看到 README.md 文件</p>
<h2>12. Clone 远程仓库</h2>
<pre><code>git clone git@github.com:lixuanliming/frelon.git
</code></pre>
<h2>13.Git 分支</h2>
<h3>13.1 创建 Git 分支</h3>
<pre><code>$ git checkout -b bayu git checkout -b bayu
</code></pre>
<p>-b 表示 branch 相当于下面两条命令 Git branch bayu 建立'bayu'分支 Git check bayu 切换到'bayu'分支</p>
<h3>13.2 查看分支</h3>
<pre><code>$ git branch
</code></pre>
<p>当前分支前面会标一个*号</p>
<h3>13.3 合并分支到当前分支</h3>
<h4>13.3.1 Fast 合并分支</h4>
<pre><code>$ git merge frelon
</code></pre>
<p>注意提示的 Fast-forward 信息，Git 告诉我们，这次合并是“快进模式”，也就是直接把 master 指向 dev 的当前提交，所以合并速度非常快。当然，也不是每次合并都能 Fast-forward</p>
<h4>13.3.2 常规合并分支</h4>
<pre><code>$ git merge --no-ff -m "merge with no-ff" frelon
</code></pre>
<p>合并分支时，加上--no-ff 参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而 fast forward 合并就看不出来曾经做过合并。</p>
<h3>13.4 删除多余分支</h3>
<pre><code>$ git branch -d bayu
</code></pre>
<h3>13.5 丢弃未合并的分支</h3>
<pre><code>$ git branch -D fork1
</code></pre>
<p>假设 fork1 是未合并的分支，那么用 13.4 中的删除方法并不可行，只能用 -D 强制删除查看分支： <code>git branch</code> 创建分支： <code>git branch</code> 切换分支： <code>git checkout</code> 创建 + 切换分支： <code>git checkout -b</code> 合并某分支到当前分支： <code>git merge</code> 删除分支： <code>git branch -d</code></p>
<h2>14. Git 冲突解决</h2>
<p>Git 合并时遇到的冲突问题 当 Git 无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。解决冲突就是把 Git 合并失败的文件手动编辑为我们希望的内容，再提交。用 <code>git log --graph</code> 命令可以看到分支合并图。</p>
<h3>14.1 查看分支合并图</h3>
<pre><code>$ git log --graph
</code></pre>
<p>15.git 解决 bug 分支的问题 修复 bug 时，我们会通过创建新的 bug 分支进行修复，然后合并，最后删除。当手头工作没有完成时，先把工作现场 <code>git stash</code> 一下，然后去修复 bug，修复后，再 <code>git stash pop</code> ，回到工作现场。</p>
<ul>
<li>把工作区的文件暂时隐藏起来</li>
</ul>
<pre><code>$ git stash
</code></pre>
<ul>
<li>切换到 master 分支下面</li>
</ul>
<pre><code>$ git checkout master
</code></pre>
<ul>
<li>建立 issue-101 的修复 bug 的分支 "并进入该分支修复 bug"</li>
</ul>
<pre><code>$ git checkout -b issue-101
</code></pre>
<ul>
<li>把文件提交到暂存区</li>
</ul>
<pre><code>$ git add xxx.py

$ git commit -m "fix bug 101" 提交文件到仓库
</code></pre>
<ul>
<li>回到原分支</li>
</ul>
<pre><code>$ git checkout master
</code></pre>
<ul>
<li>删除 issue-101 分支</li>
</ul>
<pre><code>$ git merge --no-ff -m "merged bug fix 101" issue-101
</code></pre>
<ul>
<li>返回原分区</li>
</ul>
<pre><code>$ git checkout dev
</code></pre>
<ul>
<li>还原工作区</li>
</ul>
<pre><code>$ git status
</code></pre>
<ul>
<li>继续工作</li>
</ul>
<pre><code>$ git stash pop
</code></pre>
<h2>16 Git 的多人协作</h2>
<h3>16.1 查看远程仓库的信息</h3>
<pre><code>$ git remote -v(显示详细信息)
</code></pre>
<h3>16.2 推送分支到远程仓库</h3>
<pre><code>$ git push origin master 这是推送主分支(origin是远程仓库的名字)

$ git push origin dev 还可以推送别的副分支(origin是远程仓库的名字)
</code></pre>
<h3>16.3 抓取分支 从本地推送分支</h3>
<p>使用 <code>git push origin branch-name</code> ，如果推送失败，先用 <code>git pull</code>  抓取远程的新提交； 在本地创建和远程分支对应的分支，使用 <code>git checkout -b branch-name origin/branch-name</code> ，本地和远程分支的名称最好一致； 建立本地分支和远程分支的关联，使用 <code>git branch --set-upstream branch-name origin/branch-name</code> ； 从远程抓取分支，使用 Git pull，如果有冲突，要先处理冲突。</p>
<h2>17 Git 标签管理</h2>
<h3>17.1 Git 创建标签</h3>
<pre><code>$ git tag tag_Name
</code></pre>
<h3>17.2 对 Git 已经 commit 过的历史文件打标签</h3>
<pre><code>$ git log --pretty=oneline --abbrev-commit 查看log中所记录的commit id
</code></pre>
<pre><code>$ git tag v0.9 f52c633 
#对commit id为 f52c633 的文件打上标签为 v0.9
#还可以创建带有说明的标签，
#用-a指定标签名，-m指定说明文字
#如下实例:

$ git tag -a v0.1 -m "blabla" 1094ad
</code></pre>
<h3>17.3 查看标签信息</h3>
<pre><code>$ git tag 查看所有 tag信息
$ git show &lt;tagname&gt; 查看指定tag信息
</code></pre>
<h3>17.4 推送标签到远程</h3>
<pre><code>$ git push frelon v1.0 给某个仓库打标签
$ git push frelon --tags 一次性推送全部尚未推送到远程的本地标签,前提是本地都打了标签
</code></pre>
<h3>17.5 删除标签</h3>
<pre><code>$ git tag -d v0.1
</code></pre>
<p>这适用于尚为推送到远程仓库使用如果标签已经推送到远程，要删除远程标签就麻烦一点，先从本地删除：</p>
<pre><code>$ git tag -d v0.9 $ git push frelon :refs/tags/v0.9
</code></pre>
<p>命令 <code>git push origin</code> 可以推送一个本地标签；</p>
<p>命令 <code>git push origin --tags</code> 可以推送全部未推送过的本地标签；</p>
<p>命令 <code>git tag -d</code> 可以删除一个本地标签；</p>
<p>命令 <code>git push origin :refs/tags/</code> 可以删除一个远程标签。</p>
<h3>本文参考 <a href="https://www.liaoxuefeng.com/wiki/896043488029600" target="_blank">廖雪峰的官方网站/Git教程</a></h3>
<p>曾经在微信公众上也发过，但是因为公众号维护起来比较麻烦就拖到这里来了，文章写的匆忙，如有错误欢迎评论区指导/纠正</p>]]></description>
      <author>JokerLee</author>
      <guid>https://jokeme.top/articles/2020/07/14/1594662739208.html</guid>
      <category>Git</category>
      <category>GitHub</category>
      <pubDate>Tue, 14 Jul 2020 04:52:13 +0800</pubDate>
    </item>
    <item>
      <title>Python 报错集锦</title>
      <link>https://jokeme.top/articles/2020/07/03/1593768976855.html</link>
      <description><![CDATA[<ol>
<li>
<h2>UnicodeEncodeError: 'ascii' codec can't encode characters in position ... ...</h2>
</li>
</ol>
<p>解决方案：<br>
linux 下执行 <code>export LANG=en_US.UTF-8</code><br>
不要使用网上那些导入 <code>sys</code>,在reload什么的,都没有用</p>]]></description>
      <author>JokerLee</author>
      <guid>https://jokeme.top/articles/2020/07/03/1593768976855.html</guid>
      <category>python</category>
      <pubDate>Fri, 03 Jul 2020 17:36:16 +0800</pubDate>
    </item>
    <item>
      <title>利用Python爬虫获取bing.com每天的高清壁纸</title>
      <link>https://jokeme.top/articles/2020/06/14/1592141097046.html</link>
      <description><![CDATA[<h1>利用 Python 爬虫获取 bing.com 每天的高清壁纸</h1>
<p>众所周知，必应是主力做壁纸の搜索引擎！</p>
<p>每天都更新搜索页面的背景图片，这些图片也的的确确很好看，那我们要是 ❤️心动了，想保存欣赏欣赏怎么办呐？</p>
<h2>方法一：直接开发者模式拿图片</h2>
<p>这个方法应该是最简单的了， <code>ctrl+ shift+i</code></p>
<pre><code class="language-html">... ...
&lt;tbody&gt;
  &lt;tr&gt;
    &lt;td id="hp_cellCenter" ... ...&gt;
      &lt;div id="hp_container" ... ...&gt;
        &lt;div id="bgDiv" ... ...&gt;
          &lt;div id="bgImgProgLoad" data-ultra-definition-src="/th?id=OHR.WildflowersBC_EN-CN3359054435_UHD.jpg&amp;rf=LaDigue_UHD.jpg&amp;pid=hp&amp;w=1920&amp;h=1080&amp;rs=1&amp;c=4" data-explicit-bing-load="false" data-dynamic-size="true"&gt;
            &lt;/div&gt;
... ...		
</code></pre>
<p>这个链接 ?就在 <code>&lt;div id="bgImgProgLoad"</code> の标签里面，复制 <code>data-ultra-definition-src</code> 所对应的值，再在前面补上 <code>cn.bing.com</code> 就可以啦</p>
<p>不过这种方法下载的图片是被压缩以后的图片，大小也就几百 kb,而如果我们想要下载原图的话，就需要把链接 ?里面第一个 <code>.jpg</code> 后面的字符全给干掉，最终的的 <strong>URL</strong> 应该是： <code>https://cn.bing.com/th?id=OHR.WildflowersBC_EN-CN3359054435_UHD.jpg</code></p>
<h2>方法二：python 爬虫</h2>
<p>没有什么好说の,都是最简单的 python 命令，</p>
<p>运行环境： <code>Linux</code></p>
<p>Python 版本： <code>Python3</code></p>
<p>pip 依赖库： <code>requests,lxml</code></p>
<p>基本上大部分的 <strong>Linux</strong> 都会预装 <strong>Python3</strong> ,所以就从安装 <strong>pip</strong> 开始了</p>
<pre><code class="language-shell">sudo apt install python3-pip
pip3 install lxml
pip3 install requests
mkdir -p ~/Bing_pic/pic/
cd Bing_pic
nano xxx.py					#名字就根据你自己的喜好来吧,把下面的代码粘进去就可以啦
python3 xxx.py				#如果没有报错,大功告成啦
ls pic/						#看一下下载的壁纸
</code></pre>
<pre><code class="language-python">#coding=utf-8
import requests
from lxml import etree
import os
webPage = requests.get(url = "https://cn.bing.com/?FORM=BEHPTB&amp;ensearch=1",
        headers={"User-Agent":"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/79.0.3945.88 Safari/537.36"}
        )
we = webPage.text
ssr = etree.HTML(we)
Links = ssr.xpath("//div/div[@id='bgDiv']/div/@data-ultra-definition-src")
Desc=ssr.xpath("//a/div/h2/text()")

Str="https://cn.bing.com"
desc=""
re = []
for sein in Desc:
        desc=sein
print(desc)

for  se  in Links:
        Str = Str+se
        re = Str.split("&amp;",1)
        Str=re[0]
print(Str)

picfile="/home/jokeme/pic/"+desc+".jpg"
#这里需要根据实际情况修改

picture=requests.get(Str)
with open (picfile,"wb+") as f:
        f.write(picture.content)
print("Get The Picture of Bing Successfully! "+"The Picture in \""+picfile+"\"")
</code></pre>
<p>如果你想每天都自动执行这段代码的话，就可以用 <code>crontab</code> 来定时执行</p>
<pre><code class="language-shell">crontab -e
30 0 * * * python3 ~/Bing_pic/Bing_spider.py &gt;&gt; ~/Bing_pic/Bing_spider_log.txt
</code></pre>
<p>这样的话，每天凌晨 12:30 就会自动执行该命令啦</p>
<p>使用须知：这个脚本爬取的是 <strong>Bing</strong> 国际版的图片，所以当天中午 15:00 以后爬取的图片和第二天中午 15:00 之前爬取的图片一致，也就是第一天会出现这种情况，以后都没有问题的</p>]]></description>
      <author>JokerLee</author>
      <guid>https://jokeme.top/articles/2020/06/14/1592141097046.html</guid>
      <category>Linux</category>
      <category>python</category>
      <pubDate>Sun, 21 Jun 2020 02:08:17 +0800</pubDate>
    </item>
    <item>
      <title>CentOS编译安装Nano</title>
      <link>https://jokeme.top/articles/2020/06/10/1591793250425.html</link>
      <description><![CDATA[<h1>CentOS编译安装Nano</h1>
<p>众所周知,因为 <strong>CentOS</strong> 非常的稳定,所以导致 <strong>CentOS</strong> の <strong>YUM</strong> 源里面的软件非常的老旧<br>
就拿 <strong>Nano</strong> 来说, 官方已经到了 4.0版本, 而 <strong>CentOS</strong> 这边还在2.0徘徊,这就非常的难受了.所以咱就手动编译安装!</p>
<h2>1. 安装准备</h2>
<pre><code>sudo su
cd
yum -y install gcc ncurses-devel wget
wget https://www.nano-editor.org/dist/v4/nano-4.6.tar.gz
tar zxvf nano-4.6.tar.gz
cd nano-4.6
</code></pre>
<h2>2. 准备编译</h2>
<pre><code>./configure
make &amp;&amp; make install
</code></pre>
<h2>3. 复制文件</h2>
<pre><code>cp src/nano  /usr/bin
cp doc/sample.nanorc  /root/.nanorc
</code></pre>
<p>常用插件也给安排上</p>
<pre><code>echo  'include "/usr/local/share/nano/*.nanorc"'  &gt;&gt;  /root/.nanorc
#用于高亮显示

echo  'set nowrap'  &gt;&gt;  /root/.nanorc
#关闭自动换行

echo  'set linenumbers'  &gt;&gt;  /root/.nanorc
#打开行号显示
</code></pre>
<p>本文参考: <a href="https://hiwbb.com/2019/12/centos-install-nano-46-syntax/" target="_blank">Hiwbb.com</a></p>]]></description>
      <author>JokerLee</author>
      <guid>https://jokeme.top/articles/2020/06/10/1591793250425.html</guid>
      <category>Linux</category>
      <pubDate>Wed, 10 Jun 2020 20:47:30 +0800</pubDate>
    </item>
    <item>
      <title>Frp 内网穿透</title>
      <link>https://jokeme.top/articles/2020/06/08/1591555886634.html</link>
      <description><![CDATA[<h1>Frp 内网穿透</h1>
<p>自打搞一个软路由，我就玩的可带劲了，什么 <strong>Linux , Docker , Java</strong> 各种技术都被逼提升了很多。 闲话不多说，直接说重点了</p>
<h2>1. 准备工作：</h2>
<ul>
<li>frp-server &amp; frp-client 可以在 <a href="https://github.com/fatedier/frp/releases" target="_blank">GitHub</a> 里下载</li>
<li>域名(需要备案)</li>
<li>有公网 IP の服务器一台</li>
</ul>
<h2>2. 配置 server 端</h2>
<p>我是用的是 amd64 架构的，如果和我一样的话可以按我的命令来</p>
<pre><code class="language-shell">wget https://github.com/fatedier/frp/releases/download/v0.33.0/frp_0.33.0_linux_amd64.tar.gz
tar -zxvf frp_0.33.0_linux_amd64.tar.gz
mv frp_0.33.0_linux_amd64.tar.gz frp #为了接下来方便一点
cd frp
rm frpc* #删除不必要的配置,也可以不删
nano frps.ini
</code></pre>
<pre><code class="language-ini">[common]
bind_port = 7000 
#对外提供服务的端口

dashboard_port = 7500
#访问控制板的端口

token = 123456
#token,相对于一个简单的验证

vhost_http_port = 80
#http服务在服务器的代理端口
</code></pre>
<p>可以根据自己的喜好设定这些配置</p>
<h2>3. 配置 client 端</h2>
<pre><code class="language-shell">wget https://github.com/fatedier/frp/releases/download/v0.33.0/frp_0.33.0_linux_amd64.tar.gz
tar -zxvf frp_0.33.0_linux_amd64.tar.gz
mv frp_0.33.0_linux_amd64.tar.gz frp #为了接下来方便一点
cd frp
rm frps* #删除不必要的配置,也可以不删
nano frpc.ini
</code></pre>
<h3>3.1 单网站配置(非必选)</h3>
<pre><code class="language-ini">[common]
server_addr = yourdomain.com
#你的域名/填写IP地址也可以 &lt;记得把你的域名解析到服务器的IP地址上&gt;

server_port = 7000
#需要和上面的server配置相同

token = 123456
#需要和上面的server配置相同

[http]
type = http
local_port = 80
custom_domains = yourdomain.com
</code></pre>
<h3>3.2 多网站配置(非必选)</h3>
<p>如果你有多个 Web 项目的话，哪就建议你用二级域名</p>
<pre><code class="language-ini">[common]
server_addr = yourdomain.com
server_port = 7000
token = 123456

[web1]
type = http
local_port = 80
custom_domains = a.yourdomain.com

[web2]
type = http
local_port = 8080
custom_domains = b.yourdomain.com

[web3]
type = http
local_port = 8088
custom_domains = c.yourdomain.com
</code></pre>
<h3>3.3 SSH 配置(非必选)</h3>
<pre><code class="language-ini">[ssh]
type = tcp
#ssh服务请使用tcp连接

local_ip = 127.0.0.1
local_port = 22
remote_port = 11484
#需要打开服务器端的该端口の防火墙
</code></pre>
<h2>4. 浏览器验证</h2>
<p>浏览器输入 <code>http://yourdomain.com</code> 理论上就可以打开你在 client 上的 Web 项目了</p>
<p>如果你遇到了</p>
<p><strong>Chrome 浏览器打不开网页！</strong></p>
<p><strong>IE 浏览器也打不开网页</strong></p>
<p>别急！ ! 换<strong>Firefox</strong>浏览器试一下  / |&amp;&amp;| \ 使用<strong>Chrome</strong>的无痕模式打开试一下</p>]]></description>
      <author>JokerLee</author>
      <guid>https://jokeme.top/articles/2020/06/08/1591555886634.html</guid>
      <category>Linux</category>
      <category>Frp</category>
      <pubDate>Mon, 08 Jun 2020 03:02:29 +0800</pubDate>
    </item>
    <item>
      <title>SpringBoot学习笔记(1)</title>
      <link>https://jokeme.top/articles/2020/05/29/1590754071333.html</link>
      <description><![CDATA[<h1>Spring学习</h1>
<p>提醒⏰:在开始之前,我们需要配置以下基本环境(还有文件的编码方式也要注意)</p>
<ol>
<li>
<p>File &gt;&gt;&gt; Project Structcture(CTRL+ALT+Shift+S) &gt;&gt;&gt; Project &gt;&gt;&gt; Project SDK:</p>
</li>
<li>
<p>File &gt;&gt;&gt; Project Structcture(CTRL+ALT+Shift+S) &gt;&gt;&gt; Project &gt;&gt;&gt; Project language level</p>
</li>
<li>
<p>File &gt;&gt;&gt; Project Structcture(CTRL+ALT+Shift+S) &gt;&gt;&gt; Modules &gt;&gt;&gt; Sources &gt;&gt;&gt; Languages level</p>
</li>
<li>
<p>File &gt;&gt;&gt; Settings(CTRL+ALT+S) &gt;&gt;&gt; Build,Execution,Deployment &gt;&gt;&gt; Compiler &gt;&gt;&gt; Java Compiler &gt;&gt;&gt; Project bytecode version</p>
</li>
<li>
<p>File &gt;&gt;&gt; Settings(CTRL+ALT+S) &gt;&gt;&gt; Build,Execution,Deployment &gt;&gt;&gt; Compiler &gt;&gt;&gt; Java Compiler &gt;&gt;&gt;Per-module bytecode version</p>
</li>
</ol>
<h2>1. 配置文件 &lt;pom.xml&gt;</h2>
<pre><code class="language-xml">&lt;properties&gt;
  &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
  &lt;java.version&gt;1.8&lt;/java.version&gt;
&lt;/properties&gt;
&lt;!-- 首先配置一下基本的文件编码和Java版本 --&gt;

&lt;dependencies&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
            &lt;version&gt;2.2.2.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;
&lt;!-- 提供一些 mvc，aop 的依赖包，这是玩Spring-boot必备的依赖包 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
            &lt;version&gt;2.2.2.RELEASE&lt;/version&gt;
            &lt;type&gt;pom&lt;/type&gt;
        &lt;/dependency&gt;
&lt;!--  这个依赖是帮助我们自动选择一些依赖最合适的版本，这个是玩Spring-Boot必备的 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
            &lt;version&gt;2.1.7.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;
&lt;!--该插件是将Springboot项目打包为可执行的jar包 --&gt;
&lt;/dependencies&gt;
</code></pre>
<p><strong>spring-boot-starter-parent</strong> 是版本仲裁者,所以我们在导入依赖时,可以省略一些依赖的版本号</p>
<p><strong>spring-boot-starter-web</strong> web 模块的场景启动器组件,还有别的一些 <strong>starter</strong> 都是被 <strong>Sprint boot</strong> 抽取出来的,以后在项目里只需导入这些启动器就可以开箱即用</p>
<h2>2. 建立Controller &amp; Starter</h2>
<pre><code class="language-java">package top.jokeme;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class Starter {
    public static void main(String[] args) {
        SpringApplication.run(Starter.class,args);
    }
}
#~~~~~~~~~~~~~~~~
package top.jokeme;

import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class Controller {
    @RequestMapping("/word")
    public String restr(){
        return "&lt;p style='color:red;text-align:center'&gt;Awesome Java&lt;/p&gt;";
    }
}
</code></pre>
<p>这就是一个最简单的 <strong>SpringBoot</strong> 应用程序</p>
<pre><code class="language-java">package top.jokeme;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@ComponentScan("top.jokeme.ayibe")
@SpringBootApplication
public class Starter {
    public static void main(String[] args) {
        SpringApplication.run(Starter.class,args);
    }
}
</code></pre>
<p><strong>@SpringBootApplication</strong> 该注解就标识着 <strong>Springboot</strong> 的主配置类,启动类,从这里的 <strong>main</strong> 方法开始执行</p>
<pre><code class="language-java">@Target({ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@SpringBootConfiguration
@EnableAutoConfiguration
@ComponentScan(
    excludeFilters = {@Filter(
    type = FilterType.CUSTOM,
    classes = {TypeExcludeFilter.class}
), @Filter(
    type = FilterType.CUSTOM,
    classes = {AutoConfigurationExcludeFilter.class}
)}
)
public @interface SpringBootApplication {
    ......
}
</code></pre>
<p>注: <strong>@import</strong> 是 <strong>SpringBoot</strong> の底层注解.其作用就是给容器导入组件</p>
<h3>2.1 需要注意两个比较重要的注解</h3>
<h4>2.1.1 Registrar.class</h4>
<pre><code>@SpringBootApplication 中的 
@EnableAutoConfiguration 中的 
@AutoConfigurationPackage 中的
@Import({Registrar.class})
</code></pre>
<p>其中 Registrar.clss就是</p>
<pre><code class="language-java">static class Registrar implements ImportBeanDefinitionRegistrar, DeterminableImports {
        Registrar() {
        }

        public void registerBeanDefinitions(AnnotationMetadata metadata, BeanDefinitionRegistry registry) {
            AutoConfigurationPackages.register(registry, (new AutoConfigurationPackages.PackageImport(metadata)).getPackageName());
        }
//这个方法就是将标记了@SpringBootApplication的类,及其子包的所有组件扫描到Spring容器里面去
    
        public Set&lt;Object&gt; determineImports(AnnotationMetadata metadata) {
            return Collections.singleton(new AutoConfigurationPackages.PackageImport(metadata));
        }
</code></pre>
<h4>2.1.2 AutoConfigurationImportSelector</h4>
<pre><code>@SpringBootApplication 中的 
@EnableAutoConfiguration 中的 
@Import({AutoConfigurationImportSelector.class})
</code></pre>
<p><strong>AutoConfigurationImportSelector</strong> 就是导入哪些组件的选择器,并且会将需要导入的组件以全类名の方式返回,然后这些组件就会被添加到容器之中;</p>
<p>在这个过程中,会导入非常多的自动配置类诸如 [ xxxAutoConfiguration ] 等,目的就是给容器导入这些场景所需的所有组件,并自动配置好</p>
<p>上 <strong>AutoConfigurationImportSelector</strong> 代码片段:</p>
<pre><code class="language-java">    public String[] selectImports(AnnotationMetadata annotationMetadata) {
        if (!this.isEnabled(annotationMetadata)) {
            return NO_IMPORTS;
        } else {
            AutoConfigurationMetadata autoConfigurationMetadata = AutoConfigurationMetadataLoader.loadMetadata(this.beanClassLoader);
            AutoConfigurationImportSelector.AutoConfigurationEntry autoConfigurationEntry = this.getAutoConfigurationEntry(autoConfigurationMetadata, annotationMetadata);
            return StringUtils.toStringArray(autoConfigurationEntry.getConfigurations());
        }
    }
    protected AutoConfigurationImportSelector.AutoConfigurationEntry getAutoConfigurationEntry(AutoConfigurationMetadata autoConfigurationMetadata, AnnotationMetadata annotationMetadata) {
        if (!this.isEnabled(annotationMetadata)) {
            return EMPTY_ENTRY;
        } else {
            AnnotationAttributes attributes = this.getAttributes(annotationMetadata);
            List&lt;String&gt; configurations = this.getCandidateConfigurations(annotationMetadata, attributes);
            configurations = this.removeDuplicates(configurations);
            Set&lt;String&gt; exclusions = this.getExclusions(annotationMetadata, attributes);
            this.checkExcludedClasses(configurations, exclusions);
            configurations.removeAll(exclusions);
            configurations = this.filter(configurations, autoConfigurationMetadata);
            this.fireAutoConfigurationImportEvents(configurations, exclusions);
            return new AutoConfigurationImportSelector.AutoConfigurationEntry(configurations, exclusions);
        }
    }
</code></pre>
<pre><code class="language-java">    protected List&lt;String&gt; getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes) {
        List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(this.getSpringFactoriesLoaderFactoryClass(), this.getBeanClassLoader());
        Assert.notEmpty(configurations, "No auto configuration classes found in META-INF/spring.factories. If you are using a custom packaging, make sure that file is correct.");
        return configurations;
    }
</code></pre>
<p>然后就用到了 <strong>SpringFactoriesLoader.loadFactoryNames</strong></p>
<pre><code class="language-java">    public static List&lt;String&gt; loadFactoryNames(Class&lt;?&gt; factoryType, @Nullable ClassLoader classLoader) {
        String factoryTypeName = factoryType.getName();
        return (List)loadSpringFactories(classLoader).getOrDefault(factoryTypeName, Collections.emptyList());
    }
    private static Map&lt;String, List&lt;String&gt;&gt; loadSpringFactories(@Nullable ClassLoader classLoader) {
        MultiValueMap&lt;String, String&gt; result = (MultiValueMap)cache.get(classLoader);
        if (result != null) {
            return result;
        } else {
            try {
                Enumeration&lt;URL&gt; urls = classLoader != null ? classLoader.getResources("META-INF/spring.factories") : ClassLoader.getSystemResources("META-INF/spring.factories");
                LinkedMultiValueMap result = new LinkedMultiValueMap();

                while(urls.hasMoreElements()) {
                    URL url = (URL)urls.nextElement();
                    UrlResource resource = new UrlResource(url);
                    Properties properties = PropertiesLoaderUtils.loadProperties(resource);
                    Iterator var6 = properties.entrySet().iterator();

                    while(var6.hasNext()) {
                        Entry&lt;?, ?&gt; entry = (Entry)var6.next();
                        String factoryTypeName = ((String)entry.getKey()).trim();
                        String[] var9 = StringUtils.commaDelimitedListToStringArray((String)entry.getValue());
                        int var10 = var9.length;

                        for(int var11 = 0; var11 &lt; var10; ++var11) {
                            String factoryImplementationName = var9[var11];
                            result.add(factoryTypeName, factoryImplementationName.trim());
                        }
                    }
                }

                cache.put(classLoader, result);
                return result;
            } catch (IOException var13) {
                throw new IllegalArgumentException("Unable to load factories from location [META-INF/spring.factories]", var13);
            }
        }
    }
</code></pre>
<p><strong>SpringBoot</strong> 在启动的时候,主要就是从类路径下的 <strong>META-INF/factories</strong> 里获取  <strong>EnableAutoConfiguration</strong> 指定的值,并将这些值作为自动配置类导入容器中,然后自动配置类生效,帮我们实现自动配置的工作</p>
<p>这些都归功于:</p>
<p><strong>spring-boot-autoconfigure-2.2.2.RELEASE.jar</strong></p>
<p>注:</p>
<pre><code class="language-properties">Part 2.1的一些内容可能与 Part 3 的内容有冲突,以 Part 3 为准,Part 2.1有点老
</code></pre>
<h2>3. 自动配置原理</h2>
<p><strong>application.properties</strong> 配置文件里面都可以配置什么内容?</p>
<p>SpringBoot在启动的时候会加载主配置类,这个主配置类就是我们添加了注解 [ <strong>@SpringBootApplication</strong> ]的类</p>
<p>并且为这个类开启了自动配置功能 (继承至注解:<strong>@SpringBootApplication</strong> の注解 <strong>@EnableAutoConfiguration</strong>)</p>
<p><em>小技巧 :在使用Idea的时候,我们想要看导入的一些第三方代码的源码可以按 ALT+CTRL+鼠标点击你要看源码的 类/接口/注解...</em></p>
<pre><code class="language-java">package org.springframework.boot.autoconfigure;

import ......;

@Target({ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@SpringBootConfiguration
@EnableAutoConfiguration
@ComponentScan(
    excludeFilters = {@Filter(
    type = FilterType.CUSTOM,
    classes = {TypeExcludeFilter.class}
), @Filter(
    type = FilterType.CUSTOM,
    classes = {AutoConfigurationExcludeFilter.class}
)}
)
public @interface SpringBootApplication {
......
}
</code></pre>
<h3>3.1 @EnableAutoConfigurationの作用:</h3>
<ul>
<li>
<p>使用 <strong>AutoConfigurationImportSelector</strong> 给容器导入相关组件</p>
</li>
<li>
<p>虽然没太看懂 <strong>selectImports</strong> 代码,但是我猜大概的意思是:</p>
</li>
<li>
<p>依赖 <strong>AutoConfigurationMetadataLoader</strong> 来导入 <strong>META-INF</strong> 下面的 <strong>properties</strong> 文件</p>
<p>详细解释可以看这个 <strong><a href="https://www.cnblogs.com/milicool/p/11718099.html" target="_blank">Other+</a></strong> 的文章</p>
</li>
</ul>
<pre><code class="language-java">public String[] selectImports(AnnotationMetadata annotationMetadata) {
        if (!this.isEnabled(annotationMetadata)) {
            return NO_IMPORTS;
        } else {
            AutoConfigurationMetadata autoConfigurationMetadata = AutoConfigurationMetadataLoader.loadMetadata(this.beanClassLoader);
            AutoConfigurationImportSelector.AutoConfigurationEntry autoConfigurationEntry = this.getAutoConfigurationEntry(autoConfigurationMetadata, annotationMetadata);
            return StringUtils.toStringArray(autoConfigurationEntry.getConfigurations());
        }
    
</code></pre>
<ul>
<li>所有可以在配置文件中配置的属性,都在xxxProperties类中</li>
</ul>
<p>由于**@SpringBootApplication** 有一个默认的<strong>ComponentScan</strong>注解指定了扫描包の方式,所以在我们需要DIY扫包方式的时候就需要用 <strong>@ComponentScan</strong> 来指定我们需要扫描的包</p>
<p>eg: <strong>@ComponentScan("top.jokeme.ayibe")</strong> 指定扫描 <strong>ayibe</strong> 这个包....如果指定以后就不会 使用默认的扫描方式,只会扫描指定の包</p>
<h2>4. YAML &amp; Properties</h2>
<h4>4.1. yaml基本语法:</h4>
<pre><code class="language-yaml">K: V
##############
K:
    V1: 443
    V2: sew
</code></pre>
<p>yaml是大小写敏感的,并且需要注意缩进和空格</p>
<p>注意:yaml里面</p>
<pre><code class="language-yaml">" " &amp; ' ' 作用不一样
</code></pre>
<p>" "会转义字符串,比如 \n 等</p>
<p>' ' 不会转义字符串,输入啥,输出啥</p>
<h4>4.2. yamlの 对象</h4>
<pre><code class="language-yaml">food:
    name: apple
    tasty: true
####################
food: {name: apple,tasty: true}
</code></pre>
<h4>4.3. yamlの数组</h4>
<pre><code class="language-yaml">interesting:
 - 13
 - 14
 - 15
#####################
interesting: [13,14,15]
</code></pre>
<h4>4.4. yaml文件 &amp; 数据绑定</h4>
<pre><code class="language-yaml">person:
  sname: zhangsan
  sage: 18
  Sod: 'AnHui Provience'
  Lovelydog: {age: 13,name: lisi}
</code></pre>
<pre><code class="language-java">package top.day2_yaml;

import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.stereotype.Component;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@Component
@ConfigurationProperties(prefix = "person")
public class Person {
}
</code></pre>
<p>如果不出意外:</p>
<pre><code class="language-java">#localhost:8080/se 
#会出现以下效果
Person{sname='zhangsan', sage=18, Sod='AnHui Provience', Lovelydog=dog{age=13, name='lisi'}}
</code></pre>
<p>注意1:<strong>@Component</strong> 注解是帮助绑定值的一个注解,所以不能忘记添加该注解</p>
<p>注意2:这里可能需要导入以下依赖</p>
<pre><code class="language-xml">&lt;dependency&gt;
  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
  &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt;
  &lt;version&gt;2.3.0.RELEASE&lt;/version&gt;
&lt;/dependency&gt;
&lt;!-- 配置文件处理模块,配置文件的数据绑定就依赖该模块 --&gt;
</code></pre>
<h4>4.5. Properties</h4>
<p><strong>properties</strong> の用法大致与 <strong>yaml</strong> 差不多,但是比 <strong>yaml</strong> 费事一点点</p>
<pre><code class="language-properties">person.sname=zhangsan
person.sage=18
person.Sod='AnHui Provience'
person.lovelydog.age=13
person.lovelydog.name=lisi
server.port=8088
</code></pre>
<p>∵ <strong>Properties</strong> 是大小写不敏感的</p>
<p>∴ <strong>person.age</strong> = <strong>person.Age</strong></p>
<h2>5. @Value</h2>
<h4>5.1 <strong>@Value</strong> 使用方法</h4>
<pre><code class="language-java">package top.day3_atValue;

import org.springframework.beans.factory.annotation.Value;

public class human {
    @Value("Person")
    String Typeof;
}
</code></pre>
<h4>5.2 <strong>@ConfigurationProperties &amp; @Value</strong> の区别</h4>
<table>
<thead>
<tr><th align="center"> </th><th align="center">@ConfigurationProperties</th><th align="center">@Value</th></tr>
</thead>
<tbody>
<tr><td align="center"><strong>特征</strong></td><td align="center"><strong>批量注入配置文件里的属性</strong></td><td align="center"><strong>一个个指定</strong></td></tr>
<tr><td align="center"><strong>松散语法</strong></td><td align="center"><strong>?YES</strong></td><td align="center"><strong>?NO</strong></td></tr>
<tr><td align="center"><strong>SpEL</strong></td><td align="center"><strong>?NO</strong></td><td align="center"><strong>?YES</strong></td></tr>
<tr><td align="center"><strong>JSR303</strong></td><td align="center"><strong>?YES</strong></td><td align="center"><strong>?NO</strong></td></tr>
<tr><td align="center"><strong>复杂类型封装</strong></td><td align="center"><strong>?YES</strong></td><td align="center"><strong>?NO</strong></td></tr>
</tbody>
</table>
<p>eg: 复杂类型封装就是指只, map/list/...</p>
<h4>5.3 我们在何时使用他们</h4>
<p>如果我们只是某项业务逻辑中需要获取某个属性,推荐使用</p>
<p>如果我们是需要进行大规模配置文件,就要使用 <strong>@ConfigurationProperties</strong></p>
<h2>6. @PropertySource &amp; @ImportResource</h2>
<h4>6.1 @PropertySource使用方法</h4>
<pre><code class="language-java">package top.day3_atValue;

import org.springframework.context.annotation.PropertySource;

@PropertySource(value={"classpath:per.properties"})
public class human {
    
}
</code></pre>
<p><em>@PropertySource 加载指定☞的配置文件</em></p>
<p><em>@ConfigurationProperties 默认获取全局の配置文件里的属性</em></p>
<p>⚠注意: <strong>@PropertySource</strong> 必须和 <strong>@ConfigurationProperties</strong> 一起使用才有效,单独使用没有效果</p>
<h4>6.2 @ImportResource使用方法</h4>
<p>其作用是导入 <strong>Spring</strong> 里面的配置文件并让其生效</p>
<pre><code class="language-java">@ImportResource(locations = {classpath:"abc.xml"})
</code></pre>
<h2>7. 配置文件占位符</h2>
<p>先来一个实例:</p>
<pre><code class="language-properties">person.sname=${random.uuid}
person.sage=${random.int}
person.Sod='AnHui Provience'
person.lovelydog.age=${person.lol:233}
person.lovelydog.name=lisi
server.port=8080
</code></pre>
<p>这就是用随机数 $random 来生成的,还有用占位符生成の</p>
<p><strong>${person.lol:233}</strong> の意思就是 有person.lol就用它,没有就用233</p>
<pre><code>Person{sname='d573e71a-f8b2-4a48-a688-10449b4b55fc', sage=-1817647899, Sod=''AnHui Provience'', Lovelydog=dog{age=233, name='lisi'}}
</code></pre>
<h2>8. Profile文件支持</h2>
<h4>8.1 多Profile文件</h4>
<h5>8.1.1 properties</h5>
<p>可以用多个带有 <strong>application-{env}.properties</strong> 来切换环境</p>
<p>注: 默认的profile是 <strong>application.properties</strong></p>
<p>如果需要切换生产环境,可以在 <strong>application.properties</strong>  里面配置</p>
<pre><code class="language-properties">spring.profiles.active=env
</code></pre>
<pre><code class="language-properties">dog2.SunDay=24
dog2.Example.k1=sim
dog2.Example.k2=sib
dog2.Friends={lisi,zhangsan}
dog2.soul.Weight=30
dog2.soul.Data=35
dog2.soul.Power=80
dog2.soul.Lovely=true
spring.profiles.active=ssr

person.sname=${random.uuid}
person.sage=${random.int}
person.Sod='AnHui Provience'
person.lovelydog.age=${person.lol:233}
person.lovelydog.name=lisi
server.port=8080
spring.profiles=ssr
</code></pre>
<h5>8.1.2 yaml</h5>
<p>如果配置文件是 <strong>yaml</strong> 我们还可以用更为简便の多文档块の方式</p>
<p>这里就涉及到了基本の yaml 语法 <strong>- - -</strong> 这种连续三个 <strong>-</strong> 就表示文本块,看操作:</p>
<pre><code class="language-yaml">person:
  sname: zhangsan
  sage: 18
  Sod: 'AnHui Provience'
  Lovelydog: {age: 13,name: lisi}
spring:
  profiles: 
    active: ssr
---
person:
  sname: ${random.uuid}
  sage: ${random.int}
  Sod: 'AnHui Provience'
  Lovelydog: {age: 13,name: lisi}
server.port: 8088
spring:
  profiles: ssr
</code></pre>
<h2>9 SpringBoot配置文件の加载顺序</h2>
<p>首先关心一下,配置文件放哪里才会被加载</p>
<table>
<thead>
<tr><th align="center"><strong>1.file:./config</strong></th><th align="center"><strong>2.file:/</strong></th></tr>
</thead>
<tbody>
<tr><td align="center"><strong>3.classpath:/config/</strong></td><td align="center"><strong>4.classpath:/</strong></td></tr>
</tbody>
</table>
<p>按照顺序,1-4按顺序扫描,然后1-4の优先级依次降低,当配置文件里的属性冲突时,以优先级高的配置文件为准</p>
<p>还有一点需要注意的就是,这些文件都会被加载,形成互补配置</p>
<h4>9.1 外部配置文件加载顺序</h4>
<pre><code class="language-php">1、命令行参数：所有的配置都可以在命令行参数中指定，每个配置项前使用--，多个配置间使用空格隔开，例如：

java -jar spring-boot-02-0.0.1-SNAPSHOT.jar --server.port=8088 --server.context-path=boot
2、来自java:comp/env的JNDI属性

3、java的系统属性(System.getProperties(""))

4、操作系统环境变量

5、RandomValuePropertySource配置的random.*属性值

6、jar包外部的application-{profile}.properties或application-{profile}.yml(带spring.profile配置)

7、jar包内部的application-{profile}.properties或application-{profile}.yml(带spring.profile配置)

8、jar包外部的application.properties或application.yml(不带spring.profile配置)

9、jar包内部的application.properties或application.yml(不带spring.profile配置)

10、@Configuration注解类上的@PropertySource

11、通过SpringApplication.setDefaultProperties()指定的默认属性

注：

    ①以上配置文件的优先级顺序由高到低，高优先级的覆盖低优先级的并形成互补

    ②6、8所指的jar包外指的是和jar包同一个文件夹下
</code></pre>]]></description>
      <author>JokerLee</author>
      <guid>https://jokeme.top/articles/2020/05/29/1590754071333.html</guid>
      <category>Java</category>
      <category>SpringBoot</category>
      <pubDate>Fri, 29 May 2020 20:08:25 +0800</pubDate>
    </item>
    <item>
      <title>我在 GitHub 上的开源项目</title>
      <link>https://jokeme.top/my-github-repos</link>
      <description><![CDATA[<!-- 该页面会被定时任务自动覆盖，所以请勿手工更新 -->
<!-- 如果你有更漂亮的排版方式，请发 issue 告诉我们 -->
<h3>1. <a href="https://github.com/jokefrelon/make" target="_blank">make</a> <kbd title="主要编程语言">Shell</kbd> <span style="font-size: 12px;"><a href="https://github.com/jokefrelon/make/watchers" title="关注数" target="_blank">]]>🤩<![CDATA[<code>0</code></a>&nbsp;&nbsp;<a href="https://github.com/jokefrelon/make/stargazers" title="收藏数" target="_blank">⭐️<code>1</code></a>&nbsp;&nbsp;<a href="https://github.com/jokefrelon/make/network/members" title="分叉数" target="_blank">]]>🖖<![CDATA[<code>0</code></a></span></h3>
<hr>
<h3>2. <a href="https://github.com/jokefrelon/linux-series" target="_blank">linux-series</a> <kbd title="主要编程语言">Shell</kbd> <span style="font-size: 12px;"><a href="https://github.com/jokefrelon/linux-series/watchers" title="关注数" target="_blank">]]>🤩<![CDATA[<code>0</code></a>&nbsp;&nbsp;<a href="https://github.com/jokefrelon/linux-series/stargazers" title="收藏数" target="_blank">⭐️<code>1</code></a>&nbsp;&nbsp;<a href="https://github.com/jokefrelon/linux-series/network/members" title="分叉数" target="_blank">]]>🖖<![CDATA[<code>0</code></a></span></h3>
<hr>
<h3>3. <a href="https://github.com/jokefrelon/java-learn" target="_blank">java-learn</a> <kbd title="主要编程语言">Java</kbd> <span style="font-size: 12px;"><a href="https://github.com/jokefrelon/java-learn/watchers" title="关注数" target="_blank">]]>🤩<![CDATA[<code>1</code></a>&nbsp;&nbsp;<a href="https://github.com/jokefrelon/java-learn/stargazers" title="收藏数" target="_blank">⭐️<code>1</code></a>&nbsp;&nbsp;<a href="https://github.com/jokefrelon/java-learn/network/members" title="分叉数" target="_blank">]]>🖖<![CDATA[<code>0</code></a></span></h3>
<p>learn java_series</p>
<hr>
<h3>4. <a href="https://github.com/jokefrelon/jokefrelon.github.io" target="_blank">jokefrelon.github.io</a> <kbd title="主要编程语言">HTML</kbd> <span style="font-size: 12px;"><a href="https://github.com/jokefrelon/jokefrelon.github.io/watchers" title="关注数" target="_blank">]]>🤩<![CDATA[<code>2</code></a>&nbsp;&nbsp;<a href="https://github.com/jokefrelon/jokefrelon.github.io/stargazers" title="收藏数" target="_blank">⭐️<code>0</code></a>&nbsp;&nbsp;<a href="https://github.com/jokefrelon/jokefrelon.github.io/network/members" title="分叉数" target="_blank">]]>🖖<![CDATA[<code>0</code></a>&nbsp;&nbsp;<a href="https://jokefrelon.github.io/" title="项目主页" target="_blank">]]>🏠<![CDATA[<code>https://jokefrelon.github.io/</code></a></span></h3>
<hr>
<h3>5. <a href="https://github.com/jokefrelon/python" target="_blank">python</a> <kbd title="主要编程语言">Python</kbd> <span style="font-size: 12px;"><a href="https://github.com/jokefrelon/python/watchers" title="关注数" target="_blank">]]>🤩<![CDATA[<code>0</code></a>&nbsp;&nbsp;<a href="https://github.com/jokefrelon/python/stargazers" title="收藏数" target="_blank">⭐️<code>0</code></a>&nbsp;&nbsp;<a href="https://github.com/jokefrelon/python/network/members" title="分叉数" target="_blank">]]>🖖<![CDATA[<code>0</code></a></span></h3>
<p>啊哈,爬虫啊</p>
<hr>
<h3>6. <a href="https://github.com/jokefrelon/html5" target="_blank">html5</a> <kbd title="主要编程语言">HTML</kbd> <span style="font-size: 12px;"><a href="https://github.com/jokefrelon/html5/watchers" title="关注数" target="_blank">]]>🤩<![CDATA[<code>0</code></a>&nbsp;&nbsp;<a href="https://github.com/jokefrelon/html5/stargazers" title="收藏数" target="_blank">⭐️<code>0</code></a>&nbsp;&nbsp;<a href="https://github.com/jokefrelon/html5/network/members" title="分叉数" target="_blank">]]>🖖<![CDATA[<code>0</code></a></span></h3>
<hr>
<h3>7. <a href="https://github.com/jokefrelon/javawork" target="_blank">javawork</a> <kbd title="主要编程语言">Java</kbd> <span style="font-size: 12px;"><a href="https://github.com/jokefrelon/javawork/watchers" title="关注数" target="_blank">]]>🤩<![CDATA[<code>1</code></a>&nbsp;&nbsp;<a href="https://github.com/jokefrelon/javawork/stargazers" title="收藏数" target="_blank">⭐️<code>0</code></a>&nbsp;&nbsp;<a href="https://github.com/jokefrelon/javawork/network/members" title="分叉数" target="_blank">]]>🖖<![CDATA[<code>0</code></a></span></h3>
<p>java homework</p>]]></description>
      <author>JokerLee</author>
      <guid>https://jokeme.top/my-github-repos</guid>
      <category>GitHub</category>
      <category>开源</category>
      <pubDate>Wed, 06 May 2020 00:33:17 +0800</pubDate>
    </item>
    <item>
      <title>Java Collection学习</title>
      <link>https://jokeme.top/articles/2019/12/20/1576773712519.html</link>
      <description><![CDATA[<h1>?<strong>collection</strong>集合</h1>
<pre><code class="language-properties">collection--|
		   |--list:有序,有索引,允许重复元素
		   |--set:不允许重复元素,元素存取无序
</code></pre>
<h2>1.共性功能</h2>
<p>a.添加</p>
<pre><code class="language-java">Boolean add (Obj obj);//添加单个对象
Boolean addAll (Collection c);//添加一组的collection的对象
</code></pre>
<p>b.删除</p>
<pre><code class="language-Java">void clear();//清空collection内所有对象/元素
Boolean remove (Object o);//删除collection里面某个对象
Boolean removeAll (Collection c);//删除一组的collection
</code></pre>
<p>c.获取长度</p>
<pre><code class="language-java">int size();
</code></pre>
<p>d.判断</p>
<pre><code class="language-java">Boolean isEmpty();
Boolean contains(Object o);
Boolean containsAll(Collection c)
</code></pre>
<p>e.集合转数组</p>
<pre><code class="language-java">toArray();
toArray([]);
</code></pre>
<p>f.迭代器</p>
<pre><code class="language-java">Iterator iterator();
</code></pre>
<h2>2. <strong>List</strong>集合</h2>
<h3>2.1 <strong>list</strong>集合的具体子类</h3>
<pre><code class="language-properties">List----
	|-- Vector:数组数据结构,长度可变,线程同步&lt;多线程安全&gt;,但是速度比较慢(现在已经不常用-被ArrayList替代),长度按数组长度的100%延长
	|-- ArrayList:数组结构,长度可变,线程不同步&lt;多线程不安全&gt;.查,速度快,增 删 改速度慢,长度按数组长度的50%延长
	|-- LinkedList:链表结构,线程不同步&lt;多线程不安全&gt;,增,删,改,速度快,查 速度慢
</code></pre>
<h3>2.2  迭代器使用注意</h3>
<pre><code class="language-properties">Exception in thread "main" java.util.ConcurrentModificationException
	at java.util.ArrayList$Itr.checkForComodification(Unknown Source)
	at java.util.ArrayList$Itr.next(Unknown Source)
</code></pre>
<p>遇到这种在使用迭代器时还修改迭代器内元素的时候，<strong>JVM</strong>会报错，这时候就需要用<strong>ListIterator</strong></p>
<h3>2.3 犯错实记 ?:</h3>
<pre><code class="language-java">package sourceCode;

import java.util.ArrayList;
import java.util.List;
import java.util.ListIterator;

public class listTest {
	public static void clean(ArrayList&lt;person&gt; jsr) {
		List&lt;person&gt; dot = new ArrayList&lt;person&gt;();

		for (ListIterator&lt;person&gt; lis = jsr.listIterator(); lis.hasNext();) {
			person pop = lis.next();
			if (!dot.contains(pop)) {
				dot.add(pop);
			}
		}
		jsr.clear();
		jsr.addAll(dot);
	}

	public static void main(String[] args) {
		ArrayList&lt;person&gt; jsr = new ArrayList&lt;person&gt;();
		jsr.add(new person(20, "frelon"));
		jsr.add(new person(21, "frelon"));
		jsr.add(new person(23, "frelon"));
		jsr.add(new person(21, "frelon"));
		clean(jsr);
		System.out.println(jsr);
	}

}
</code></pre>
<pre><code class="language-java">package sourceCode;

public class person {
	private int age;
	private String name;

	public person(int age, String name) {
		super();
		this.age = age;
		this.name = name;
	}

	public int getAge() {
		return age;
	}

	public void setAge(int age) {
		this.age = age;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	@Override
	public String toString() {
		return "person [age=" + age + ", name=" + name + "]";
	}
	


	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (getClass() != obj.getClass())
			return false;
		person other = (person) obj;
		if (age != other.age)
			return false;
		if (name == null) {
			if (other.name != null)
				return false;
		} else if (!name.equals(other.name))
			return false;
		return true;
	}

	public boolean equals(person obj) {
		if (this==obj) {
			return true;
		}
			return this.name.equals(obj.name)&amp;&amp;this.age==obj.age;
	}
}

</code></pre>
<p>上面这个例子，是我用了两天时间得出<strong>Java</strong>面向接口编程的一个实例</p>
<p>为什么说用了两天时间呢？</p>
<p>因为我一直都不太明白 Java 面向对象编程的具体表现，所以在写代码的时候也比较呆板，再者就是我还没有搞明白接口里面的类有没有被子类所实现</p>
<pre><code class="language-Java">ArrayList&lt;person&gt; dot = new ArrayList&lt;person&gt;();
</code></pre>
<p>这就是我犯错的一段代码，我总是用<strong>List</strong>的子类 <strong>ArrayList</strong>来<strong>new</strong>新对象，而我<strong>Overwrite</strong>的方法已经被<strong>ArrayList</strong>实现，使用无论我怎么调用都还是无法调用到我自己 <strong>Overwrite</strong>后的代码</p>
<pre><code class="language-java">List&lt;person&gt; dot = new ArrayList&lt;person&gt;();
</code></pre>
<p>这就是导致我卡了两天的细节，我用<strong>List</strong> <strong>new</strong>对象以后代码完美执行了</p>
<p>这就是因为没有掌握面向对象编程的思想，犯下的一个低级错误</p>
<h4><a href="http://www.jokeme.top/articles/2019/12/20/1576774367244.html" target="_blank">重写 equals和hashcode</a></h4>
<h3>2.4 LinkedList</h3>
<h4>a.特有方法</h4>
<table>
<thead>
<tr><th align="center">addFirst()</th><th align="center">removeFirst()</th><th align="center">getFirst()</th></tr>
</thead>
<tbody>
<tr><td align="center">#添加到第一个</td><td align="center">#删除第一个</td><td align="center">#获取第一个</td></tr>
<tr><td align="center"><strong>addlast()</strong></td><td align="center"><strong>removeLast()</strong></td><td align="center"><strong>getLast()</strong></td></tr>
<tr><td align="center">#添加到最后一个</td><td align="center">#删除最后一个</td><td align="center">#获取最后一个</td></tr>
</tbody>
</table>
<p><strong>JDK1.6</strong>以后推荐使用下列方法替代，这样在遇到空值时就不会报错而是返回<strong>null</strong></p>
<table>
<thead>
<tr><th align="center">offerFirst()</th><th align="center">pollFirst()</th><th align="center">peekFirst()</th></tr>
</thead>
<tbody>
<tr><td align="center">#添加到第一个</td><td align="center">#删除第一个</td><td align="center">#获取第一个</td></tr>
<tr><td align="center"><strong>offerLast()</strong></td><td align="center"><strong>pollLast()</strong></td><td align="center"><strong>peekLast()</strong></td></tr>
<tr><td align="center">#添加到最后一个</td><td align="center">#删除最后一个</td><td align="center">#获取最后一个</td></tr>
</tbody>
</table>
<h4>b.实战演练</h4>
<p>实现  先进后出</p>
<pre><code class="language-java">package sourceCode;

import java.util.LinkedList;

public class linkedlist_test {
	public static void main(String[] args) {
		test loser = new test();
		loser.setKail("hello");
		loser.setKail("CNN");
		loser.setKail("Love China");
		while (loser.Kailisempty()) {
			System.out.println(loser.getKail());
		}
	}
}

class test {
	private LinkedList&lt;Object&gt; kail;

	public Object getKail() {
		return kail.pollLast();
	}

	public Boolean Kailisempty() {
		if (kail.isEmpty()) {
			return false;
		} else if (!kail.isEmpty()) {
			return true;
		}
		return false;
	}

	@Override
	public String toString() {
		return "test [kail=" + kail + "]";
	}

	public void setKail(Object obj) {
		this.kail.addLast(obj);
	}

	public test() {
		kail = new LinkedList&lt;Object&gt;();
	}
}
</code></pre>
<h2>3. Set 集合</h2>
<pre><code class="language-properties">Set--:不允许重复元素,方法和collection相同.set集合只能用Iterator取出元素
	|--Hashset:不保证存入和取出的顺序一致,不允许重复,效率高 
			 |--LinkedHashSet:有序的HashSet表,不允许重复	
	|--Treeset:可以对元素进行排序,其排序方式需要元素具备比较功能,且实现CompareTo()方法,且不允许存储相同元素的方法是依据compareto()返回值是否为0,其数据结构为二叉树结构,
</code></pre>
<h3>3.1HashSet</h3>
<p><strong>HashSet</strong>主要就是靠<strong>hashcode()<strong>表来确定元素排列的，在使用时必须要重写</strong>hashCode()<strong>方法，而</strong>hashCode()<strong>方法内部又调用到了</strong>equals()<strong>方法来解决</strong>Hash 冲突</strong>,所以在使用时必须要<strong>Overwrite</strong>这两个方法</p>
<h4>3.1.1 HashSet 使用示例</h4>
<pre><code class="language-Java">package sourceCode;

import java.util.HashSet;
import java.util.Set;

public class hashset {
	public static void main(String[] args) {
		Set doThat = new HashSet();
		
		doThat.add(new person(13,"coco"));
		doThat.add(new person(22,"peon"));
		doThat.add(new person(23,"frelon"));
		doThat.add(new person(23,"frelon"));
		
		System.out.println(doThat);
	}
}

person类同上,这里仅写出 Overwrite 部分
	@Override
	public boolean equals(Object obj) {
		if (this==obj) {
			return true;
		}	
			person se = (person) obj;
			return this.name.equals(se.name)&amp;&amp;this.age==se.age;
	}
	@Override
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		result = prime * result + age;
		result = prime * result + ((name == null) ? 0 : name.hashCode());
		return result;
	}
</code></pre>
<h3>3.2 TreeSet</h3>
<h4>3.2.1 Comparable 接口的学习</h4>
<pre><code class="language-properties">Exception in thread "main" java.lang.ClassCastException: sourceCode.person cannot be cast to java.lang.Comparable
	at java.util.TreeMap.compare(Unknown Source)
	at java.util.TreeMap.put(Unknown Source)
	at java.util.TreeSet.add(Unknown Source)
</code></pre>
<p>这个异常对于学习 TreeSet 的我是一脸懵逼啊 ?,啥啥啥啊，就报了个异常，再看看我这代码没有错啊，编辑器也没有报错啊！</p>
<pre><code class="language-java">package sourceCode;

import java.util.Set;
import java.util.TreeSet;

public class treeSetLearn {
	public static void main(String[] args) {
		Set ssf = new TreeSet();
		ssf.add(new person(12, "hfh"));
		ssf.add(new person(19, "frelon"));
		ssf.add(new person(13, "jokoe"));

	}
}
</code></pre>
<p>遂百度，知，需要<strong>person</strong> 类 <strong>implements</strong> <strong>comparable</strong> 接口并 <strong>Overwrite</strong> 该接口的 <strong>CompareTo()</strong> 方法</p>
<pre><code class="language-java">package sourceCode;

public class person implements Comparable {
​~~~
    略
​~~~
    方法一:只能按年龄排序,忽略了姓名
	public int compareTo(Object osi) {
		person seao = (person) osi;
		if(this.age&gt;seao.age) {
			return 1;
		}
		if(this.age&lt;seao.age)
			return -1;
		return 0;
	}
    
​~~~
    方法二:完美方案?
    public int compareTo(Object osi){
        int temp = this.age-seao.age;
        return temp==0?this.name.compareTo(osi.name):temp;
    }
</code></pre>
<p>按照方法二改完以后，成功按照年龄(从小到大)排序，并且同姓名，同年龄算一个人，不存进去</p>
<h4>3.2.2 实现<strong>Comparator</strong>接口示例</h4>
<p>当我们需要需要 对没有比较功能的元素进行排序时<strong>or</strong> 自定义元素排序方式时，我们就不能再依赖通过实现<strong>Comparable</strong>接口的**CompareTo()**方法，而是要自定义一个新的比较器</p>
<h5>3.2.2.1 使用自定义的比较器对<strong>TreeSet</strong>排序</h5>
<pre><code class="language-java">package sourceCode;

import java.util.Set;
import java.util.TreeSet;

public class diySavePerson {
	public static void main(String[] args) {
		Set t1 = new TreeSet(new diyCompare());
		t1.add(new person(12,"frelon"));
		t1.add(new person(29,"lion"));
		t1.add(new person(29,"aion"));
		t1.add(new person(19,"zoco"));
		for(Object se : t1) {
			System.out.println(se);
		}
	}
}
</code></pre>
<pre><code class="language-java">package sourceCode;

import java.util.Comparator;

public class diyCompare implements Comparator&lt;Object&gt; {

	@Override
	public int compare(Object arg0, Object arg1) {

		person p1 = (person) arg0;
		person p2 = (person) arg1;

		int temp = p1.getName().compareTo(p2.getName());
		int temp2 = p1.getAge() - p2.getAge();

		return temp == 0 ? temp2 : temp;
	}

}
</code></pre>
<h5>3.2.2.2 对根据字符长短排序</h5>
<p>下面的方案主要是根据名字的长短来排序的，如长短相同则根据名字的<strong>hashCode</strong>决定谁在前面</p>
<pre><code class="language-java">package sourceCode;

import java.util.Set;
import java.util.TreeSet;

public class diySavePerson {
	public static void main(String[] args) {
		Set&lt;String&gt; set1 = new TreeSet&lt;String&gt;( new diyCompare()); 
		set1.add("jeAreF");
		set1.add("jpwdth");
		set1.add("jogeth");
		set1.add("jokeme");
		set1.add("jsrdds");
		for (Object se: set1) {
			System.out.println(se);
		}
	}
}
</code></pre>
<pre><code class="language-java">package sourceCode;

import java.util.Comparator;

public class diyCompare implements Comparator&lt;Object&gt; {

	@Override
	public int compare(Object arg0, Object arg1) {
		String str1 = (String)arg0;
		String str2 = (String)arg1;
		int temp1=str1.length()-str2.length();
		int sss = str1.hashCode();
		int ssd = str2.hashCode();
		return temp1==0?sss-ssd:temp1;
	}

}
</code></pre>
<h5>3.2.3 三元运算符</h5>
<p>语法为：<strong>条件表达式？表达式 1：表达式 2</strong>。</p>
<p>说明：问号前面的位置是判断的条件，判断结果为 boolean 型，为 true 时调用表达式 1，为 false 时调用表达式 2。</p>]]></description>
      <author>JokerLee</author>
      <guid>https://jokeme.top/articles/2019/12/20/1576773712519.html</guid>
      <category>Java</category>
      <pubDate>Wed, 06 May 2020 00:32:52 +0800</pubDate>
    </item>
    <item>
      <title>Java equals方法和contains为什么要重写?</title>
      <link>https://jokeme.top/articles/2019/12/20/1576774367244.html</link>
      <description><![CDATA[<h1><strong>equals() &amp;&amp; contains()</strong></h1>
<p>Java 中常见的比较有<strong>equals</strong>和<strong>hashcode</strong></p>
<p>今天在学习的时候就遇到了一个头疼的问题(菜鸟级的我有大大疑问)</p>
<p>在比较两个对象内的元素时，无论是使用<strong>equals</strong>还是<strong>hashcode</strong>都始终得不到我想要的结果。遂百度，记此文</p>
<p>那么这两种方法到底有什么区别呢？</p>
<p>equals()方法是根类 Object 的默认方法，查看 Object 中 equals()的默认实现：</p>
<pre><code class="language-java">public boolean equals(Object obj) {
    return (this == obj);
    }
:white_check_mark:
</code></pre>
<p>可以看出没有重写过的 equals()方法和 == 是一样的，都是比较两个对象引用指向的内存地址是否一样判断两个对象是否相等。</p>
<p>也就是说，基本上每次都要<strong>Overwrite</strong>这个方法</p>
<p><strong>hashCode</strong>是<strong>JDK</strong>根据对象的地址或者字符串或者数字计算该对象的哈希码值的方法。</p>
<p><strong>hashcode</strong> 和 <strong>equals</strong> 两者必须同时重写。</p>
<hr>
<p>注意在类中，有一些 <strong>equals</strong> 方法 <strong>OverWrite</strong> 时必须要传入 <strong>Object</strong> 类型</p>
<pre><code class="language-java">public boolean equals (person obj){
	return (this == obj);
	}	
:x:
//这样写就是错误的,equals()方法不允许传入非 Object 类
</code></pre>]]></description>
      <author>JokerLee</author>
      <guid>https://jokeme.top/articles/2019/12/20/1576774367244.html</guid>
      <category>Java</category>
      <pubDate>Wed, 06 May 2020 00:32:31 +0800</pubDate>
    </item>
    <item>
      <title>nginx反向代理</title>
      <link>https://jokeme.top/articles/2020/01/10/1578638927507.html</link>
      <description><![CDATA[<h2>nginx 反向代理</h2>
<p>nginx 一直都是我们比较常用的工具，它不仅功能强悍，而且性能也非常好 ?,一直深受开发者的喜爱</p>
<p>并且我们经常用 <strong>nginx</strong> 反代来做负载均衡，那么 <strong>nginx</strong> の反代原理我也就不说了，咱就说咋操作吧</p>
<p>我把我的网站的 <strong>nginx</strong> 配置给拷贝了下来</p>
<pre><code class="language-nginx">server {
    listen    443  ssl;
    server_name   www.jokeme.top;

    add_header Strict-Transport-Security "max-age=31536000; includeSubDomains;preload" always;    
    ssl_certificate /ssl/3355633_www.jokeme.top.pem;
    ssl_certificate_key /ssl/3355633_www.jokeme.top.key;
    ssl_session_timeout 5m;
    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;
    ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE;
    ssl_prefer_server_ciphers on;

    location / {
        root /usr/share/nginx/html;
        index index.html index.htm;
        proxy_pass http://www.jokeme.top:8080;
}
    error_page   500 502 503 504  /50x.html;
    location = /50x.html {
        root   /usr/share/nginx/html;
    }
}

server{
  listen 80;
  server_name localhost;
  rewrite ^(.*) https://$host$1 permanent;
}
</code></pre>
<p>我的网站呢，是通过 <strong>docker</strong> 跑在 8080 端口的 <strong>https</strong> ,如果日常需要访问的话是不太方便の,还需要敲端口号</p>
<p><strong>nginx</strong> 通过把 8080 端口的数据代理到 443 端口，来实现我们直接通过域名来访问，也就是 <strong>location</strong> 里面の <strong>proxy_pass</strong>实现了反向代理的功能</p>
<p>而且当用户通过 80 端口访问 <strong>http</strong> 的时候还会自动转到 443 端口的 <strong>https</strong> 这个就是下面的那个 <strong>server</strong> <strong>rewrite</strong>实现的</p>
<p>还有一个就是大家反代的时候一定要确认你那个端口是允许访问的，要不然你的配置没有问题，但就是拒接连接，或者连接超时，昨天晚上我就出现了这种情况，配置没有问题，但是网站就是不能访问，然后倒腾了一圈，才想起来是我防火墙没有开放端口 ?</p>]]></description>
      <author>JokerLee</author>
      <guid>https://jokeme.top/articles/2020/01/10/1578638927507.html</guid>
      <category>nginx</category>
      <category>Linux</category>
      <pubDate>Wed, 06 May 2020 00:31:22 +0800</pubDate>
    </item>
    <item>
      <title>Python 爬虫</title>
      <link>https://jokeme.top/articles/2019/12/31/1577785161692.html</link>
      <description><![CDATA[<h1>Python 爬虫 ?</h1>
<p>用<strong>python</strong>写爬虫其实是比较简单的，主要还是靠第三方的库 ?常用的有 <strong>requests &amp; urllib</strong> 至于解析 HTML,我目前使用的是 <strong>xpath</strong> ,了解了基本操作，咱就试试看吧</p>
<h3>代码附上</h3>
<pre><code class="language-python"># coding:utf-8
import json
import requests
from lxml import etree

def getWebUrl(uri):
	webPage = requests.get(url = uri,
		headers={"User-Agent":"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/79.0.3945.88 Safari/537.36"}
		)

	we = webPage.text
	ssr = etree.HTML(we)
	
	Links = ssr.xpath("//div/table/tbody/tr/td/p/a/@href")

	Str = "http://172.17.150.251"
	Allinks = []

	for  se  in Links:
		link = Str+se
		Allinks.append(link)
	
	dicName = {}
	dicName = {uri:Allinks}
	return dicName

def getInfo(uri):
	webPage = requests.get(url = uri,
		headers={"User-Agent":"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/79.0.3945.88 Safari/537.36"}
		)
	page = webPage.text
	pageinfo = etree.HTML(page)

	info = pageinfo.xpath("//div/span[@class='sp4']/text()")
	notNesInfo = pageinfo.xpath("//div/span[@class='sp2']/text()")
	salaryInfo = pageinfo.xpath("//div[@class='cn']/strong/text()")
	job = pageinfo.xpath("//p[position()=1]/span[@class='el']/text()")
	city = pageinfo.xpath("//span[@class='lname']/text()")

	if (len(notNesInfo)!=0):
		for er in notNesInfo:
			info.append(er)

	information = {"info":info,'salaryInfo':salaryInfo,'job':job,'city':city}

	return information


# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
we = {}
fun = {}
tot = []
wilu = []
for a in range(1,41):
	strin = "http://172.17.150.251/xueqing-web/course/index/{}".format(a)
	tot.append(strin)
	we = getWebUrl(strin)
	fun.update(we)
	we.clear()
for osx in tot:
	wilu  = fun.get(osx)
	for xs in wilu:
		ufo = {}
		ufo = getInfo(xs)
		fuc ={xs:ufo}
		we.update(fuc)

wei = json.dumps(we,indent=1,ensure_ascii=False)
with open("wuli.json",'w',encoding='utf-8') as f:
	f.write(wei)
print("?")
</code></pre>
<p>因为我是真的又菜又爱玩，所以才写的这么烂的代码 ?,以后还是要慢慢提升啊</p>
<p>我爬取的是 51job 网站，可是如果爬虫大规模爬取，网站就会封 IP,所以我就把页面抓下来，放到本地，开一个 Web 服务器，慢慢调试代码代码 ?‍♂️</p>
<p>最基本的两个库，<strong>requests &amp; lxml</strong>  <strong>simplejson</strong> 不是必要的，我只是为了把爬取到的数据保存到本地查看才出此下策，实在是菜的无奈 ?才这样干了，其实我也是懒得配置数据库了</p>
<h3>代码解释</h3>
<p><strong>getWebUrl()</strong> 是拿取网站一共有多少页并且获取该页面下的求职信息详情页面链接，再传递给下一个函数处理我给写死了</p>
<p><strong>getInfo()</strong> 处理<strong>geWebUrl()</strong> 传递过来的详情页面链接，并爬取数据返回我需要的求职信息</p>
<p>还有需要注意的是 JSON 格式化<strong>dict</strong>Chinese 时，非常容易乱码，所以在 dumps()方法里，我没有用 ascii,这也算是一个小坑吧，一开始的时候<br>
我保存数据，不管用啥方法都乱码，心态都炸了，<strong># coding:utf-8</strong>也用了，就是不奏效</p>
<h3>爬取到的信息节选</h3>
<pre><code class="language-json">{
 "http://172.17.150.251/xueqing-web/51job/72396849.html": {
        "info": [
            "3-4年经验",
            "本科",
            "招1人",
            "02-08发布",
            "英语良好",
            "计算机科学与技术 自动化"
        ],
        "salaryInfo": [
            "15-28万/年"
        ],
        "job": [
            "软件工程师",
            "算法工程师"
        ],
        "city": [
            "广州"
        ]
    },
    "http://172.17.150.251/xueqing-web/51job/98287424.html": {
        "info": [
            "5-7年经验",
            "大专",
            "招若干人",
            "02-08发布"
        ],
        "salaryInfo": [
            "1-2万/月"
        ],
        "job": [
            "销售经理"
        ],
        "city": [
            "北京"
        ]
    },
    "http://172.17.150.251/xueqing-web/51job/98370374.html": {
        "info": [
            "5-7年经验",
            "本科",
            "招2人",
            "02-08发布"
        ],
        "salaryInfo": [],
        "job": [
            "高级软件工程师",
            "网站运营经理/主管"
        ],
        "city": [
            "深圳"
        ]
    },
    "http://172.17.150.251/xueqing-web/51job/97846012.html": {
        "info": [
            "无工作经验",
            "本科",
            "招若干人",
            "02-08发布",
            "英语熟练",
            "计算机科学与技术 计算机网络"
        ],
        "salaryInfo": [
            "10-15万/年"
        ],
        "job": [
            "系统工程师",
            "系统架构设计师"
        ],
        "city": [
            "北京-昌平区"
        ]
    },
    "http://172.17.150.251/xueqing-web/51job/96612644.html": {
        "info": [
            "无工作经验",
            "招若干人",
            "02-08发布"
        ],
        "salaryInfo": [
            "1-2万/月"
        ],
        "job": [
            "信息技术经理/主管"
        ],
        "city": [
            "北京-西城区"
        ]
    }
}
</code></pre>]]></description>
      <author>JokerLee</author>
      <guid>https://jokeme.top/articles/2019/12/31/1577785161692.html</guid>
      <category>python</category>
      <pubDate>Wed, 06 May 2020 00:30:52 +0800</pubDate>
    </item>
    <item>
      <title>Java 时间类API的使用</title>
      <link>https://jokeme.top/articles/2019/12/22/1576958773512.html</link>
      <description><![CDATA[<h1>时间类 API</h1>
<p>在日常学习生活中，我们经常遇到时间相关的问题，现在虽然 Date 类已经不是主流了，但任然有许多方法要学习</p>
<h2>1.1DateFormat</h2>
<h3>1.1.1 使用示例</h3>
<pre><code class="language-java">package APICourceCode;

import java.text.DateFormat;
import java.util.Date;

public class dateAPI {
	public static void main(String[] args) {
		Date date = new Date();
		DateFormat ses = DateFormat.getDateTimeInstance(DateFormat.FULL, DateFormat.FULL);
		String sesa = ses.format(date);
		System.out.println(sesa);
	}
}
</code></pre>
<p>其常见的<strong>Style</strong>如下</p>
<pre><code class="language-properties">FULL:2019年12月16日 星期一 下午06时38分17秒 CST
LONG:2019年12月16日 下午06时39分20秒
MEDIUM:2019-12-16 18:39:41 (默认方式)
SHORT:19-12-16 下午6:40
</code></pre>
<p>如果需要自定义的格式，就需要按照下面的表格自定义，自定义以后，系统自带的<strong>Style</strong>将不生效</p>
<table>
<thead>
<tr><th align="center">字母</th><th align="center">意义</th></tr>
</thead>
<tbody>
<tr><td align="center">y</td><td align="center">年</td></tr>
<tr><td align="center">M</td><td align="center">月份</td></tr>
<tr><td align="center">w</td><td align="center">年份中的周数</td></tr>
<tr><td align="center">W</td><td align="center">月份中的周数</td></tr>
<tr><td align="center">d</td><td align="center">月份中的天数</td></tr>
<tr><td align="center">D</td><td align="center">年份中的天数</td></tr>
<tr><td align="center">F</td><td align="center">月份中的星期</td></tr>
<tr><td align="center">E</td><td align="center">星期中的天数</td></tr>
<tr><td align="center">a</td><td align="center">am/pm 表示上下午</td></tr>
<tr><td align="center">H</td><td align="center">一天中的小时数(0-23)</td></tr>
<tr><td align="center">h</td><td align="center">am/pm 中的一天小时数(1-12)</td></tr>
<tr><td align="center">m</td><td align="center">小时中的分钟数</td></tr>
<tr><td align="center">s</td><td align="center">分钟中的秒数</td></tr>
<tr><td align="center">S</td><td align="center">毫秒数</td></tr>
<tr><td align="center">z</td><td align="center">PST;GMT 时区</td></tr>
</tbody>
</table>
<pre><code class="language-java">package APICourceCode;

import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.Date;

public class dateAPI {
	public static void main(String[] args) {
		Date date = new Date();
		DateFormat ses = DateFormat.getDateTimeInstance();
		ses = new SimpleDateFormat("yyyy/MM/dd HH-mm-ss-SS");
		String sesa = ses.format(date);
		System.out.println(sesa);
		
	}
}
</code></pre>
<h3>1.1.2 总结：</h3>
<p><strong>DateFormat</strong>方法其实很简单，</p>
<p>① 首先<strong>new</strong>一个<strong>Date</strong>类对象，就不用管了</p>
<p>② 调用<strong>DateFormat</strong>方法对象(不需要 new),生成自定义的<strong>Style</strong></p>
<p>③ 使用字符串接收<strong>DateFormat</strong>对象的<strong>Format</strong>方法，需要传<strong>Date</strong>类的对象</p>
<h2>1.2 DateFormat 反解析</h2>
<h3>1.2.1 使用示例：</h3>
<pre><code class="language-java">package APICourceCode;

import java.text.DateFormat;
import java.text.ParseException;
import java.util.Date;

public class ReverseDateFormat {
	public static void main(String[] args) throws ParseException {
		String str = "2019-07-02";
		DateFormat se = DateFormat.getDateInstance();
		Date date =se.parse(str);
		System.out.println(date);
	}
}
</code></pre>
<h2>2 Calendar</h2>
<h3>2.1 使用示例：</h3>
<pre><code class="language-java">package APICourceCode;

import java.util.Calendar;

public class CalenderL {
	public static void main(String[] args) {
		Calendar se = Calendar.getInstance();
		
		se.add(Calendar.YEAR, 1);
		
		int year = se.get(Calendar.YEAR);
		int month = se.get(Calendar.MONTH)+1;
		int day = se.get(Calendar.DAY_OF_MONTH);
		int hours = se.get(Calendar.HOUR_OF_DAY);
		int minute = se.get(Calendar.MINUTE);
		int sec = se.get(Calendar.SECOND);
		System.out.println(year + "-" + month + "-" + day + "-" + hours + "-" + minute + "-" + sec);
	}
}
----------
2020-12-16-20-16-53
</code></pre>
<h3>2.2 常见的<strong>Calendar</strong>参数</h3>
<pre><code class="language-properties">java.util.GregorianCalendar[
time=1576496255445,
firstDayOfWeek=1,
YEAR=2019,
MONTH=11,
WEEK_OF_YEAR=51,
WEEK_OF_MONTH=3,
DAY_OF_MONTH=16,
DAY_OF_YEAR=350,
DAY_OF_WEEK=2,
DAY_OF_WEEK_IN_MONTH=3,
HOUR=7,
HOUR_OF_DAY=19,
MINUTE=37,
SECOND=35,
MILLISECOND=445]
</code></pre>
<h3>2.3 日期的偏移</h3>
<pre><code class="language-Java">se.add(Calendar.MONTH, 1);
</code></pre>
<p>个人认为作用不是很大</p>]]></description>
      <author>JokerLee</author>
      <guid>https://jokeme.top/articles/2019/12/22/1576958773512.html</guid>
      <category>Java</category>
      <pubDate>Wed, 06 May 2020 00:30:16 +0800</pubDate>
    </item>
    <item>
      <title>Collection-Map学习总结</title>
      <link>https://jokeme.top/articles/2019/12/28/1577494146348.html</link>
      <description><![CDATA[<h1>Collection-Map</h1>
<pre><code class="language-properties">Map--|双列集合,一次存一对键值对,必须保证唯一性
	 --|HashMap:哈希表,不同步,允许空的Key,Value
	 --|TreeMap:二叉树,线程不同步,可以对Map集合的键?排序
	 --|Hashtable:哈希表,线程同步效率低下,不允许空的Key,Value
</code></pre>
<h2>1. Map 集合共性功能</h2>
<table>
<thead>
<tr><th align="center">添加</th><th align="center">V put(K,V) / putAll(Map&lt;K,V&gt; map)</th></tr>
</thead>
<tbody>
<tr><td align="center"><strong>删除</strong></td><td align="center"><strong>V remove(K) / void clear()</strong></td></tr>
<tr><td align="center"><strong>判断</strong></td><td align="center"><strong>Boolean  containsKey / Value()</strong></td></tr>
<tr><td align="center"><strong>获取</strong></td><td align="center"><strong>V get(K) / int size()</strong></td></tr>
</tbody>
</table>
<p>注意：如果对同一个键多次存储会出现值被覆盖的现象</p>
<h2>2 Map 集合取出键值对方法</h2>
<h3>2.1 迭代器取出法</h3>
<pre><code class="language-java">package sourceCode;

import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;

public class collMap {
	public static void main(String[] args) {
		Map&lt;Integer,String&gt; se = new HashMap&lt;Integer,String&gt;();
		se.put(1, "Now");
		se.put(5, "aset");
		se.put(6, "kEREd");
//		System.out.println(se);
		Set&lt;Integer&gt; keySet = se.keySet();
		for (Iterator&lt;Integer&gt; iter = keySet.iterator(); iter.hasNext();) {
			Integer ssr = (Integer) iter.next();
			System.out.println(se.get(ssr));
		}
	}
}
</code></pre>
<h3>2.2 Map.Entry</h3>
<pre><code class="language-Java">		Set&lt;Map.Entry&lt;Integer, String&gt;&gt; Solo = se.entrySet();
		for (Iterator&lt;Map.Entry&lt;Integer, String&gt;&gt; itera = Solo.iterator(); itera.hasNext();) {
			Map.Entry&lt;Integer, String&gt; me = itera.next();
			Integer er =me.getKey();
			String  sun =me.getValue();
			System.out.println(er+"::::"+sun);			
		}
</code></pre>
<p>这里解释以下<strong>Map.Entry</strong> 其实，<strong>Entry</strong>就是<strong>Map</strong>接口内的一个接口</p>
<p>它随着<strong>Map</strong>的加载而加载</p>
<pre><code class="language-java">interface Map{
	public static interface Entry {
		
	}
}
class xxx implements Map.Entry{

}
</code></pre>
<h3>2.3 Values 方法取出键值对</h3>
<pre><code class="language-java">Collection&lt;String&gt; value = se.values();
for (Iterator&lt;String&gt; uuid = value.iterator(); uuid.hasNext();) {
	String dock =uuid.next();
	System.out.println(dock);
}
</code></pre>
<hr>
<h3>2.4 三种方法结果如下：</h3>
<pre><code class="language-properties">Now
aset
kEREd
​~~~~~~~~~~~
1::::Now
5::::aset
6::::kEREd
​~~~~~~~~~~~
Now
aset
kEREd
</code></pre>
<h3>2.5 关于 Map.Entry 方法</h3>
<p>其实<strong>Map.Entry</strong>可以直接写为<strong>Entry</strong> 方法，因为我在敲代码的时候偶然发现，不敲 <strong>Map.</strong> 程序依然可以正常运行</p>
<p>百度得：</p>
<pre><code class="language-properties">Entry是Map中的一个静态内部类，用来表示Map中的每个键值对。除非使用了静态导入:import static java.util.Map.*
除了使用静态导入外，还可以直接导入这个类，因为它是public的。即:import java.util.Map.Entry。
导入后也可以在当前空间直接使用Entry。
</code></pre>]]></description>
      <author>JokerLee</author>
      <guid>https://jokeme.top/articles/2019/12/28/1577494146348.html</guid>
      <category>Java</category>
      <pubDate>Wed, 06 May 2020 00:29:54 +0800</pubDate>
    </item>
    <item>
      <title>Collections 学习</title>
      <link>https://jokeme.top/articles/2019/12/28/1577495325749.html</link>
      <description><![CDATA[<h1>Collection 框架的工具类</h1>
<h2>1. Collections</h2>
<h3>1.1.1  sort 按照自然顺序排序</h3>
<pre><code class="language-java">package sourceCode;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

public class Collections_utils {
	public static void main(String[] args) {
		List&lt;String&gt; se = new ArrayList&lt;String&gt;();
		se.add("fdw");
		se.add("jokeme");
		se.add("dfipo");
		se.add("daase");
		Collections.sort(se);
		System.out.println(se);
			}
}
​~~~~~~~~~~~~~~~~~~~~~
[daase, dfipo, fdw, jokeme]
</code></pre>
<p>用法很简单： <strong>Collections.sort(List)</strong></p>
<h3>1.1.2   reverse 倒序排列自然排序的 List</h3>
<pre><code class="language-java">Collections.reverse(se);
System.out.println(se);
​~~~~~~~~~~~~~~~~
[jokeme, fdw, dfipo, daase]
</code></pre>
<p>用法也很简单： <strong>Collections.reverse(List)</strong></p>
<p>如果单独使用时，其效果和 <strong>reverseOrder()</strong> 作用一样</p>
<h3>1.1.3  自定义排序方法</h3>
<pre><code class="language-java">Collections.reverseOrder(Comparator&lt;T&gt; cmp())
</code></pre>
<p>自定义排序方法时就需要使用 <strong>reverseOrder()</strong> 并且需要自定义一个比较方法 ? 传进去</p>
<pre><code class="language-java">Collections.sort(se, Collections.reverseOrder(new compareByLength()));
System.out.println(se);
​~~~~~~~~~~~~~~~
[fdw, daase, dfipo, jokeme]
​~~~~~~~~~~~~~~~
package sourceCode;

import java.util.Comparator;

public class compareByLength implements Comparator&lt;String&gt; {
	@Override
	public int compare(String str1,String str2) {
		int temp = str2.length() - str1.length();
		return temp==0?str2.compareTo(str1):temp;
	}
}
</code></pre>
<p>**上面我们可以看出 reverseOrder() 就是万金油，不传参就是倒序排列自然排序的 List , 而传参就可以自定义我们需要的比较方法 &lt;  注意 reverseOrder 要联合 sort 使用，只有 reverse 可以单独使用 &gt; **</p>
<h2>2 将非同步集合转为同步集合</h2>]]></description>
      <author>JokerLee</author>
      <guid>https://jokeme.top/articles/2019/12/28/1577495325749.html</guid>
      <category>Java</category>
      <pubDate>Wed, 06 May 2020 00:29:37 +0800</pubDate>
    </item>
    <item>
      <title>java 泛型,必须要学好的一个基础</title>
      <link>https://jokeme.top/articles/2019/12/28/1577495553196.html</link>
      <description><![CDATA[<h1>泛型</h1>
<h2>1 泛型特性</h2>
<p>百度得如下解释：</p>
<pre><code class="language-properties">泛型是程序设计语言的一种特性,允许程序员在强类型程序设计语言中编写代码时定义一些可变部分，那些部分在使用前必须作出指明。各种程序设计语言和其编译器、运行环境对泛型的支持均不一样。将类型参数化以达到代码复用提高软件开发工作效率的一种数据类型。泛型类是引用类型，是堆对象，主要是引入了类型参数这个概念。 
</code></pre>
<h2>2. 举个栗子 ? ?</h2>
<pre><code class="language-java">List Li = new ArrayList();
Li.add("sdn");
Li.add(90);

for (Object se :Li){
	System.out.println(se);   
}
</code></pre>
<pre><code class="language-java">java.lang.ClassCastException: java.lang.Integer cannot be cast to java.lang.String
</code></pre>
<p>典型的类型转换异常，<strong>Integer</strong>不能被转换成<strong>String</strong></p>
<p>正确的写法如下：</p>
<pre><code class="language-java">List&lt;String&gt; Li = new ArrayList&lt;String&gt;();
</code></pre>
<h2>3. 泛型的使用</h2>
<p>泛型有三种使用方式，分别为：泛型类、泛型接口、泛型方法</p>
<h3>3.1  泛型类</h3>
<p>泛型类型用于类的定义中，被称为泛型类。通过泛型可以完成对一组类的操作对外开放相同的接口。最典型的就是各种容器类，如：List、Set、Map。</p>
<p>一个最普通的泛型类：</p>
<pre><code class="language-java">public class examples&lt;Human&gt;{ 
    private Human key;
    public examples(Human key) { 
        this.key = key;
    }
    public Human getKey(){ 
        return key;
    }
}
</code></pre>
<p><strong>注意事项</strong></p>
<p>泛型的类型参数只能是<strong>类</strong>类型，不能是简单类型。</p>
<p>不能对确切的泛型类型使用<strong>instanceOf</strong>操作，编译时会出错。</p>
<h3>3.2  泛型接口</h3>
<p>泛型接口与泛型类的定义及使用基本相同</p>
<pre><code class="language-java">public interface killSky&lt;Gun&gt; {
    public Gun next();
}
</code></pre>
<p>实现泛型接口的类也必须要保证该类的泛型和接口保持一致</p>
<pre><code class="language-java">class Fun&lt;Gun&gt; implements killSky&lt;Gun&gt;{
    @Override
    public Gun next() {
        return null ;
    }
}
</code></pre>
<h3>3.3 泛型通配符</h3>
<p>在写代码时可能会遇到下面的情况，通配符就会统统匹配</p>
<pre><code class="language-Java">public static void printCollection(Collection&lt;?&gt; coll) {
		for (Object obj:coll){
			System.out.println(obj);
		}
</code></pre>
<h3>3.4  泛型方法</h3>
<p>泛型类，是在实例化类的时候指明泛型的具体类型，那么泛型方法，就是在调用方法的时候指明泛型的具体类型 。</p>
<h4>3.4.1 静态方法与泛型</h4>
<p>静态方法有一种情况需要注意一下，那就是在类中的静态方法使用泛型：静态方法无法访问类上定义的泛型；如果静态方法操作的引用数据类型不确定的时候，必须要将泛型定义在方法上。</p>
<p>即：如果静态方法要使用泛型的话，必须将静态方法也定义成泛型方法 。</p>
<pre><code class="language-java">public class StaticGenerator&lt;T&gt; {
    ....
    ....
    public static &lt;T&gt; void show(T t){

    }
}
</code></pre>
<h3>3.5 泛型上下边界</h3>
<p>在使用泛型的时候，我们还可以为传入的泛型类型实参进行上下边界的限制，如：类型实参只准传入某种类型的父类或某种类型的子类。</p>
<p>为泛型添加上边界，即传入的类型实参必须是指定类型的子类型</p>
<pre><code class="language-java">public void showKeyValue1(Generic&lt;? extends Number&gt; obj){
    System.out.println(obj)
} 
public void showKeyValue1(Generic&lt;? super Number&gt; obj) {
    System.out.println(obj)
}
</code></pre>
<pre><code class="language-java">//在泛型方法中添加上下边界限制的时候，必须在权限声明与返回值之间的&lt;T&gt;上添加上下边界，即在泛型声明的时候添加
//public &lt;T&gt; T showKeyName(Generic&lt;T extends Number&gt; container)，编译器会报错："Unexpected bound"
public &lt;T extends Number&gt; T showKeyName(Generic&lt;T&gt; container){
    System.out.println("container key :" + container.getKey());
    T test = container.getKey();
    return test;
}
</code></pre>
<p>看到了很多文章中都会提起泛型数组，经过查看 sun 的说明文档，在 Java 中是”不能创建一个确切的泛型类型的数组”的。</p>
<p>也就是说下面的这个例子是不可以的：</p>
<pre><code class="language-java">List&lt;String&gt;[] ls = new ArrayList&lt;String&gt;[10];  
</code></pre>
<p>而使用通配符创建泛型数组是可以的，如下面这个例子：</p>
<pre><code class="language-java">List&lt;?&gt;[] ls = new ArrayList&lt;?&gt;[10]; 
</code></pre>
<p>这样也是可以的：</p>
<pre><code class="language-java">List&lt;String&gt;[] ls = new ArrayList[10];
</code></pre>
<p>下面使用<a href="http://docs.oracle.com/javase/tutorial/extra/generics/fineprint.html" target="_blank">Sun</a><a href="http://docs.oracle.com/javase/tutorial/extra/generics/fineprint.html" target="_blank">的一篇文档</a>的一个例子来说明这个问题：</p>]]></description>
      <author>JokerLee</author>
      <guid>https://jokeme.top/articles/2019/12/28/1577495553196.html</guid>
      <category>Java</category>
      <pubDate>Wed, 06 May 2020 00:29:21 +0800</pubDate>
    </item>
    <item>
      <title>Java IO 文件的读写与高效率IO</title>
      <link>https://jokeme.top/articles/2019/12/28/1577495753800.html</link>
      <description><![CDATA[<h1>Java-IO? Part 1</h1>
<p>Java Input-Output 主要是用于文件的存储和读取，相关操作一般都会放在 Java.io 包中</p>
<h2>1 File 类</h2>
<p>file 类的方法是我们操作文件必不可少的，是必须要学习的类</p>
<h3>1.1 使用示例：</h3>
<pre><code class="language-java">package Java_IO;

import java.io.File;
import java.io.IOException;

public class fileClass {
	public static void main(String[] args) throws IOException {
		
		File se = new File("D:\\Frelon.txt");
		File we = new File("D:\\","sda.py");
		System.out.println(se+"~~~~"+we);
		
		File dir = new File("D:\\KW"+File.separator);
		File sdCard = new File (dir,"a.java");
		if(sdCard.createNewFile()) {
			System.out.println("Create File Successfully ! "+sdCard);
		}else {
			System.out.println("Filed!");
		}
	}
}
</code></pre>
<h3>1.2 <strong>File</strong>类常见方法</h3>
<h4>1.2.1 获取文件路径</h4>
<pre><code class="language-java">package Java_IO;

import java.io.File;

public class filePath {
	public static void main(String[] args) {
		File file = new File("a.sh");
		String str = file.getAbsolutePath();
		String str1 = file.getPath();
		System.out.println(str+"~~~~~"+str1);
	}
}
​~~~~~~~~~~~~~~~~~~
D:\github\Hadoop_build\JavaLearn\a.sh~~~~~a.sh
</code></pre>
<p>getPath()只是获取相对路径 &lt; 程序在哪运行，路径就是那里 &gt;</p>
<p>getAbsolutePath()表示获取绝对路径</p>
<h4>1.2.2 获取文件修改时间</h4>
<pre><code class="language-java">package Java_IO;

import java.io.File;
import java.text.DateFormat;
import java.util.Date;

public class filePath {
	public static void main(String[] args) {
		File file = new File(".classpath");
		Long lon = file.lastModified();
		Date date = new Date(lon);
		String mod_time = DateFormat.getDateTimeInstance(DateFormat.LONG,DateFormat.LONG).format(date);
		System.out.println(lon+" &gt;&gt;&gt;&gt;&gt; "+mod_time);
	}
}
</code></pre>
<pre><code class="language-log">1575876750643 &gt;&gt;&gt;&gt;&gt; 2019年12月9日 下午03时32分30秒
</code></pre>
<p>该方法并不困难，稍稍有难度的是如何把获取到的 <strong>Long</strong> 类型的数字转化为具体的时间</p>
<pre><code class="language-java">Date date = new Date(1575876750643l);
DateFormat time = DateFormat.getDateTimeInstance(DateFormat.LONG, DateFormat.LONG);
String str = time.format(date);
System.out.println(str);
</code></pre>
<h4>1.2.3 常见操作</h4>
<pre><code class="language-Java">boolean boof = file.createNewFile();     
boolean boo  = file.canExecute();        
boolean booa = file.canRead();           
boolean bood = file.canWrite();          
boolean booh = file.exists();            
boolean booj = file.isAbsolute();        
boolean book = file.isDirectory();       
boolean bool = file.isFile();            
boolean booz = file.isHidden();          
</code></pre>
<p>认识即可，没有难度</p>
<h4>1.2.4 获取文件夹内容</h4>
<p>当操作文件夹时，肯定要知道这个文件夹里面有什么东西，我们才好操作，常用的方法有两种 <strong>list()</strong> , <strong>listFile()</strong> 但是建议用后者，因为<strong>list()</strong> 有的它也有，他有的方法**list()**没有</p>
<pre><code class="language-Java">package Java_IO;

import java.io.File;

public class visitFile {
	public static void main(String[] args) {
		File alean = new File("c:\\");
		if (alean.exists()) {
			String[] dd = alean.list();
			for (String ss : dd) {
				System.out.println(ss);
			}
System.out.println("~~~~~~~~~~~~~~~~~~~~~~");
			File[] fo = alean.listFiles();
			for (File fs : fo) {
				if(fs.getName().contains("Logs")) {
					System.out.println(fs+" ~~~ "+fs.getName());
				}
			}
System.out.println("~~~~~~~~~~~~~~~~~~~~~~");
			Long sis = alean.getFreeSpace();
			System.out.println(alean + " " + sis / Math.pow(1024, 3) + "Gb" + " free!");
		} else {
			System.out.println("No this file");
		}
	}
}
</code></pre>
<h4>1.2.5 文件过滤器</h4>
<pre><code class="language-Java">File[] str1  =  dir.listFiles(new fileFilterByName());
for (File strr : str1) {
	System.out.println(strr);
}
​~~~~
package Java_IO;

import java.io.File;
import java.io.FileFilter;

public class fileFilterByName implements FileFilter {
	@Override
	public boolean accept(File arg0) {
		return arg0.isDirectory();
	}
}
</code></pre>
<p>它可以过滤出该 ?内的 ?,还可以过滤出 ?内的 ?,只需要把 <strong>fileFilterByName</strong> の <strong>accept()</strong> 方法改一下即可</p>
<pre><code class="language-java">public boolean accept(File arg0) {
	return arg0.isDirectory();
//	return arg0.isFile();
//  return arg0.isFile();
//  return arg0.getName().endSWith(".java")
}
</code></pre>
<h5>1.2.5.1 文件名过滤器</h5>
<pre><code class="language-Java">package Java_IO;

import java.io.File;
import java.io.FilenameFilter;

public class filterByName implements FilenameFilter {
	private String se="";
	
	public filterByName(String se) {
		super();
		this.se = se;
	}
	public filterByName() {
		super();
	}
	
	@Override
	public boolean accept(File arg0, String arg1) {
		
		return arg1.endsWith(se);
	}

}
​~~~~~~~~~~~~~~~~~~~~~~
package Java_IO;

import java.io.File;

public class FileFilter {
	public static void main(String[] args) {
		File file = new File("D:\\hadoop-2.8.5");
		String[] str = file.list(new filterByName(".txt"));
		for (String name : str) {
			System.out.println(name);
		}
	}
}

</code></pre>
<p>这种过滤器不常用，因为需要一个过滤器实现<strong>FileNameFilter</strong>, 实际 coding 我们可以使用<strong>FileFilter</strong> 替代，它不仅仅可以过滤文件夹 ?还可以过滤文件 ?</p>
<h3>1.3 递归 获取 ?内的内容</h3>
<pre><code class="language-java">package Java_IO;

import java.io.File;
import java.io.IOException;
import java.nio.file.NoSuchFileException;

public class getAllFiles {

	public static void main(String[] args) throws IOException {
		File dir = new File("D:\\github");
		getAllFile(dir);
	}

	public static void getAllFile(File se) throws IOException {
		File[] dir1 = se.listFiles();
		if(!se.exists()) {
			throw new NoSuchFileException("No such Path");
		}
		for (File der : dir1) {
			if (der.isDirectory()) {
				getAllFile(der);
			} else {
				System.out.println("Visited " + der);
			}
		}
	}
}
</code></pre>
<p>什么是递归？</p>
<p>其实 递归就是在方法内部调用该方法，该方法不断地进栈，在使用递归时，一定要有判断条件，否则一直递归下去会导致内存溢出</p>
<pre><code class="language-java">public void met(){
	void show();
}

public void show(){
	void met();
}
</code></pre>
<p>这就是一种递归，但是它是错误 ❌的递归，两个方法相互调用会导致栈内存溢出，</p>
<pre><code class="language-java">public void show(){
	void show();
}
</code></pre>
<p>这也是一种错误 ❌的递归，方法内部无线调用自己 ✌会导致栈内存溢出</p>
<h4>1.3.1 使用递归删除 ?</h4>
<pre><code class="language-java">package Java_IO;

import java.io.File;
import java.nio.file.NoSuchFileException;

public class deleteFiles {
	public static void main(String[] args) throws NoSuchFileException {
		File dir = new File("D:\\KWS");
		removeFiles(dir);
	}
	public static void removeFiles(File se) throws NoSuchFileException {
		File [] wow = se.listFiles();
		for(File wo : wow) {
			if(!wo.exists()) {
				throw new NoSuchFileException(null);
			}
			if(wo.isDirectory()) {
				removeFiles(wo);
			}else {
				Boolean esc = wo.delete();
				System.out.println("delete the file "+wo+" "+esc);
			}
		}
		Boolean esc = se.delete();
		System.out.println("delete the file "+se+" "+esc);
	}
}
</code></pre>
<p>递归删除很简单，只是需要注意，这个删除是不经过回收站的，会被直接删除，不可找回</p>
<p>还有就是需要判断该 ?有没有权限访问，要不然会报 <strong>java.lang.NullPointerException</strong> 异常，甚至还需要我们自己来抛一些 <strong>IO</strong> 异常</p>
<h3>1.4 前三 part 测试</h3>
<p>需求：</p>
<pre><code>获取某个?内所有文件的集合
获取该?内某个?内的.txt文件,并存储到集合中打印?出来
</code></pre>
<pre><code class="language-java">package Java_IO;

import java.io.File;
import java.io.FilenameFilter;
import java.util.ArrayList;
import java.util.List;

public class IO_Test1 {
	public static void main(String[] args) {
		File dir = new File("c:\\tempfile");

		List&lt;String&gt; list = new ArrayList&lt;String&gt;();

		fileFilterByName filter = new fileFilterByName(".txt");

		getFile(dir, filter, list);

		for (String ser : list) {
			System.out.println(ser);
		}
	}

	private static void getFile(File file, fileFilterByName filter, List&lt;String&gt; list) {
		File[] fileName = file.listFiles();
		for (File se : fileName) {
			if (se.isDirectory()) {
				getFile(se, filter, list);
			} else {
				if (filter.accept(se)) {
					list.add(se.getPath());
				}
			}
		}
	}
}
​~~~~~~~~~~~~~~~~~~~~
package Java_IO;

import java.io.File;
import java.io.FileFilter;

public class fileFilterByName implements FileFilter {
	private String str;
    
	public fileFilterByName(String str) {
		super();
		this.str = str;
	}
    
	public fileFilterByName() {
		super();
	}
	
	
	@Override
	public boolean accept(File arg0) {
		return arg0.getName().endsWith(this.str);
	}

}
</code></pre>
<p>给自己点个赞 ?,我真厉害?</p>
<h2>2 FileOutputStream 向 ?内写入内容</h2>
<pre><code class="language-java">package Java_IO;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;

public class writeIntoFile {
	private static final String Line_separator = System.getProperty("line.separator");

	public static void main(String[] args) throws IOException {
		File dir = new File("c:\\tempfile");
		if(!dir.exists()) {
			dir.mkdir();
		}
		String str ="i Love Java";
		FileOutputStream fops = null;
		try {
			fops = new FileOutputStream("c:\\tempfile\\fops.java",true);
			String ssr = Line_separator+"Hello World"+Line_separator;
			fops.write(ssr.getBytes());
			fops.write(str.getBytes());
			fops.write(ssr.getBytes());
			System.out.println("写入成功");
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
			if(fops!=null) {}
			fops.close();
		}
	}
}
</code></pre>
<p>写入内容很容易，只需要调用一下<strong>write()<strong>方法即可，但是难点就是处理各种</strong>Exception</strong> ,我们需要考虑到各种各样的异常</p>
<p>比如 FileNotFoundException,,,NullPointerException 等等等， 因为一旦出现了这些问题我们的代码可能就占用了相关的系统资源，但是程序执行失败后，我们并没有释放该资源，如此循环往复就会导致系统的卡慢，甚至死机重启，这里我们经常使用<strong>try catch finally</strong> 方法来解决，需要执行的代码放在<strong>try</strong> 里面，在<strong>finally</strong> 里面放 <strong>close()<strong>方法，保证我们的代码在申请完资源以后，无论是否报错，都可以被释放掉，还有一点就是如果我们使用</strong>try catch finally</strong> 那我们一定不能在<strong>try</strong>里面 <strong>new</strong> 对象，因为到时候<strong>finally</strong> 关闭资源时会<strong>找不到对象</strong> ?的</p>
<p>还有<strong>write()</strong> 方法是会覆盖掉文件内部的内容的，如果我们需要在当前内容上继续添加内容，那就需要在创建对象时加一个<strong>true</strong> 表示续写该文件，代码如下</p>
<pre><code class="language-java">FileOutputStream fops = new FileOutputStream("c:\\tempfile\\fops.java",true);
</code></pre>
<h2>3 FileInputStream 读取 ?内容</h2>
<p>FileInputStream 类和 FileOutputStream 类有许多的共同点，都需要传一个 File 类的对象(new 对象时要保证 Path✔无误，要不然很容易造成空指针异常) 还有就是在使用完资源以后要及时释放掉资源，还有要注意的是异常の处理，如果没有处理好异常也会导致我们无法释放掉资源，导致程序占用过多的系统资源，使系统卡慢</p>
<h3>3.1❌ read() 入门级读取</h3>
<pre><code class="language-java">package Java_IO;

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;

public class readFile {
	private static final int LIMSize = 8192;

	public static void main(String[] args) throws IOException {
		File dir = new File("c:\\tempfile\\fops.java");

		FileInputStream fipts = new FileInputStream(dir);

		int byt;
		while ((byt = fipts.read()) != -1) {
			System.out.println(byt);
		}

		fipts.close();
	}
}        
</code></pre>
<p>日常开发中，基本上用不上 PASS ❌</p>
<h3>3.2❌ read() 初级读取</h3>
<pre><code class="language-java">package Java_IO;

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;

public class readFile {
	private static final int LIMSize = 8192;

	public static void main(String[] args) throws IOException {
		File dir = new File("c:\\tempfile\\fops.java");
		byte[] buf = new byte[2];

		FileInputStream fip = new FileInputStream(dir);

		int len = fip.read(buf);
		System.out.println(len + "~~~" + new String(buf));

		fip.close();
	}
}            
</code></pre>
<p>日常开发中，基本上用不上 PASS ❌</p>
<h3>3.3 ✔ read() 进阶级读取</h3>
<pre><code class="language-java">package Java_IO;

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;

public class readFile {
	private static final int LIMSize = 8192;

	public static void main(String[] args) throws IOException {
		File dir = new File("c:\\tempfile\\fops.java");
				FileInputStream fips = new FileInputStream(dir);
		byte[] by = new byte[LIMSize];

		int length = 0;

		while ((length = fips.read(by)) != -1) {
			System.out.println(new String(by, 0, length));
		}
		fips.close();

	}
}
</code></pre>
<p>日常开发中可以使用，✔建议根据需要改变缓冲区的大小，一般建议设置成 :8192</p>
<h3>3.4 ✔ read()高级读取</h3>
<pre><code class="language-java">package Java_IO;

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;

public class readFileAdvantage {
	public static void main(String[] args) throws IOException {
		File dir = new File("c:\\tempfile\\fops.java");
		FileInputStream fips = new FileInputStream(dir);
		byte [] byt = new byte [fips.available()];
		fips.read(byt);
		System.out.println(new String(byt));
		fips.close();
	}
}
</code></pre>
<p>✔这种是我比较喜欢的一种方法，简洁好用，也不用考虑缓冲区大小 ?,而且一般 File 对象没有问题也就不会出错啊(相对于前面几个),这是重点 ✔,圈起来！下次会考！!!</p>
<p>但是！!但是！!但是！ 这种方法只是比较适合处理比较小的文件，如果处理好几个 G 的文件，当场挂..所以呢，还是 进阶 和 高级 一起用</p>
<h2>4 FileOutputStream 和 FileInputStream 一起读写文件</h2>
<h3>4.1 低级写法</h3>
<pre><code class="language-java">package Java_IO;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;

public class IO_CopyFile {

	public static void main(String[] args) throws IOException {
		File dir = new File("C:\\tempfile\\fops.java");
		FileInputStream fis = new FileInputStream(dir);

		File dir1 = new File("C:\\tempfile\\fops.txt");
		FileOutputStream fos = new FileOutputStream(dir1);
		int len = 0;
		while ((len = fis.read()) != -1) {
			fos.write(len);
		}
		fis.close();
		fos.close();
	}
}
</code></pre>
<p>不推荐这种写法，因为效率比较低，读取一个写入一个，太浪费时间</p>
<h3>4.2 高级写法</h3>
<pre><code class="language-java">package Java_IO;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;

import APICourceCode.dateAPI;

public class copyFileByBuf {
	public static void main(String[] args) throws IOException {
		dateAPI date = new dateAPI();
		date.getDate();
		File dir = new File("d:\\tempfile\\idea.exe");
		FileOutputStream fos = null;
		FileInputStream fis = null;
		try {
			fis = new FileInputStream(dir);
			fos = new FileOutputStream("d:\\tempfile\\idea.wilu");

			byte[] buf = new byte[10240];

			int len = 0;
			while ((len = fis.read(buf)) != -1) {
				fos.write(buf, 0, len);
			}
		} catch (IOException e) {
			throw new IOException();
		} finally {
			fis.close();
			fos.close();
			date.getDate();
			System.out.println("Copy Over");
		}

	}
}

</code></pre>
<p>我无聊就试了试，这个<strong>byte</strong> 数组の长度对<strong>IO</strong> の性能影响有多大，就把长度从 10,102,1024,2048,4096,8192,10240 都试了个遍，得出以下答案：</p>
<table>
<thead>
<tr><th align="center">时间\byte 长度</th><th align="center">10</th><th align="center">102</th><th align="center">1024</th><th align="center">2048</th><th align="center">4096</th><th align="center">8192</th><th align="center">10240</th><th align="center">20480</th></tr>
</thead>
<tbody>
<tr><td align="center">Start</td><td align="center">19:38:27</td><td align="center">19:53:42</td><td align="center">19:54:52</td><td align="center">19:55:50</td><td align="center">19:56:25</td><td align="center">19:57:05</td><td align="center">19:57:40</td><td align="center">19:58:16</td></tr>
<tr><td align="center">Stop</td><td align="center">19:44:33</td><td align="center">19:54:19</td><td align="center">19:54:57</td><td align="center">19:55:54</td><td align="center">19:56:28</td><td align="center">19:57:08</td><td align="center">19:57:42</td><td align="center">19:58:18</td></tr>
<tr><td align="center">time</td><td align="center">366s</td><td align="center">37s</td><td align="center">5s</td><td align="center">4s</td><td align="center">3s</td><td align="center">3s</td><td align="center">2s</td><td align="center">2s</td></tr>
</tbody>
</table>
<p>测试所使用的文件大小为： 584935KB 大约是 571MB</p>
<p>可以看出 byte 数组的长度也是越大越好的，只要你内存足够大，磁盘性能足够强，理论上是可以做到一秒内复制任何文件的，可是！! 科技日益发达的今天电脑内存和磁盘还依然是一个瓶颈，有待我们突破啊，So 为了适应各种大小的文件，还是选择大小为<strong>8192</strong> 或者<strong>10240</strong> 也是可以的</p>
<h2>5 Buffer 缓冲区</h2>
<p>buffer 原理就是调用一片内存，作为缓冲区，然后再为 FileInput/OutputStream 使用，原理和上面的相似</p>
<h3>5.1 使用示例</h3>
<pre><code class="language-java">package Java_IO;

import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;

public class buffer {
	public static void main(String[] args) throws IOException {
				copyfile();
	}
	public static void copyfile() throws IOException {
		File dir  = new File("d:\\LinuxSoftware_VariedOS\\Python-3.8.0.tgz");
		
		FileInputStream pis = new FileInputStream(dir);
		FileOutputStream pos = new FileOutputStream("d:\\tempfile\\Python.wilu");
		
		BufferedInputStream bufpis = new BufferedInputStream(pis);
		BufferedOutputStream bufpos = new BufferedOutputStream(pos);
		
		byte [] buf = new byte[8192];
		int len = 0;
		while((len=bufpis.read(buf))!=-1) {
			bufpos.write(buf,0,len);
		}
		bufpis.close();
		bufpos.close();
		System.out.println("Copy over");
	}  
}
</code></pre>
<h2>6 字符读写</h2>
<h3>6.1 使用 I/O-Stream-Reader/Writer</h3>
<p>由于中文一个字符占两字节，所以我们不能像读写英文那样，直接操作数据了，</p>
<pre><code class="language-java">package Java_IO;

import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;

public class StreamReader {
	public static void main(String[] args) throws IOException {
		FileInputStream fis = new FileInputStream("D:\\tempfile\\fpos.java");
		FileOutputStream fos = new FileOutputStream("D:\\tempfile\\pofs.c",true);
		
		InputStreamReader isr = new InputStreamReader(fis);
		OutputStreamWriter osw = new OutputStreamWriter(fos,"utf-8");
		
		int in ;
		while((in = isr.read()) != -1) {
			osw.write(in);
		}
		
		isr.close();
		osw.close();
		System.out.println("Copy over");
	}
}
</code></pre>
<p>中文处理时比较的麻烦，因为各种电脑支持的编码可能不一样，就导致乱码问题，这时候我们在<strong>new</strong> 对象的时候就需要指定我们所需要的编码方式，今天就因为编码就倒腾了半天的时间 ⏰</p>
<p>所以为了保险起见，在创建 <strong>FileOutputStream</strong> 的时候还是加上 <strong>UTF-8</strong> 好一点</p>
<h3>6.2 FileReader/FileWriter 类</h3>
<p><strong>FileReader/FileWriter</strong> 其实就是简化了<strong>FileOutputStream</strong> ＆ <strong>FileOutputStream</strong> の 使用过程，但是缺点( •̀ ω •́ )y 非常明显，就是不支持设置编码方式，默认的是 <strong>ISO-8859-1 or US-ASCII</strong> ,非常容易导致乱码 ~%?…,# *'☆&amp;℃ $︿★?</p>
<p>处理乱码也不难，就是不用这个类 ?</p>
<p>way 1</p>
<pre><code class="language-java">BufferedWriter writer = new BufferedWriter (new OutputStreamWriter (new FileOutputStream (filePath,true),"UTF-8"));
</code></pre>
<p>虽然这也是一种解决办法吧，但是如果一点要用的话那就只能用下面这种方法了</p>
<p>way 2</p>
<pre><code class="language-java">Writer writer = new BufferedWriter(new OutputStreamWriter(new FileOutputStream ("String"), "UTF-8"));
</code></pre>
<p>让<strong>FileWriter</strong> 继承 <strong>Write</strong> の 编码方式，不过也不好用</p>
<h4>6.2.1 FileReader /  FileWrite 初级写法</h4>
<pre><code class="language-java">package Java_IO;

import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.OutputStreamWriter;

public class fileWriter {
	public static void main(String[] args) throws IOException {
		FileOutputStream fos = new FileOutputStream("D:\\tempfile\\pofs.c");
		OutputStreamWriter osw = new OutputStreamWriter(fos,"UTF-8");
		
		FileReader fr = new FileReader("D:\\tempfile\\fpos.java");
		FileWriter fw = new FileWriter("D:\\tempfile\\pofs.c");
		
		int in;
		while((in=fr.read())!=-1) {
			fw.write((char)in);
		}
		fr.close();
		System.out.println(fw.getEncoding());
		fw.close();
		osw.close();
		System.out.println("Copy over");
	}
}
</code></pre>
<h4>6.2.2 FileReader /  FileWrite 高级写法</h4>
<pre><code class="language-java">package Java_IO;

import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;

public class IO_SimplifyChinese {
	public static void main(String[] args) throws IOException {
		copyChineseChar();
	}
	public static void copyChineseChar() throws IOException {
		FileReader fr = new FileReader("D:\\LinuxSoftware_VariedOS\\jdk-8u231-linux-x64.tar.gz");
		FileWriter fw = new FileWriter("D:\\tempfile\\jdk8.wuli");
		
		char [] chara = new char[2048];
		int len ;
		while ((len=fr.read(chara))!= -1) {
			fw.write(chara,0,len);
		}
		fr.close();
		fw.close();
		System.out.println("copy over");
	}
}
</code></pre>
<h3>6.3 BufferedReader / BufferedWriter</h3>
<p>主要是利用缓冲区来提高读写效率，也没有啥难处，会用就可以了</p>
<pre><code class="language-java">package Java_IO;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;

public class Buffered_IO {
	public static void main(String[] args) throws IOException {
		buff();
	}
	public static void buff() throws IOException {
		FileReader fr = new FileReader("D:\\tempfile\\fos.java");
		BufferedReader br = new BufferedReader(fr);
		
		FileWriter fw = new FileWriter("D:\\tempfile\\copyed_fos.wuli");
		BufferedWriter bw = new BufferedWriter(fw);
		
		char [] chara = new char[2048];
		
		int in ;
		while((in=fr.read(chara))!= -1) {
			bw.write(chara,0,in);
		}
		br.close();
		bw.close();
		System.out.println("Copy over");
	}
}

</code></pre>
<h2>Final	写在最后：</h2>
<p>在经过学习后，我发现字节流和字符流都用于复制文件，但字符流的出现主要是为了解决与字符相关的问题，所以不适合复制文件(编码原因),字符流复制文件时可能会出现莫名其妙的问题导致复制后的文件破损无法使用，但字节流就不存在这种问题所以得出</p>
<pre><code class="language-properties">复制文件时使用字节流:复制文本文件时使用字符流
</code></pre>]]></description>
      <author>JokerLee</author>
      <guid>https://jokeme.top/articles/2019/12/28/1577495753800.html</guid>
      <category>Java</category>
      <pubDate>Wed, 06 May 2020 00:29:06 +0800</pubDate>
    </item>
    <item>
      <title>微信小程序遇到的坑</title>
      <link>https://jokeme.top/articles/2020/01/10/1578626602884.html</link>
      <description><![CDATA[<h1>微信小程序遇到的坑</h1>
<p>微信小程序其实很简单，和 <strong>HTML</strong> 差不多，但是又加入了微信的很多特色，我也是本着写着玩的心态写了几天的小程序，发现有很多坑哦，和 <strong>HTML</strong>还是有点差距的</p>
<h2>1 文本超出隐藏并加…</h2>
<p>其实在 HTML 里面这段代码很简单，只要在父元素里面定义</p>
<pre><code class="language-css">overflow:hidden;
text-overflow: ellipsis;
white-space: nowrap;
</code></pre>
<p>但是微信小程序就邪了门了，在电脑上看的好好的，可到了真机预览就失效了，</p>
<p>而且还只是 iOS 平台出现问题，Android 并没有问题，这就见鬼了吗！!同样的代码，还能有不同疗效的？??</p>
<h3>1.1 Answer :</h3>
<p>然后百度，得答案：子元素还必须是 <strong>text</strong> 元素才会生效，这是因为 iOS 的 <strong>Safari</strong> 浏览器的特立独行吧，</p>
<p>还有的说需要设置一下宽度就可以解决，反正这个方法我没有试，懒得试</p>
<h2>2 background-attachment:fixed</h2>
<p>这个属性是用来设置背景图的，但是还是在 <strong>iOS</strong> 这里出现了问题，反观 <strong>Android</strong> 那边一切都很正常 ?</p>
<p>本来固定背景图片就是一个常用的功能，但是 <strong>iOS</strong> 这边就是死活不兼容这个属性，一开始我这样写，出错了我还以为是我自己の问题，在哪里倒腾了大半天，无果，百度发现这是一个很普遍的现象，那些大神解决问题的方式倒也很直接，不用这个属性，自己在写一个 <strong>view</strong> 放在最下面一层</p>
<h3>2.1 Answer :</h3>
<pre><code class="language-css">  position:fixed;
  top:0;
  left:0;
  width:100%;
  height:100%;
  background:url('http://172.17.150.251:8080/pic/bk7.jpg') no-repeat #000;
  background-size:cover;
  z-index:-1;
</code></pre>
<h2>3 wx : for</h2>
<pre><code class="language-html">&lt;view class="acf" wx:for="{{heloi}}" wx:key="index"&gt;
		&lt;view class="bhk" data-arturl="{{item.article}}" bindtap="showNextPage"&gt;
			&lt;div class="guli"&gt;&lt;text class="intro"&gt;{{item.introduce}}&lt;/text&gt;&lt;/div&gt;
			&lt;div class="ddas"&gt;
				&lt;image class="pic" src='{{item.picurl}}'&gt;&lt;/image&gt;
			&lt;/div&gt;
		&lt;/view&gt;
	&lt;/view&gt;
</code></pre>
<pre><code class="language-javascript">  onLoad: function () {
    var _self = this
    wx.request({
      url: "http://172.17.150.251:8080/as.json",
      success: function (qum) {
        _self.setData({
          heloi: qum.data.page,
        })
      }
    })
  },
</code></pre>
<p>wx:for 用来解析服务器返回的 <strong>JSON</strong> 是真的很棒的，可以一键迭代生成很多的内容</p>
<h2>4 不同页面间传参</h2>
<p>这是困扰我最长时间的一个问题了，因为不太熟悉小程序，只能看别人怎么写，我就跟着这样写，毫无灵魂，也上网百度了，都是看的一知半解，就目前而言，我还不是特别会页面间的传参，但是，还是可以写出来点东西的</p>
<p>上代码：</p>
<pre><code class="language-html">&lt;view class="bhk" data-arturl="{{item.article}}" bindtap="showNextPage"&gt;LOL?&lt;/view&gt;
</code></pre>
<p>不知道为什么这个 <strong>data-arturl</strong> 必须要和 <strong>bindtap</strong> 一起才可以读取到数据，如果把 <strong>bingtap</strong> 定义在 <strong>data-arturl</strong> 上面，我怎么样都拿不到数据，实在是搞不懂啥原因 ?</p>
<pre><code class="language-javascript">showNextPage: function (event) {
  var url = event.currentTarget.dataset.arturl
  console.log(url)
  wx.navigateTo({
    url: "/pages/aitrcle/aitrcle?url="+url,
    success: function () { 
      console.log("Success! Congratulate!")
    },
    fail: function () { console.log("faild!!!") },
  })
}
</code></pre>
<p>下面是 <strong>article</strong> 的 <strong>js</strong></p>
<pre><code class="language-javascript">onLoad: function (options) {
    var that = this
    that.data.paurl =options.url
    console.log(that.data.paurl)

    wx.request({
      url:that.data.paurl,
      success:function(){
        console.log("Yes! U did")
      },
      false:function(){
        console.log("false")
      }
    })
  }
</code></pre>
<p>我只会这种简单的页面传参，还有别的传参方法，比如：</p>
<pre><code class="language-log">使用数据库传递数据,

全局变量使用方法

使用缓存传递参数,使用组件模板 template传递参数
</code></pre>
<h2>5 小程序页面跳转</h2>
<p>常见的有四种方法</p>
<table>
<thead>
<tr><th align="center">wx.navigateTo({})</th><th align="center">保留当前页面，跳转到应用内的某个页面，使用 wx.navigateBack 可以返回;</th></tr>
</thead>
<tbody>
<tr><td align="center"><strong>wx.redirectTo()</strong></td><td align="center"><strong>关闭当前页面，跳转到非 tabBar 的某个页面</strong></td></tr>
<tr><td align="center">**<navigator> <strong>|</strong><navigator url="../test/test"> 点击跳转 </navigator> **</navigator></td></tr>
<tr><td align="center"><strong>wx.switchTab</strong></td><td align="center"><strong>跳转到 tabBar 的某个页面</strong></td></tr>
</tbody>
</table>
<p>举个例子 ?</p>
<pre><code class="language-javascript">wx.navigateTo({
	url:'../test/test?id=1&amp;page=4',  //跳转页面的路径，可带参数 ？隔开，不同参数用 &amp; 分隔；相对路径，不需要.wxml后缀
	success:function(){}        //成功后的回调；
	fail：function(){}          //失败后的回调；
	complete：function(){}      //结束后的回调(成功，失败都会执行)
})
 
//传递的参数在接收页面onLoad()函数中得到值：option.id就可以得到了
onLoad: function (option) {
	console.log(option)//可以打印一下option看查看参数
	this.setData({
		id:option.id,
});
</code></pre>
<p>这大概就是这几天踩得坑，虽然都不难，但是对于我们这种初学者还是有一点难度的 ?,暂时就更新到这里，过几天遇到了坑，再继续更新</p>]]></description>
      <author>JokerLee</author>
      <guid>https://jokeme.top/articles/2020/01/10/1578626602884.html</guid>
      <category>WeChat</category>
      <pubDate>Wed, 06 May 2020 00:28:25 +0800</pubDate>
    </item>
    <item>
      <title>vim 格式化代码</title>
      <link>https://jokeme.top/articles/2020/02/01/1580546067262.html</link>
      <description><![CDATA[<p>(1) 按两下 gg，定位光标到第一行。<br>
(2) 按住 Shift+v，进入可视化编辑的列编辑模式。<br>
(3) Shift+g，选中整个代码。<br>
(4) 按下等号 =，格式化所有代码。<br>
(5)❤️️ 新年快乐 ?</p>]]></description>
      <author>JokerLee</author>
      <guid>https://jokeme.top/articles/2020/02/01/1580546067262.html</guid>
      <category>Linux</category>
      <pubDate>Wed, 06 May 2020 00:27:28 +0800</pubDate>
    </item>
    <item>
      <title>Java jdbc操作MySQL</title>
      <link>https://jokeme.top/articles/2020/02/01/1580555730319.html</link>
      <description><![CDATA[<h1>Java JDBC 操作 MySQL</h1>
<h2>1 . Maven 导包</h2>
<pre><code class="language-xml">&lt;dependency&gt;
	&lt;groupId&gt;mysql&lt;/groupId&gt;
	&lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
	&lt;version&gt;5.1.48&lt;/version&gt;
&lt;/dependency&gt;
	&lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt;
	&lt;artifactId&gt;junit-jupiter&lt;/artifactId&gt;
	&lt;version&gt;RELEASE&lt;/version&gt;
    &lt;scope&gt;compile&lt;/scope&gt;
&lt;/dependency&gt;
</code></pre>
<p>填在 pom 文件里面即可，无难度</p>
<h2>2 . 用代码连接数据库</h2>
<pre><code class="language-java">import java.io.*;
import java.sql.*;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class Fre{
    public static final String driver = "com.mysql.jdbc.Driver";
    public static final String uri = "jdbc:mysql://127.0.0.1:3306/solo";
    public static final String user = "root";
    public static final String passcode = "123456";
    final String sqlScript = "select * from b3_solo_article";
    Connection connection= null;

    public ResultSet StartCollection() throws SQLException {
        try{
            Class.forName(driver);
            connection = DriverManager.getConnection(uri,user,passcode);
            if(!connection.isClosed())
                System.out.println("connection successfully");
            Statement statement = connection.createStatement();
            ResultSet replyString = statement.executeQuery(sqlScript);
            return replyString;
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
            return null;
        }
    }

    public static String toTheJson(List&lt;Map&gt; list){
        return list.toString().replace("{", "{\"").replace("}", "\"}").replace("=","\":\"").replace(", ", "\",\"").replace("}\",\"{", "},{").replace("{", "{\"").replace("}", "\"}").replace("=","\":\"").replace(", ", "\",\"").replace("}\",\"{", "},{").replace("\"\"","\"");
    }

    public void close(){
        try{

            this.connection.close();
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }
   @Test
   public void Solomon() throws SQLException, IOException {
       Map&lt;String,Object&gt; outer = new HashMap&lt;String, Object&gt;();
       List&lt;Map&gt; list = new ArrayList&lt;Map&gt;();
       Fre solo = new Fre();
       ResultSet so  = solo.StartCollection();
       while(so.next()){
           Map&lt;String,Object&gt;  map = new HashMap&lt;String, Object&gt;();
           map.put("User_ID",so.getString(1));
           map.put("User_Name",so.getString(2));
           map.put("User_Mod",so.getString(3));
           map.put("User_IDE",so.getString(4));
           list.add(map);
       }
       String Solo = toJson(list);
       System.out.println(Solo);
       FileOutputStream fos = new FileOutputStream("solo.json",true);
       OutputStreamWriter osw = new OutputStreamWriter(fos,"utf-8");
       osw.write(Solo);
       System.out.println("Write Over");
       osw.close();
   		}
    }
}
</code></pre>
<h2>3 . 代码详解</h2>
<pre><code class="language-Java">public static final String driver = "com.mysql.jdbc.Driver";
public static final String uri = "jdbc:mysql://127.0.0.1:3306/solo";
public static final String user = "root";
public static final String passcode = "123456";
final String sqlScript = "select * from b3_solo_article";
Connection connection= null;
</code></pre>
<p>在定义这些常量的时候，最好不要直接定义 <strong>String</strong> ,而是 <strong>public static final String</strong> ,怎么安全，怎么来</p>
<p>而且对象尽量不要在方法里面 <strong>new</strong> ,如果发生异常就不能释放系统资源了</p>
<hr>
<pre><code class="language-java">public ResultSet StartCollection() throws SQLException {
        try{
            Class.forName(driver);
            connection = DriverManager.getConnection(uri,user,passcode);
            if(!connection.isClosed())
                System.out.println("connection successfully");
            Statement statement = connection.createStatement();
            ResultSet replyString = statement.executeQuery(sqlScript);
            return replyString;
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
            return null;
        }
}
</code></pre>
<p>如果从安全角度来考虑的话，那么我们不应该用 <strong>Statement</strong> 而是用 <strong>PreparedStatement</strong> ,我在自己电脑上也不怕什么 <strong>SQL</strong>注入，所以没有用</p>
<hr>
<pre><code class="language-java">public static String toTheJson(List&lt;Map&gt; list){
        return list.toString().replace("{", "{\"").replace("}", "\"}").replace("=","\":\"").replace(", ", "\",\"").replace("}\",\"{", "},{").replace("{", "{\"").replace("}", "\"}").replace("=","\":\"").replace(", ", "\",\"").replace("}\",\"{", "},{").replace("\"\"","\"");
    }
</code></pre>
<p>主要是我没有导 <strong>JSON</strong> 相关的库，就这样简化 <strong>List&lt;Map&lt;String,String&gt;&gt;</strong>   &gt;&gt;&gt;   <strong>JSON</strong> 主要就是字符串的替换，还有转义可能有点懵 ?,小心即可</p>
<hr>
<pre><code class="language-java">public void close(){
        try{

            this.connection.close();
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }
</code></pre>
<p>使用完资源以后肯定也要释放的，没有什么好说的</p>
<hr>
<pre><code class="language-java">@Test
public void Solomon() throws SQLException, IOException {
       Map&lt;String,Object&gt; outer = new HashMap&lt;String, Object&gt;();
       List&lt;Map&gt; list = new ArrayList&lt;Map&gt;();
       Fre solo = new Fre();
       ResultSet so  = solo.StartCollection();
       while(so.next()){
           Map&lt;String,Object&gt;  map = new HashMap&lt;String, Object&gt;();
           map.put("User_ID",so.getString(1));
           map.put("User_Name",so.getString(2));
           map.put("User_Mod",so.getString(3));
           map.put("User_IDE",so.getString(4));
           list.add(map);
       }
       String Solo = toTheJson(list);
       System.out.println(Solo);
       FileOutputStream fos = new FileOutputStream("solo.json",true);
       OutputStreamWriter osw = new OutputStreamWriter(fos,"utf-8");
       osw.write(Solo);
       System.out.println("Write Over");
       osw.close();
   		}
}
</code></pre>
<p>写完先测试一下</p>]]></description>
      <author>JokerLee</author>
      <guid>https://jokeme.top/articles/2020/02/01/1580555730319.html</guid>
      <category>Java</category>
      <pubDate>Wed, 06 May 2020 00:27:16 +0800</pubDate>
    </item>
    <item>
      <title>Java 注解（Annotation）</title>
      <link>https://jokeme.top/articles/2020/02/01/1580556355859.html</link>
      <description><![CDATA[<h1>Java 注解（Annotation）</h1>
<p>Java 注解其实并不难，从名字上你都知道注解是帮助 Java 代码执行的，它的形式跟接口很类似，不过前面多了一个 @ 符号</p>
<h2>1 Java 元注解</h2>
<ul>
<li>
<p>@Retention</p>
<p>Retention 保留期，决定注解的生命时常，取值如下</p>
<table>
<thead>
<tr><th align="center">SOURCE</th><th align="center">只在源码阶段保留</th></tr>
</thead>
<tbody>
<tr><td align="center"><strong>CLASS</strong></td><td align="center"><strong>只被保留到编译进行的时候</strong></td></tr>
<tr><td align="center"><strong>RUNTIME</strong></td><td align="center"><strong>注解可以保留到程序运行的时候</strong></td></tr>
</tbody>
</table>
<p>eg：该注解被保留到运行时</p>
<pre><code class="language-java">@Retention(RetentionPolicy.RUNTIME)
public @interface Annotation {
}
</code></pre>
<hr>
</li>
<li>
<p>@Documented</p>
<p>它的作用是能够将注解中的元素包含到 Javadoc 中去</p>
<hr>
</li>
<li>
<p>@Target</p>
<p>Target 指定了注解运用的地方</p>
<table>
<thead>
<tr><th align="center"><strong>ANNOTATION_TYPE</strong></th><th align="center"><strong>给一个注解进行注解</strong></th></tr>
</thead>
<tbody>
<tr><td align="center"><strong>CONSTRUCTOR</strong></td><td align="center"><strong>给构造方法进行注解</strong></td></tr>
<tr><td align="center"><strong>FIELD</strong></td><td align="center"><strong>给属性进行注解</strong></td></tr>
<tr><td align="center"><strong>LOCAL_VARIABLE</strong></td><td align="center"><strong>给局部变量进行注解</strong></td></tr>
<tr><td align="center"><strong>METHOD</strong></td><td align="center"><strong>给方法进行注解</strong></td></tr>
<tr><td align="center"><strong>PACKAGE</strong></td><td align="center"><strong>给包进行注解</strong></td></tr>
<tr><td align="center"><strong>PARAMETER</strong></td><td align="center"><strong>给方法内的参数进行注解</strong></td></tr>
<tr><td align="center"><strong>TYPE</strong></td><td align="center"><strong>给一个类型进行注解，比如类、接口</strong></td></tr>
</tbody>
</table>
<hr>
</li>
<li>
<p>@Inherited</p>
<p>一个类被 @Inherited 注解过的注解进行注解的话，如果它的子类没有被任何注解应用的话，那么这个子类就继承了该类的注解。</p>
<hr>
</li>
<li>
<p>@Repeatable</p>
</li>
</ul>
<p>是可重复的意思</p>
<h2>2 Java 内置注解</h2>
<ul>
<li>@Deprecated<br>
这个元素是用来标记过时的元素</li>
<li>@Override<br>
子类要复写父类中的方法</li>
<li>@SuppressWarnings<br>
忽略编辑器的警告 ⚠</li>
<li>@SafeVarargs<br>
参数安全类型注解。它的目的是提醒开发者不要用参数做一些不安全的操作，<br>
它的存在会阻止编译器产生 unchecked 这样的警告。</li>
<li>@FunctionalInterface<br>
函数式接口注解，函数式接口可以很容易转换为 Lambda 表达式</li>
</ul>
<h2>3 注解与反射。</h2>
<p>注解通过反射获取。首先可以通过 Class 对象的 isAnnotationPresent() 方法判断它是否应用了某个注解</p>
<pre><code class="language-java">public boolean isAnnotationPresent(Class&lt;? extends Annotation&gt; annotationClass) {}
</code></pre>
<p>然后通过 getAnnotation() 方法来获取 Annotation 对象。</p>
<pre><code class="language-java">public &lt;A extends Annotation&gt; A getAnnotation(Class&lt;A&gt; annotationClass) {}
</code></pre>
<p>或者是 getAnnotations() 方法。</p>
<pre><code class="language-java">public Annotation[] getAnnotations() {}
</code></pre>
<p>前一种方法返回指定类型的注解，后一种方法返回注解到这个元素上的所有注解。</p>
<p>如果获取到的 Annotation 如果不为 null，则就可以调用它们的属性方法了</p>
<h2>4 注解应用实例</h2>
<p><strong>JUnit</strong></p>
<pre><code class="language-java">public class JUnitTest {
    @Test
    public void solo(){
        System.out.println("Awesome Junit");
    }
}
</code></pre>]]></description>
      <author>JokerLee</author>
      <guid>https://jokeme.top/articles/2020/02/01/1580556355859.html</guid>
      <category>Java</category>
      <pubDate>Wed, 06 May 2020 00:26:59 +0800</pubDate>
    </item>
    <item>
      <title>Bay Trail主板安装Linux的坑</title>
      <link>https://jokeme.top/articles/2020/03/16/1584344826236.html</link>
      <description><![CDATA[<h1>Bay Trail 主板安装 Linux 的坑</h1>
<p>最近搞了一个 <strong>N2920</strong> 的低功耗小主机，本来打算搞软路由，但是家里网速不行，就打算先刷个 <strong>Linux</strong> 玩玩，于是我就被这个问题烦了将近半个月！</p>
<p>一开始我打算安装一个 <strong>CentOS 7</strong> 玩玩，当我下载完系统刻录完开始安装的时候发现 <strong>CentOS 7</strong> 的 installer 异常的卡顿，而且耗时也非常的多，差不多需要将近半个小时才可以到图形界面的安装(我这个小主机是有固态的，这个速度肯定有很大的问题),而且好不容易到了图形界面的安装环节，还经常卡死！刚开始 我还以为可能是这个 ISO 镜像有问题，又换了一个 <strong>CentOS 8</strong> 的镜像。</p>
<p>刻录--安装--等待--卡死</p>
<p>Again</p>
<p>开机--安装--等待--卡死</p>
<p>? ? ?我真的是......一点办法都没有</p>
<p>这结果属实有点意外呀，怎么 <strong>CentOS 8</strong> 也是这个鸟样？</p>
<p>我不甘，又换了一个 <strong>Ubuntu 18</strong></p>
<p>刻录--安装--等待--卡死</p>
<p>卧槽，这是什么问题换系统 都不行，应该就不是软件的问题了吧，我就从主板开始动刀，会不会是因为主板的 <strong>BIOS</strong> 太老了，本来打算去更新一下 <strong>BIOS</strong> 结果，这是一个不知名的小板，不知道从哪里搞到 <strong>BIOS</strong> 文件，就放弃了！</p>
<p>然后去百度 <em>为什么电脑安装 Linux 卡顿</em></p>
<p>众所周知，百度相当垃圾，大部分都是答非所问，要不然就是 <del>CSDN,简书</del> 的水贴，都没有用 <strong>:(</strong></p>
<p>然后我又找隔壁 二狗子 意念扶梯子，用 Google 搜一下</p>
<p>然后我就在国外某个被大陆 404 的的技术论坛上找到了一点线索 ? ? ?</p>
<p>贴子网址： <a href="https://askubuntu.com/questions/803640/system-freezes-completely-with-intel-bay-trail" target="_blank">askubuntu</a></p>
<p>反正他们大概说的是 <strong>Bay Trail</strong> 主板上安装 Linux 出现的各种异常，刚刚好我的主板也是，出现的问题也和他们的很相似</p>
<p>在这里截取一些解决方法：</p>
<pre><code class="language-shell">#Your processor is affected by the c-state bug

#This causes total freezes when the CPU tries to enter an unsupported sleep state. It's a problem for many Bay Trail devices especially with newer (4.*) kernels.

#Affected processors AFAIK:

#Atom Z3735F (Asus X205TA, Acer Aspire Switch 10, Lenovo MIIX 3 1030)
#Atom Z3735G
#Celeron J1900 (Asus ET2325IUK, shuttle XS35V4)
#Celeron N2940 (Acer Aspire ES1-711, Chromebook)
#Celeron N2840 (Acer Aspire ES1-311)
#Celeron N2930 (Jetway JBC311U93, Zotac Nano CI320)
#Pentium N3520
#Pentium N3530 (Acer V3-111P)
#Pentium N3540 (Dell Inspiron 15 3000, Lenovo G50, ASUS X550MJ)
#(please (suggest an) edit to add your own device if affected)

#Complete list of Bay Trail processors may be found here

#There is a simple workaround for this until it gets properly fixed upstream.

#You just need to pass a kernel boot parameter and the random freezing stops completely. The parameter may increase battery consumption slightly, but it will give you a usable system.

#You do this by editing the configuration file for GRUB:

#Boot Ubuntu and open a terminal by pressing Ctrl+Alt+T then type

sudo nano /etc/default/grub
#Find the line that starts GRUB_CMDLINE_LINUX_DEFAULT=

#This needs to be changed to include intel_idle.max_cstate=1

#So after your edit it reads something like

GRUB_CMDLINE_LINUX_DEFAULT="quiet splash intel_idle.max_cstate=1"
#quiet and splash are default parameters for Ubuntu Desktop - no need to change them, or any other pre-existing parameters

#Now save the file by pressing ctrl+o then enter and exit by pressing ctrl+x

#Now run

sudo update-grub
#Then reboot.

#What to do if you don't have enough time to do this before the system hangs

#No problem. As explained on the help page I linked to earlier, you can add the parameter to GRUB before booting. Note that this only passes the parameter for the current boot, so you still have to edit /etc/default/grub once you have booted to make the change permanent.

#You need to get to the GRUB menu. If you are dual booting this will appear anyway, if not you have to press and hold (or tap) shift after pressing the power button to turn on.

#When you get to this screen select Advanced Options for Ubuntu. You can move the cursor to a different kernel, or leave it in place to edit options for the default. Instead of pressing enter, press e and you will go into edit mode, looking vaguely like this.

#Move the cursor down to where it says quiet splash, put a space after splash and carefully type intel_idle.max_cstate=1 making sure there is a space after it as well.
</code></pre>
<p>反正大概意思就是这种主板有残疾，在引导的时候会导致一些问题，需要加上这些参数就可以了</p>
<p>至此，这个烦了我将近半个月的问题没有了，就在引导的时候加了几个参数，鼠标正常了，键盘也可以用了，也不会卡顿了</p>]]></description>
      <author>JokerLee</author>
      <guid>https://jokeme.top/articles/2020/03/16/1584344826236.html</guid>
      <category>intel</category>
      <category>Linux</category>
      <pubDate>Wed, 06 May 2020 00:26:42 +0800</pubDate>
    </item>
    <item>
      <title>Docker 中运行 OpenWrt</title>
      <link>https://jokeme.top/articles/2020/03/20/1584702695341.html</link>
      <description><![CDATA[<h1>Docker  中运行  OpenWrt</h1>
<p>前几天解决了小主机 <strong>Ubuntu</strong> 系统的引导问题以后。便开始折腾 <strong>OpenWrt</strong> 了，在 <strong>GitHub</strong> 上找到了 <strong>L 大</strong> 的 <strong><a href="https://github.com/coolsnowwolf/lede" target="_blank">Lede</a></strong> 源码，需要自己编译。</p>
<p>关于如何编译我也不说了，<strong>L 大</strong> 在 Readme 里面说的清清楚楚的，没有难度，就是需要有耐心和良好的网络环境，编译过程会很慢(建议扶梯子，我没有用梯子，整整编译了两天才完成！? ? ?) 也可以用我编译好的 <strong><a href="https://github.com/jokefrelon/linux-series/releases" target="_blank">x86_64</a></strong> 的固件(集成有<strong>ssr,v2ray,adblock plus,samba,vsftpd</strong>等常用插件)</p>
<p>对于编译出来的文件我来介紹一下：</p>
<table>
<thead>
<tr><th align="center"><strong>openwrt-x86-64-rootfs-squashfs.img</strong></th><th align="center">OpenWrt for Docker の img</th></tr>
</thead>
<tbody>
<tr><td align="center"><strong>openwrt-x86-64-combined-squashfs.vmdk</strong></td><td align="center"><strong>虚拟机文件，丢进 VMware 里面使用</strong></td></tr>
<tr><td align="center"><strong>openwrt-x86-64-combined-squashfs.img</strong></td><td align="center"><strong>我们编译的固件，刻录到 u 盘上来安装</strong></td></tr>
</tbody>
</table>
<p>我一开始也不知道这些镜像应该选哪一个刻录，然后爬各种论坛终于被我发现了这几个文件的用法了</p>
<p>好！环境已经没有问题，安装包也有了，那就先在 <strong>Docker</strong> 里面试试看这个 <strong>OpenWrt</strong> 怎么样吧</p>
<h2>1 导入 OpenWrt 的镜像</h2>
<pre><code>cd ~/lede/bin/targets/x86/64
mkdir -p ~/opt
mount -o loop openwrt-x86-64-rootfs-squashfs.img ~/opt
tar -cvzf ~/Openwrt.tar.gz ~/opt/* 
docker import ~/OpenWrt.tar.gz OpenWrt
</code></pre>
<h2>2 Docker 创建网络</h2>
<pre><code>docker network create -d macvlan --subnet=192.168.100.0/24 --gateway=192.168.100.1 -o parent=enp2s0 fet
</code></pre>
<p>这个 IP 地址需要根据你的实际 IP 更改，网卡也一样，不能照抄</p>
<h2>3 Docker 运行容器</h2>
<pre><code>docker run -d --name lede --network fet --privileged OpeenWrt /sbin/init
</code></pre>
<p>在这里我一开始参考 <strong><a href="https://openwrt.org/zh/docs/guide-user/virtualization/docker_openwrt_image" target="_blank">OpenWrt 官方文档</a></strong>,结果一直报错，我一开始以为是他给的例子 ?里面系统太老，我就换成 19.10,依旧报错，然后在网上瞎转悠的时候看到了一篇来自 <a href="https://mlapp.cn/376.html" target="_blank"><strong>美丽应用</strong></a> 的文章，虽然，他是在 <strong>树莓派</strong> 当中安装 <strong>OpenWrt</strong> 但是过程大多一样 (感谢 <strong>美丽应用</strong> ?)</p>
<p>到这时，我们可以</p>
<pre><code>docker ps
[sudo] frelon 的密码：
CONTAINER ID	IMAGE		COMMAND		CREATED		STATUS		PORTS		NAMES
4fe146d86277	OpenWrt		"/sbin/init" 2 hours ago  Up 2 hours			  lede
</code></pre>
<p>看一下我们的容器是否在正常运行，如果还在运行，那就说明容器没有问题可以进行下一步了</p>
<h2>4 进入 OpenWrt 容器内，进一步配置</h2>
<pre><code>docker exec -it lede /bin/ash
</code></pre>
<p>这里要注意的是 <strong>/bin/ash</strong> 而不是 <strong>/bin/bash</strong></p>
<h3>4.1 配置网络</h3>
<h4>4.1.1 查看一下 <strong>IP</strong></h4>
<pre><code>/ # ip a
1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
25: eth0@if2: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc noqueue state DOWN group default
    link/ether 02:42:c0:a8:64:02 brd ff:ff:ff:ff:ff:ff link-netnsid 0
</code></pre>
<p>稍等片刻</p>
<pre><code>/ # ip a
1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host
       valid_lft forever preferred_lft forever
4: br-lan: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default qlen 1000
    link/ether 02:42:c0:a8:64:02 brd ff:ff:ff:ff:ff:ff
    inet 192.168.1.1/24 brd 192.168.1.255 scope global br-lan
       valid_lft forever preferred_lft forever
25: eth0@if2: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue master br-lan state UP group default                                                                  link/ether 02:42:c0:a8:64:02 brd ff:ff:ff:ff:ff:ff link-netnsid 0

</code></pre>
<h4>4.1.2 简易修改防火墙规则</h4>
<pre><code>opkg update
opkg install nano
nano /etc/config/firewall
</code></pre>
<p>找到 <strong>config zone</strong> 重点是把 <strong>option input/output/forward</strong> の <strong>REJRECT</strong> 改为 <strong>ACCEPT</strong></p>
<pre><code>config zone
        opion name 'wan'
        list network 'wan'
        list network 'wan6'
        option input 'ACCEPT'
        option output 'ACCEPT'
        option forward 'ACCEPT'
        option masq '1'
        option mtu_fix '1'
</code></pre>
<p>然后重启一下</p>
<pre><code>/etc/init.d/firewall restart
</code></pre>
<p>正常情况会报一堆错，无视即可</p>
<h4>4.1.3 修改网口</h4>
<pre><code>nano /etc/config/network
</code></pre>
<p>可以看到 <strong>interface lan</strong> 使用的是 <strong>eth0</strong></p>
<p>然后又添加了一个网络进该容器，并分配给 <strong>interface wan</strong> 充当 <strong>eth1</strong></p>
<pre><code>config interface 'lan'
        option type 'bridge'
        option ifname 'eth0'
        option proto 'static'
        option ipaddr '192.168.1.1'
        option netmask '255.255.255.0'
        option ip6assign '60'
        option gateway '192.168.100.105'

config interface 'wan'
        option ifname 'eth1'
        option proto 'dhcp'
</code></pre>
<p>看着修改就可以了</p>
<pre><code>/etc/init.d/network restart
</code></pre>
<h3>4.2 网页登录</h3>
<p>查看容器分配的 ip,在网页中打开，正常情况下是可以打开的，</p>
<p>输入默认密码 ?<strong>password</strong>  就可以看到 <strong>OpenWrt</strong> の 状态信息</p>
<h3>4.3 再添加一个网口到 OpenWrt 容器</h3>
<pre><code>docker network connect bridge OpenWrt
docker exec -it OpenWrt /etc/init.d/network restart
</code></pre>
<p>由于前面已经把 <strong>eth1</strong> 写入到配置信息里面，我们现在只需要重启一下网络即可，至此 <strong>OpenWrt</strong> の基本配置已经完成</p>
<p>如果需要配置 <strong>OpenWrt</strong> 旁路网关，建议参考上文提到的 <a href="https://mlapp.cn/376.html" target="_blank">美丽应用</a></p>
<h3>ps:补充一下</h3>
<p>在实际使用中我发现，经常 <strong>opkg update</strong> 失败 但是网络却是没有任何问题，网关也可以  <strong>ping</strong> 通，然后就发现了 <strong>OpenWrt for Docker</strong> 的一个小 Bug</p>
<p>每一次重启(有时候退出容器)就会重置 <strong>/etc/resolv.conf</strong> ,而这个文件就是我们的 DNS 文件！所以我们在使用域名 の时候就会出现失败</p>
<p>我也试过在  <strong>/etc/config/network</strong> 里面设置  <strong>DNS</strong>,也同样会被重置，我不知道这是为什么，只能在每次重启以后写个脚本，设置一下<strong>DNS</strong></p>
<p><strong>本文参考资料来源：</strong></p>
<ol>
<li>Lean · coolsnowwolf/lede - GitHub : <a href="https://github.com/coolsnowwolf/lede" target="_blank">https://github.com/coolsnowwolf/lede</a></li>
<li>OpenWrt 官方帮助文档 :  <a href="https://openwrt.org/zh/docs/guide-user/virtualization/docker_openwrt_image" target="_blank">https://openwrt.org/zh/docs/guide-user/virtualization/docker_openwrt_image</a></li>
<li>美丽应用 :  <a href="https://mlapp.cn/376.html" target="_blank">https://mlapp.cn/376.html</a></li>
</ol>]]></description>
      <author>JokerLee</author>
      <guid>https://jokeme.top/articles/2020/03/20/1584702695341.html</guid>
      <category>OpenWrt</category>
      <category>Docker</category>
      <category>Linux</category>
      <pubDate>Wed, 06 May 2020 00:26:29 +0800</pubDate>
    </item>
    <item>
      <title>一辈子都不想安装系统了!</title>
      <link>https://jokeme.top/articles/2020/03/31/1585624128468.html</link>
      <description><![CDATA[<h1>安装 Linux 系统(Ubuntu)经验总结</h1>
<p>进来将近两三个星期的装系统经历，让我异常痛苦，先是 <strong>Bay Trail</strong> 主板的一些坑，然后是显卡驱动，然后又是一堆莫名其妙的问题......</p>
<h3>1. Bay Trail 主板的先天问题</h3>
<p>在 这系列主板上安装 Windows 可能没有什么感觉，但是安装 Linux 异常的难，会造成啥啥啥内核错误，导致卡慢</p>
<p>需要在引导的后面 加上一句</p>
<pre><code>intel_idle.max_cstate=1
</code></pre>
<h3>2. 显卡驱动问题</h3>
<p>在安装 Linux 时，常常会遇到没有对应显卡驱动的问题，这时候就要在引导的时候加上</p>
<pre><code>nomodeset
</code></pre>
<h3>3. 开机卡紫屏问题</h3>
<p>这个问题原因可能各不一样，网上一大推，不赘述</p>
<h3>4.开机卡只有鼠标和壁纸</h3>
<p>说实话这个问题最好解决了，鼠标键盘都可以正常使用，<strong>ctrl + alt + t</strong> 打开 terminal,把 <strong>gnome</strong> 删掉即可，如果喜欢用图形界面还可以在重启以后在安装回来</p>]]></description>
      <author>JokerLee</author>
      <guid>https://jokeme.top/articles/2020/03/31/1585624128468.html</guid>
      <category>Linux</category>
      <pubDate>Wed, 06 May 2020 00:25:54 +0800</pubDate>
    </item>
    <item>
      <title> Ubuntu安装ffmpeg下载m3u8格式的视频</title>
      <link>https://jokeme.top/articles/2020/04/15/1586944809634.html</link>
      <description><![CDATA[<h1>Ubuntu 安装 <strong>FFMPEG</strong> 下载 m3u8 格式的视频</h1>
<p>最近想下载一个某音视频，但是我能看不能下载，这不是扯吗？于是不能忍的我就打算盘盘这个视频</p>
<h2>1 . 准备环境：Ubuntu 18.04 , FFMPEG</h2>
<p>本着万物皆可 <strong>Linux</strong> の初心，我就不想用 Windows 了。</p>
<p>首先安装 <strong>FFMPEG</strong></p>
<pre><code class="language-shell">sudo apt -y install ffmpeg
</code></pre>
<h2>2 . 抓包短视频的 m3u8 地址</h2>
<p>iOS 端，我是使用的 <strong>Thor</strong> 这个 app,比较好用，应用商店搜索就有</p>
<p>然后得到真实的地址：</p>
<pre><code class="language-http">http://XXX.com/xxx/xxx.m3u8
</code></pre>
<h2>3 . 使用 <strong>FFMPEG</strong> 进行下载</h2>
<pre><code class="language-shell">ffmpeg -i http://XXX.com/xxx/xxx.m3u8 -c copy xxx.mp4
</code></pre>
<p>然后就需要慢慢等待下载完成就可以了，真的是特别特别的简单</p>]]></description>
      <author>JokerLee</author>
      <guid>https://jokeme.top/articles/2020/04/15/1586944809634.html</guid>
      <category>ffmpeg</category>
      <category>Linux</category>
      <pubDate>Wed, 06 May 2020 00:25:24 +0800</pubDate>
    </item>
    <item>
      <title>Solo最简安装</title>
      <link>https://jokeme.top/articles/2019/12/05/1575541246758.html</link>
      <description><![CDATA[<h1>Solo 安装 ❤️</h1>
<p>最近突然就想搭建一个自己的 Blog 服务器用来写一些自己的学习经验和解决问题的方法，刚刚好之前在<strong>GitHub</strong>上看到了一个叫<strong>Solo</strong>的 Blog 系统，而且颜值也很高，我就打算用这个</p>
<p><strong>Solo</strong>的<a href="https://github.com/88250/solo" target="_blank">Github</a>链接</p>
<p>我的憨憨部署步骤</p>
<ol>
<li>
<h3>选择服务器</h3>
</li>
</ol>
<p>因为我就打算一个人用，不打算给别人浏览学习的机会(主要还是自己菜，穷)</p>
<p>就在实验室的服务器上搭建<strong>Solo</strong> 成本 0$<br>
2.  ### 域名的选择与备案</p>
<p>因为是局域网内访问，我就直接改的电脑<strong>Hosts</strong>文件<br>
3.  ### Linux 系统选择</p>
<p><strong>Solo</strong>官方是推荐用<strong>CentOS</strong>的服务器</p>
<p>我没有用特意安装一个<strong>Linux</strong>系统的服务器而是选择了大微软最近推出的<strong>Ubuntu-WSL2</strong> 搭建，这样我既可以用<strong>Windows</strong>又可以用<strong>Linux</strong>系统 ,比较方便</p>
<p>说到<strong>WSL2</strong>我真的是太喜欢了，以前的 <strong>WSL1</strong> 还不能用<strong>Docker</strong> ,而<strong>WSL2</strong>是基于底层的<strong>Linux</strong>内核虚拟，支持运行<strong>Docker</strong>了，还保留了<strong>WSL1</strong>和<strong>Windows</strong>的互交方式，可以在资源管理器 直接访问</p>
<pre><code class="language-log">\\wsl$
</code></pre>
<p>就可以看到<strong>Linux</strong>的文件系统，真的特别方便<br>
4.  ### 安装 Docker</p>
<pre><code class="language-shell">sudo su

apt update

apt -y install docker

service  docker start

docker run hello-world
#测试运行 hello-world
</code></pre>
<ol start="5">
<li>
<h3>安装 MySQL</h3>
</li>
</ol>
<pre><code class="language-shell"> docker run --name mysql -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 -d mysql:5.6
 # 安装mysql:5.6,直接docker run 他会自动去官方镜想下载
 # MYSQL_ROOT_PASSWORD=你的数据库密码
 
 docker exec -it mysql bash
 # docker安装的mysql默认允许远程连接，可以使用Navicat等软件连接数据库
 # 进入容器mysql
 
 mysql -uroot -p123456
 # 进入数据库 p后面跟你的密码
 
 create database solo DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci;
 # 创建数据库(数据库名:solo;字符集utf8mb4;排序规则utf8mb4_general_ci)
 # 出现Query OK, 1 row affected (0.00 sec)表示成功
 
 exit
 #退出数据库
 
 exit
 #退出容器
</code></pre>
<ol start="6">
<li>
<h3>安装 Solo</h3>
<pre><code class="language-shell">docker run --detach --name solo --network=host \
--env RUNTIME_DB="MYSQL" \
--env JDBC_USERNAME="root" \
--env JDBC_PASSWORD="123456" \
--env JDBC_DRIVER="com.mysql.cj.jdbc.Driver" \
--env JDBC_URL="jdbc:mysql://127.0.0.1:3306/solo?useUnicode=yes&amp;characterEncoding=UTF-8&amp;useSSL=false&amp;serverTimezone=UTC" \
b3log/solo --listen_port=8080 --server_scheme=http --server_host=172.17.151.7
</code></pre>
<ul>
<li><code>--env JDBC_PASSWORD="123456"</code> 将 123456 换成你的密码</li>
<li><code>--listen_port=8080</code> 监听的端口</li>
<li><code>--server_scheme=http</code> 请求方式，暂时使用 http，后面我们会换成 https</li>
<li><code>--server_host=www.jinjianh.com</code> 你的域名，如果你没有域名可以写 ip 地址</li>
<li><code>--rm</code> 因为这个容器后面要删掉，带上 rm 会省很多事。</li>
</ul>
<p>命令成功执行没有报错的话，通过 <code>docker ps</code> 查看执行的容器列表中是否存在 solo，存在这表示启动成功，直接访问你的域名加：8080 即可访问你的博客，<br>
如果你尚在备案中，你可以收藏本帖，后面等备案通过了在研究后面的部分。<br>
如果你不想使用 nginx 也不想升级 https，那么你可以先执行 <code>docker stop solo</code> ，然后将上面 <code>--listen_port=8080</code> 的 <code>8080</code> 换成 <code>80</code> ，然后去掉 <code>--rm</code> ，再执行一次就 ok。</p>
</li>
</ol>
<p>大概过程就这样了，因为就我一个人用，我也懒得搞后面的步骤，还要搭建<strong>Nginx</strong>,</p>
<p>官方安装步骤：<a href="https://hacpai.com/article/1565021959471" target="_blank">Solo安装</a></p>]]></description>
      <author>JokerLee</author>
      <guid>https://jokeme.top/articles/2019/12/05/1575541246758.html</guid>
      <category>Solo</category>
      <category>Docker</category>
      <category>Linux</category>
      <category>WSL2</category>
      <pubDate>Wed, 06 May 2020 00:24:56 +0800</pubDate>
    </item>
  </channel>
</rss>
